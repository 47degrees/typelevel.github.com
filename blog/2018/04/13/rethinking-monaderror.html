<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Rethinking MonadError</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Rethinking MonadError</h2>

  <p><code class="highlighter-rouge">MonadError</code> is a very old type class, hackage shows me it was originally added in 2001, long before I had ever begun doing functional programming, just check the <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Error-Class.html">hackage page</a>.
In this blog post I’d like to rethink the way we use <code class="highlighter-rouge">MonadError</code> today.
It’s usually used to signal that a type might be capable of error handling and is basically like a type class encoding of <code class="highlighter-rouge">Either</code>s ability to short circuit.
That makes it pretty useful for building computations from sequences of values that may fail and then halt the computation or to catch those errors in order to resume the computation.
It’s also parametrized by its error type, making it one of the most common example of multi-parameter type classes.
Some very common instances include <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">IO</code>, but there are a ton more.</p>

<p>We can divide instances into 3 loosely defined groups:</p>

<p>First we have simple data types like <code class="highlighter-rouge">Either</code>, <code class="highlighter-rouge">Option</code> or <code class="highlighter-rouge">Ior</code> (with <code class="highlighter-rouge">Validated</code> not having a <code class="highlighter-rouge">Monad</code> instance).</p>

<p>Secondly we’ve got the <code class="highlighter-rouge">IO</code>-like types, the various <code class="highlighter-rouge">IO</code>s, <code class="highlighter-rouge">Task</code>s and the like. These are used to suspend side effects which might have errors and therefore need to be able to handle these.</p>

<p>Thirdly and least importantly, we have monad transformers, which get their instances from their respective underlying monads. Since they basically just propagate their underlying instances we’re only going to talk about the first two groups for now.</p>

<p>The simple data types all define <code class="highlighter-rouge">MonadError</code> instances, but I wager they’re not actually used as much. This is because <code class="highlighter-rouge">MonadError</code> doesn’t actually allow us to deconstruct e.g. an <code class="highlighter-rouge">Either</code> to actually handle the errors. We’ll see more on that later, next let’s look at the <code class="highlighter-rouge">IO</code>-like types and their instances.</p>

<p><code class="highlighter-rouge">cats.effect.IO</code> currently defines a <code class="highlighter-rouge">MonadError[IO, Throwable]</code>, meaning that it’s fully able to raise and catch errors that might be thrown during evaluation of encapsulated side effects.
Using <code class="highlighter-rouge">MonadError</code> with these effect types seems a lot more sensical at first, as you can’t escape <code class="highlighter-rouge">IO</code> even when you handle errors, so it looks like it makes sense to stay within <code class="highlighter-rouge">IO</code> due to the side effect capture.</p>

<p>The problem I see with <code class="highlighter-rouge">MonadError</code> is that it does not address the fundamental difference between these two types of instances. I can pattern match an <code class="highlighter-rouge">Option[A]</code> with a default value to get back an <code class="highlighter-rouge">A</code>. With <code class="highlighter-rouge">IO</code> that is just not possible. So these two groups of types are pretty different, when does it actually make sense to abstract over both of them?
Well, it turns out there a few instances where it might be useful, but as we’ll see later, I’m proposing something that will be equally useful to both groups.</p>

<p>Now before we continue, let’s look at the <code class="highlighter-rouge">MonadError</code> type class in a bit more detail.
<code class="highlighter-rouge">MonadError</code> currently comprises two parts, throwing and catching errors.
To begin let’s have a look at the <code class="highlighter-rouge">throw</code> part, sometimes also called <code class="highlighter-rouge">MonadThrow</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks fine for now, but one thing that strikes me is that the <code class="highlighter-rouge">F</code> type seems to “swallow” errors.
If we look at <code class="highlighter-rouge">F[A]</code> we have no clue that it might actually yield an error of type <code class="highlighter-rouge">E</code>, that fact is not required to be represented at all.
However, that’s not a really big issue, so now let’s look at the <code class="highlighter-rouge">catch</code> part:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">MonadThrow</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Immediately I have a few questions, if the errors are handled, why does it return the exact same type?
Furthermore if this is really supposed to handle errors, what happens if I have errors in the <code class="highlighter-rouge">E =&gt; F[A]</code> function? 
This is even more blatant in the <code class="highlighter-rouge">attempt</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">attempt</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here there is no way the outer <code class="highlighter-rouge">F</code> still has any errors, so why does it have the same type?
Shouldn’t we represent the fact that we handled all the errors in the type system?
This means you can’t actually observe that the errors are now inside <code class="highlighter-rouge">Either</code>. That leads to this being fully legal code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="nc">Option</span><span class="o">(</span><span class="mi">42</span><span class="o">).</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span><span class="o">.</span><span class="n">attempt</span>
<span class="c1">// res0: Option[Either[Unit,Either[Unit,Either[Unit,Either[Unit,Int]]]]] = Some(Right(Right(Right(Right(42)))))
</span></code></pre></div></div>

<p>Another example that demonstrates this is the fact that calling <code class="highlighter-rouge">handleError</code>, which looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handleError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>
<p>also returns an <code class="highlighter-rouge">F[A]</code>. This method takes a pure function <code class="highlighter-rouge">E =&gt; A</code> and thus can not fail during recovery like <code class="highlighter-rouge">handleErrorWith</code>, yet it still doesn’t give us any sign that it doesn’t throw errors.
For <code class="highlighter-rouge">IO</code>-like types this is somewhat excusable as something like an unexceptional <code class="highlighter-rouge">IO</code> is still very uncommon, but for simple data types like <code class="highlighter-rouge">Either</code> or <code class="highlighter-rouge">Some</code> that function should just return an <code class="highlighter-rouge">A</code>, since that’s the only thing it can be.
Just like with <code class="highlighter-rouge">attempt</code>, we can infinitely chain calls to <code class="highlighter-rouge">handleError</code>, as it will never change the type.</p>

<p>Ideally our type system should stop us from being able to write this nonsensical code and give us a way to show anyone reading the code that we’ve already handled errors.
Now I’m not saying that the functions on <code class="highlighter-rouge">MonadError</code> aren’t useful, but only that they could be more constrained and thus more accurate in their representation.</p>

<p>For this purpose let’s try to write a different <code class="highlighter-rouge">MonadError</code> type class, one that’s designed to leverage the type system to show when values are error-free, we’ll call it <code class="highlighter-rouge">MonadBlunder</code> for now.</p>

<p>To mitigate the problems with <code class="highlighter-rouge">MonadError</code> we have a few options, the first one I’d like to present is using two different type constructors to represent types that might fail and types that are guaranteed not to. So instead of only a single type constructor our <code class="highlighter-rouge">MonadBlunder</code> class will have two:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
</code></pre></div></div>

<p>Our type class now has the shape <code class="highlighter-rouge">(* -&gt; *) -&gt; (* -&gt; *) -&gt; * -&gt; *</code>, which is quite a handful, but I believe we can justify its usefulness.
The first type parameter <code class="highlighter-rouge">F[_]</code> will represent our error-handling type, which will be able to yield values of type <code class="highlighter-rouge">E</code>.
The second type parameter <code class="highlighter-rouge">G[_]</code> will represent a corresponding type that does not allow any errors and can therefore guarantee that computations of the form <code class="highlighter-rouge">G[A]</code> will always yield a value of type <code class="highlighter-rouge">A</code>.</p>

<p>Now that we figured out the shape, let’s see what we can actually do with it.
For throwing errors, we’ll create a <code class="highlighter-rouge">raiseError</code> function that should return a value inside <code class="highlighter-rouge">F</code>, as it will obviously be able to yield an error.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This definition looks identical to the one defined one <code class="highlighter-rouge">MonadError</code> so let’s move on to error-handling.
For handled errors, we want to return a value inside <code class="highlighter-rouge">G</code>, so our <code class="highlighter-rouge">handleErrorWith</code> function should indeed return a <code class="highlighter-rouge">G[A]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Looks good so far, right? 
Well, we still have the problem that <code class="highlighter-rouge">f</code> might return an erronous value, so if we want to guarantee that the result won’t have any errors, we’ll have to change that to <code class="highlighter-rouge">G[A]</code> as well:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And now we’re off to a pretty good start, we fixed one short coming of <code class="highlighter-rouge">MonadError</code> with this approach.</p>

<p>Another approach, maybe more obvious to some, might be to require the type constructor to take two arguments, one for the value and one for the error type.
Let’s see if we can define <code class="highlighter-rouge">raiseError</code> on top of it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">raiseError</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span>

  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks pretty similar to what we already have, though now we have the guarantee that our type doesn’t actually “hide” the error-type somewhere.
Next up is <code class="highlighter-rouge">handleErrorWith</code>. Ideally after we handled the error we should again get back a type that signals that it doesn’t have any errors. 
We can do exactly that by choosing an unhabited type like <code class="highlighter-rouge">Nothing</code> as our error-type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleErrorWith</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And this approach works as well, however now we’ve forced the two type parameter shape onto implementors. This <code class="highlighter-rouge">MonadBlunder</code> has the following kind <code class="highlighter-rouge">(* -&gt; * -&gt; *) -&gt; *</code>.
This means we can very easily define instances for types with two type parameters like <code class="highlighter-rouge">Either</code>.
However, one issue might be that it’s much easier to fit a type with two type parameters onto a type class that expects a single type constructor <code class="highlighter-rouge">(* -&gt; *)</code> than to do it the other way around.</p>

<p>For example try to implement the above <code class="highlighter-rouge">MonadBlunder[F[_, _]]</code> for the standard <code class="highlighter-rouge">cats.effect.IO</code>.
It’s not going to be simple, whereas with the first encoding we can easily encode both <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">IO</code>. For this reason, I will continue this article with the first encoding using the two different type constructors.</p>

<p>Next we’re going to look at laws we can define to make sense of the behaviour we want.
The first two laws should be fairly obvious. 
If we <code class="highlighter-rouge">flatMap</code> over a value created by <code class="highlighter-rouge">raiseError</code> it shouldn’t propogate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">raiseErrorStops</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">F</span><span class="o">.</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Next we’re going to formulate a law that states, that raising an error and then immediatly handling it with a given function should be equivalent to just calling that function on the error value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">raiseErrorHandleErrorWith</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">E</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">e</span><span class="o">).</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
</code></pre></div></div>

<p>Another law could state that handling errors for a pure value lifted into the <code class="highlighter-rouge">F</code> context does nothing and is equal to the pure value in the <code class="highlighter-rouge">G</code> context:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">handleErrorPureIsPure</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
</code></pre></div></div>

<p>Those should be good for now, but we’ll be able to find more when we add more derived functions to our type class.
Also note that none of the laws are set in stone, these are just the ones I came up with for now, it’s completely possible that we’ll need to revise these in the future.</p>

<p>Now let’s focus on adding extra functions to our type class. <code class="highlighter-rouge">MonadError</code> offer us a bunch of derived methods that can be really useful. For most of those however we need access to methods like <code class="highlighter-rouge">flatMap</code> for both <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code>, so before we figure out derived combinators, let’s revisit how exactly we define the type class.</p>

<p>The easiest would be to give both <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">G</code> a <code class="highlighter-rouge">Monad</code> constraint and move on. 
But then we’d have two type classes that both define a <code class="highlighter-rouge">raiseError</code> function extends <code class="highlighter-rouge">Monad</code>, and we wouldn’t be able to use them together, since that would cause ambiguities and as I’ve said before, the functions on <code class="highlighter-rouge">MonadError</code> are useful in some cases.</p>

<p>Instead, since I don’t really like duplication and the fact that we’re not going to deprecate <code class="highlighter-rouge">MonadError</code> overnight, I decided to extend <code class="highlighter-rouge">MonadBlunder</code> from <code class="highlighter-rouge">MonadError</code> for the <code class="highlighter-rouge">F</code> type, to get access to the <code class="highlighter-rouge">raiseError</code> function.
If <code class="highlighter-rouge">raiseError</code> and <code class="highlighter-rouge">handleErrorWith</code> were instead separated into separate type classes (as is currently the case in the PureScript prelude), we could extend only the <code class="highlighter-rouge">raiseError</code> part.
This also allows us to define laws that our counterparts of functions like <code class="highlighter-rouge">attempt</code> and <code class="highlighter-rouge">ensure</code> are consistent with the ones defined on <code class="highlighter-rouge">MonadError</code>.
So the type signature now looks like this (expressed in Haskell, since it’s easier on the eyes):</p>
<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="p">(</span><span class="kt">MonadError</span> <span class="n">f</span> <span class="n">e</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">g</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">MonadBlunder</span> <span class="n">f</span> <span class="n">g</span> <span class="n">e</span> <span class="o">|</span><span class="err"> </span><span class="n">f</span> <span class="o">-&gt;</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="kr">where</span>
  <span class="o">...</span>
</code></pre></div></div>

<p>In Scala, we can’t express this as nicely, so we’re going to have to use something close to the <code class="highlighter-rouge">cats-mtl</code> encoding:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now since this means that any instance of <code class="highlighter-rouge">MonadBlunder</code> will also have an instance of <code class="highlighter-rouge">MonadError</code> on <code class="highlighter-rouge">F</code>, we might want to rename the functions we’ve got so far.
Here’s a complete definition of what we’ve come up with with <code class="highlighter-rouge">raiseError</code> removed and <code class="highlighter-rouge">handleErrorWith</code> renamed to <code class="highlighter-rouge">handleBlunderWith</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let us go back to defining more derived functions for <code class="highlighter-rouge">MonadBlunder</code>.
The easiest probably being <code class="highlighter-rouge">handleError</code>, so let’s see if we can come up with a good alternative:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">handleBlunder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> 
    <span class="n">handleBlunderWith</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span> <span class="n">andThen</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">G</span><span class="o">]))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This one is almost exactly like <code class="highlighter-rouge">handleBlunderWith</code>, but takes a function from <code class="highlighter-rouge">E</code> to <code class="highlighter-rouge">A</code> instead of to <code class="highlighter-rouge">G[A]</code>. We can easily reuse <code class="highlighter-rouge">handleBlunderWith</code> by using <code class="highlighter-rouge">pure</code> to go back to <code class="highlighter-rouge">E =&gt; G[A]</code>.</p>

<p>Next another function that’s really useful is <code class="highlighter-rouge">attempt</code>.
Our alternative, let’s call it <code class="highlighter-rouge">endeavor</code> for now, should return a value in <code class="highlighter-rouge">G</code> instead, which doesn’t have a <code class="highlighter-rouge">MonadError</code> instance and therefore can not make any additional calls to <code class="highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">handleBlunder</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="nc">Right</span><span class="o">(</span><span class="k">_</span><span class="o">)))(</span><span class="nc">Left</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The implementation is fairly straightforward as well, we just handle all the errors by lifting them into the left side of an <code class="highlighter-rouge">Either</code> and map successful values to the right side of <code class="highlighter-rouge">Either</code>.</p>

<p>Next, let’s look at the dual to <code class="highlighter-rouge">attempt</code>, called <code class="highlighter-rouge">rethrow</code> in Cats. 
For <code class="highlighter-rouge">MonadError</code> it turns an <code class="highlighter-rouge">F[Either[E, A]]</code> back into an <code class="highlighter-rouge">F</code>, but we’re going to use our unexceptional type again:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="k">def</span> <span class="n">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But looking at this signature, we quickly realize that we need a way to get back to <code class="highlighter-rouge">F[A]</code> from <code class="highlighter-rouge">G[A]</code>.
So we’re going to add another function to our minimal definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">monadErrorF</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="k">val</span> <span class="n">monadG</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="o">}</span>
</code></pre></div></div>

<p>This function <code class="highlighter-rouge">accept</code>, allows us to lift any value without errors into a context where errors might be present.</p>

<p>We can now formulate a law that values in <code class="highlighter-rouge">G</code> never stop propagating, so <code class="highlighter-rouge">flatMap</code> should always work, we do this by specifying that calling <code class="highlighter-rouge">handleBlunder</code> after calling <code class="highlighter-rouge">accept</code> on any <code class="highlighter-rouge">G[A]</code>, is never going to actually change the value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">gNeverHasErrors</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="n">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">)</span> <span class="o">===</span> <span class="n">ga</span>
</code></pre></div></div>

<p>Now we can go back to implementing the <code class="highlighter-rouge">absolve</code> function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">absolve</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">gea</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">gea</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">raiseError</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="k">_</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]))</span>
</code></pre></div></div>

<p>Now that we’ve got the equivalent of both <code class="highlighter-rouge">attempt</code> and <code class="highlighter-rouge">rethrow</code>, let’s add a law that states that the two should cancel each other out:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">endeavorAbsolve</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">absolve</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="n">fa</span>
</code></pre></div></div>

<p>We can also add laws so that <code class="highlighter-rouge">handleBlunder</code> and <code class="highlighter-rouge">endeavor</code> are consistent with their counterparts now that we have <code class="highlighter-rouge">accept</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">deriveHandleError</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">handleBlunder</span><span class="o">(</span><span class="n">f</span><span class="o">))</span> <span class="o">===</span> <span class="n">fa</span><span class="o">.</span><span class="n">handleError</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>

<span class="k">def</span> <span class="n">deriveAttempt</span><span class="o">(</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">endeavor</span><span class="o">)</span> <span class="o">===</span> <span class="n">fa</span><span class="o">.</span><span class="n">attempt</span>
</code></pre></div></div>

<p>One nice thing about <code class="highlighter-rouge">attempt</code>, is that it’s really easy to add a derivative combinator that doesn’t go to <code class="highlighter-rouge">F[Either[E, A]]</code>, but to the isomorphic monad transformer <code class="highlighter-rouge">EitherT[F, E, A]</code>.
We can do the exact same thing with <code class="highlighter-rouge">endeavor</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">endeavorT</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">EitherT</span><span class="o">(</span><span class="n">endeavor</span><span class="o">(</span><span class="n">fa</span><span class="o">))</span>
</code></pre></div></div>

<p>One last combinator I’d like to “port” from <code class="highlighter-rouge">MonadError</code> is the <code class="highlighter-rouge">ensureOr</code> function.
<code class="highlighter-rouge">ensureOr</code> turns a successful value into an error if it does not satisfy a given predicate.
We’re going to name the counterpart <code class="highlighter-rouge">assureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">assureOr</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">predicate</span><span class="o">(</span><span class="n">a</span><span class="o">))</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">else</span> <span class="n">raiseError</span><span class="o">(</span><span class="n">error</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">)</span>
</code></pre></div></div>

<p>This plays nicely with the rest of our combinators and we can again add a law that dictates it must be consistent with <code class="highlighter-rouge">ensureOr</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">deriveEnsureOr</span><span class="o">(</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">error</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">E</span><span class="o">)(</span><span class="n">predicate</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="n">ensureOr</span><span class="o">(</span><span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">))(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span> <span class="o">===</span> <span class="n">assureOr</span><span class="o">(</span><span class="n">ga</span><span class="o">)(</span><span class="n">error</span><span class="o">)(</span><span class="n">predicate</span><span class="o">)</span>
</code></pre></div></div>

<p>Now we have a great base to work with laws that should guarantee principled and sensible behaviour.
Next we’ll actually start defining some instances for our type class.</p>

<p>The easiest definitions are for <code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">Option</code>, though I’m not going to cover both, as the instances for <code class="highlighter-rouge">Option</code> can simply be derived by <code class="highlighter-rouge">Either[Unit, A]</code>and I’m going to link to the code at the end.
For <code class="highlighter-rouge">Either[E, A]</code>, when we handle all errors of type <code class="highlighter-rouge">E</code>, all we end up with is <code class="highlighter-rouge">A</code>, so the corresponding <code class="highlighter-rouge">G</code> type for our instance should be <code class="highlighter-rouge">Id</code>.
That leaves us with the following definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">monadBlunderEither</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Id</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">Id</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">fa</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Right</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Fairly straightforward, as <code class="highlighter-rouge">Id[A]</code> is just <code class="highlighter-rouge">A</code>, but with this instance we can already see a small part of the power we gain over <code class="highlighter-rouge">MonadError</code>.
When we handle errors with <code class="highlighter-rouge">handleBlunder</code>, we’re no longer “stuck” inside the <code class="highlighter-rouge">Either</code> Monad, but instead have a guarantee that our value is free of errors.
Sometimes it’ll make sense to stay inside <code class="highlighter-rouge">Either</code>, but we can easily get back into <code class="highlighter-rouge">Either</code>, so we have full control over what we want to do.</p>

<p>Next up, we’ll look at <code class="highlighter-rouge">IO</code> and the type that inspired this whole blog post <code class="highlighter-rouge">UIO</code>.
<code class="highlighter-rouge">UIO</code> is equivalent to an <code class="highlighter-rouge">IO</code> type where all errors are handled and is short for “unexceptional IO”.
<code class="highlighter-rouge">UIO</code> currently lives inside my own <code class="highlighter-rouge">cats-uio</code> library, but if things go well, we might see it inside <code class="highlighter-rouge">cats-effect</code> eventually. This would also work for <code class="highlighter-rouge">IO</code> types who use two type parameters <code class="highlighter-rouge">IO[E, A]</code> where the first represents the error type and the second the actual value. There you’d choose <code class="highlighter-rouge">IO[E, A]</code> as the <code class="highlighter-rouge">F</code> type and <code class="highlighter-rouge">IO[Nothing, A]</code> as the <code class="highlighter-rouge">G</code> type. <code class="highlighter-rouge">IO[Nothing, A]</code> there is equivalent to <code class="highlighter-rouge">UIO[A]</code>.</p>

<p>As one might expect, you can not simply go from <code class="highlighter-rouge">IO[A]</code> to <code class="highlighter-rouge">UIO[A]</code>, but we’ll need to go from <code class="highlighter-rouge">IO[A]</code> to <code class="highlighter-rouge">UIO[Either[E, A]]</code> instead, which if you look at it, is exactly the definition of <code class="highlighter-rouge">endeavor</code>.
Now let’s have a look at how the <code class="highlighter-rouge">MonadBlunder</code> instance for <code class="highlighter-rouge">IO</code> and <code class="highlighter-rouge">UIO</code> looks:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">monadBlunderIO</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="k">=</span> 
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">UIO</span>, <span class="kt">Throwable</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Throwable</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">UIO</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Throwable</span> <span class="o">=&gt;</span> <span class="nc">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">UIO</span><span class="o">.</span><span class="n">unsafeFromIO</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">handleErrorWith</span><span class="o">(</span><span class="n">f</span> <span class="n">andThen</span> <span class="n">accept</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">UIO</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IO</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">UIO</span><span class="o">.</span><span class="n">runUIO</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And voila! We’ve got a fully working implementation that will allow us to switch between these two types whenever we have a guarantee that all errors are handled.
This makes a lot of things much simpler.
For example, if one wants to use <code class="highlighter-rouge">bracket</code> with <code class="highlighter-rouge">UIO</code>, you just need to <code class="highlighter-rouge">flatMap</code> to the finalizer, as <code class="highlighter-rouge">flatMap</code> is always guaranteed to not short-circuit.</p>

<p>We can also define instances for <code class="highlighter-rouge">EitherT</code> and <code class="highlighter-rouge">OptionT</code> (being isomorphic to <code class="highlighter-rouge">EitherT[F, Unit, A]</code>), where the corresponding unexceptional type is just the outer <code class="highlighter-rouge">F</code>, so <code class="highlighter-rouge">endeavor</code> is just a call to <code class="highlighter-rouge">.value</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">catsEndeavorForEitherT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">endeavor</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Either</span><span class="o">[</span><span class="kt">E</span>, <span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Left</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Right</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
      <span class="o">}</span>

    <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">EitherT</span><span class="o">.</span><span class="n">liftF</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>

  <span class="o">}</span>
</code></pre></div></div>

<p>Finally, it’s also possible to create instances for other standard monad transformers like <code class="highlighter-rouge">WriterT</code>, <code class="highlighter-rouge">ReaderT</code> or <code class="highlighter-rouge">StateT</code> as long as their underlying monads themselves have instances for <code class="highlighter-rouge">MonadBlunder</code>, as is typical in mtl.
As their implementations are very similar we’ll only show the <code class="highlighter-rouge">StateT</code> transformer instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">catsEndeavorForStateT</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span>, <span class="kt">E</span><span class="o">]</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">M</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">E</span><span class="o">])</span><span class="k">:</span> <span class="kt">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MonadBlunder</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">F</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">E</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">monadErrorF</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">G</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">monadG</span>

      <span class="k">val</span> <span class="n">monadErrorF</span> <span class="k">=</span> <span class="nc">MonadError</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span>
      <span class="k">val</span> <span class="n">monadG</span> <span class="k">=</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">?</span><span class="o">]]</span>

      <span class="k">def</span> <span class="n">accept</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">ga</span><span class="o">.</span><span class="n">mapK</span><span class="o">(</span><span class="k">new</span> <span class="o">(</span><span class="n">G</span> <span class="o">~&gt;</span> <span class="n">F</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ga</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span><span class="o">.</span><span class="n">accept</span><span class="o">(</span><span class="n">ga</span><span class="o">)</span>
      <span class="o">})</span>

      <span class="k">def</span> <span class="n">handleBlunderWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">E</span> <span class="o">=&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">S</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">IndexedStateT</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">handleBlunderWith</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">))(</span><span class="n">e</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">e</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">s</span><span class="o">)))</span>

    <span class="o">}</span>
</code></pre></div></div>

<p>In practice this means we can call <code class="highlighter-rouge">handleBlunderWith</code> on things like <code class="highlighter-rouge">StateT[IO, S, A]</code> and get back a <code class="highlighter-rouge">StateT[UIO, S, A]</code>. Pretty neat!
You can also create instances for pretty much any <code class="highlighter-rouge">MonadError</code> using <code class="highlighter-rouge">Unexceptional</code>, e.g.: <code class="highlighter-rouge">MonadBlunder[Future, Unexceptional[Future, ?], Throwable]</code>. The <code class="highlighter-rouge">Unexceptional</code> type is designed to turn any erroring type into one that doesn’t throw errors by catching them with <code class="highlighter-rouge">attempt</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, I’ve tried to present the argument that <code class="highlighter-rouge">MonadError</code> is insufficient for principled error handling.
We also tried to build a solution that deals with the shortcomings described earlier.
Thereby it seeks not to replace, but to expand on <code class="highlighter-rouge">MonadError</code> to get a great variety of error handling capabilities.
I believe the <code class="highlighter-rouge">MonadBlunder</code> type class, or whatever it will be renamed to, can be a great addition not just to the Cats community, but to the functional community at large, especially as it’s much easier to express in languages like <code class="highlighter-rouge">PureScript</code> and <code class="highlighter-rouge">Haskell</code>.</p>

<p>For now, all of the code lives inside the <a href="https://github.com/LukaJCB/cats-uio">cats-uio repo</a>, which houses the <code class="highlighter-rouge">MonadBlunder</code> type class the <code class="highlighter-rouge">UIO</code> data type and the <code class="highlighter-rouge">Unexceptional</code> data type.
I hope that this blog post gave a motivation as to why I created the library and why it might be nice to adopt some of its features into the core typelevel libraries.</p>

<p>Note again, that none of this is final or set in stone and before it arrives anywhere might still change a lot, especially in regards to naming (which I’m not really happy with at the moment), so if you have any feedback of any sorts, please do chime in! Would love to hear your thoughts and thank you for reading this far!</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/lukajacobowitz.jpg" />
      
      <p>by Luka Jacobowitz
    
    on Apr 13, 2018</p>

    
  <a href="https://twitter.com/LukaJacobowitz" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @LukaJacobowitz</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/LukaJCB" aria-label="Follow @LukaJCB on GitHub">Follow @LukaJCB</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
