<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Tagless Final algebras and Streaming</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Tagless Final algebras and Streaming</h2>

  <p>There have been a couple of really <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">nice blog posts</a> about <code class="highlighter-rouge">Tagless Final</code> and some related topics. However, I have faced some design problems when writing some algebras and haven’t seen anybody talking about. So please let me introduce this problem to you.</p>

<h3 id="algebra-definition">Algebra definition</h3>

<p>Given the following data definition:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">ItemName</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Item</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">,</span> <span class="n">price</span><span class="k">:</span> <span class="kt">BigDecimal</span><span class="o">)</span>
</code></pre></div></div>

<p>Consider the following algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s go through each method’s definition:</p>

<ul>
  <li><code class="highlighter-rouge">findAll</code> needs to return many Items, obtainable inside a context: <code class="highlighter-rouge">F[List[Item]]</code>.</li>
  <li><code class="highlighter-rouge">find</code> might or might not return an Item inside a context: <code class="highlighter-rouge">F[Option[Item]]</code>.</li>
  <li><code class="highlighter-rouge">save</code> and <code class="highlighter-rouge">remove</code> will perform some actions without returning any actual value: <code class="highlighter-rouge">F[Unit]</code>.</li>
</ul>

<p>Everything is clear and you might have seen this kind of pattern before, so let’s create an interpreter for it:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">cats.effect.Sync</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">PostgreSQLItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                    <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">to</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">unit</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Here we are using <a href="http://tpolecat.github.io/doobie/">Doobie</a>, defined as <code class="highlighter-rouge">A principled JDBC layer for Scala</code> and one of the most popular DB libraries in the Typelevel ecosystem. And it comes with one super powerful feature: it supports <code class="highlighter-rouge">Streaming</code> results, since it’s built on top of <a href="https://functional-streams-for-scala.github.io/fs2/">fs2</a>.</p>

<p>Now it could be very common to have a huge amount of <code class="highlighter-rouge">Item</code>s in our DB that a <code class="highlighter-rouge">List</code> will not fit into memory and / or it will be a very expensive operation. So we might want to stream the results of <code class="highlighter-rouge">findAll</code> instead of have them all in memory on a <code class="highlighter-rouge">List</code>, making <code class="highlighter-rouge">Doobie</code> a great candidate for the job. But wait… We have a problem now. Our <code class="highlighter-rouge">ItemRepository</code> algebra has fixed the definition of <code class="highlighter-rouge">findAll</code> as <code class="highlighter-rouge">F[List[Item]]</code> so we won’t be able to create an interpreter that returns a streaming result instead.</p>

<h3 id="rethinking-our-algebra">Rethinking our algebra</h3>

<p>We should think about abstracting over that <code class="highlighter-rouge">List</code> and two of the most common abstractions that immediately come to mind are <code class="highlighter-rouge">Foldable</code> and <code class="highlighter-rouge">Traverse</code>. But although these typeclasses are very useful, they are not enough to represent a stream of values, so we should come up with a better abstraction.</p>

<p>Well, it seems that our options are either adding another higher-kinded parameter <code class="highlighter-rouge">G[_]</code> to our algebra or just define an abstract member <code class="highlighter-rouge">G[_]</code>. So let’s go with the first one:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Great! This looks good so far.</p>

<h3 id="streaming-support-interpreter">Streaming support interpreter</h3>

<p>Now let’s write a new <code class="highlighter-rouge">PostgreSQL</code> interpreter with streaming support:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">doobie.implicits._</span>
<span class="k">import</span> <span class="nn">doobie.util.transactor.Transactor</span>
<span class="k">import</span> <span class="nn">fs2.Stream</span>

<span class="c1">// Doobie implementation (not fully implemented, what matters here are the types).
</span><span class="k">class</span> <span class="nc">StreamingItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">xa</span><span class="k">:</span> <span class="kt">Transactor</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span>
                                   <span class="o">(</span><span class="k">implicit</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Sync</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">sql</span><span class="s">"select name, price from items"</span>
                                           <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
                                           <span class="o">.</span><span class="n">stream</span>
                                           <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Saving item: $item"</span><span class="o">))</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">F</span><span class="o">.</span><span class="n">delay</span><span class="o">(</span><span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"Removing item: $item"</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Voilà! We got our streaming implementation of <code class="highlighter-rouge">findAll</code>.</p>

<h3 id="test-interpreter">Test interpreter</h3>

<p>That’s all we wanted, but what about testing it? Sure, we might prefer to have a simple implementation by just using a plain <code class="highlighter-rouge">List</code>, so what can we possibly do?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepository</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">mem</span> <span class="k">=</span> <span class="nc">MutableMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Item</span><span class="o">]</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">toList</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">find</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">Item</span><span class="o">]]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">save</span><span class="o">(</span><span class="n">item</span><span class="k">:</span> <span class="kt">Item</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">mem</span><span class="o">.</span><span class="n">update</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">,</span> <span class="n">item</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">ItemName</span><span class="o">)</span><span class="k">:</span> <span class="kt">Id</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mem</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s pretty much it! We managed to abstract over the return type of <code class="highlighter-rouge">findAll</code> by just adding an extra parameter to our algebra.</p>

<h3 id="about-composition">About composition</h3>

<p>At this point the avid reader might have thought, what if I want to write a generic function that takes all the items (using <code class="highlighter-rouge">findAll</code>), applies some discounts and writes them back to the DB (using <code class="highlighter-rouge">save</code>)?</p>

<p>Short answer is, you might want to define a different algebra where <code class="highlighter-rouge">findAll</code> and <code class="highlighter-rouge">save</code> have the same types (eg: both of them are streams) but in case you find yourself wanting to make this work with the current types then let’s try and find out!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span><span class="o">],</span> <span class="n">join</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">])</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">process</span><span class="o">(</span><span class="n">discount</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">items</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="n">repo</span><span class="o">.</span><span class="n">findAll</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">item</span> <span class="k">=&gt;</span> <span class="n">item</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">price</span> <span class="k">=</span> <span class="n">item</span><span class="o">.</span><span class="n">price</span> <span class="o">*</span> <span class="o">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">discount</span><span class="o">)))</span>
    <span class="k">val</span> <span class="n">saved</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=</span> <span class="n">items</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">repo</span><span class="o">.</span><span class="n">save</span><span class="o">)</span>
    <span class="n">join</span><span class="o">(</span><span class="n">saved</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We defined a <code class="highlighter-rouge">join</code> function responsible for evaluating the effects and flatten the result to <code class="highlighter-rouge">F[Unit]</code>. As you can see below, this works for both a streaming interpreter and a list interpreter (shout out to <a href="https://github.com/fthomas">fthomas</a> for proposing this solution):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">StreamingDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span><span class="o">.</span><span class="n">evalMap</span><span class="o">(</span><span class="n">identity</span><span class="o">).</span><span class="n">compile</span><span class="o">.</span><span class="n">drain</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">Stream</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">?</span><span class="o">]](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>

<span class="k">object</span> <span class="nc">ListDiscountInterpreter</span> <span class="o">{</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">IO</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">list</span> <span class="k">=&gt;</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">List</span><span class="o">].</span><span class="n">sequence</span><span class="o">(</span><span class="n">list</span><span class="o">).</span><span class="n">void</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">repo</span><span class="k">:</span> <span class="kt">ItemRepository</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">])</span><span class="k">:</span> <span class="kt">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">DiscountProcessor</span><span class="o">[</span><span class="kt">IO</span>, <span class="kt">List</span><span class="o">](</span><span class="n">repo</span><span class="o">,</span> <span class="n">join</span><span class="o">)</span>

<span class="o">}</span>
</code></pre></div></div>

<p>While in this case it was possible to make it generic I don’t recommend to do this at home because:</p>

<ol>
  <li>it involves some extra boilerplate and the code becomes harder to understand / maintain.</li>
  <li>as soon as the logic gets more complicated you might run out of options to make it work in a generic way.</li>
  <li>you lose the ability to use the <code class="highlighter-rouge">fs2 DSL</code> which is super convenient.</li>
</ol>

<p>What I recommend instead, is to write this kind of logic in the streaming interpreter itself. You could also write a generic program that implements the parts that can be abstracted (eg. applying a discount to an item <code class="highlighter-rouge">f: Item =&gt; Item</code>) and leave the other parts to the interpreter.</p>

<h3 id="design-alternative">Design alternative</h3>

<p>Another possible and very interesting alternative suggested by <a href="https://github.com/mpilquist">Michael Pilquist</a>, would be to define our repository as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">S</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">S</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Item</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Where the second type parameter matches the shape of <code class="highlighter-rouge">fs2.Stream</code>. In this case our streaming repository will remain the same (it should just extend <code class="highlighter-rouge">ItemRepository[F, Stream]</code> instead of <code class="highlighter-rouge">ItemRepository[F, Stream[F, ?]]</code>) but our in memory interpreter will now rely on <code class="highlighter-rouge">fs2.Stream</code> instead of a parametric <code class="highlighter-rouge">G[_]</code>, for example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">MemRepositoryAlt</span> <span class="k">extends</span> <span class="nc">ItemRepository</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Stream</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">findAll</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Id</span>, <span class="kt">Item</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">sql</span><span class="s">"select name, price from items"</span>
      <span class="o">.</span><span class="n">query</span><span class="o">[</span><span class="kt">Item</span><span class="o">]</span>
      <span class="o">.</span><span class="n">stream</span>
      <span class="o">.</span><span class="n">transact</span><span class="o">(</span><span class="n">xa</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>I think it’s an alternative worth exploring further that might require a blog post on its own, so I’ll leave it here for reference :)</p>

<h3 id="source-of-inspiration">Source of inspiration</h3>

<p>I’ve come up with most of the ideas presented here during my work on <a href="https://gvolpe.github.io/fs2-rabbit/">Fs2 Rabbit</a>, a stream based client for <code class="highlighter-rouge">Rabbit MQ</code>, where I make heavy use of this technique as I originally described in <a href="https://partialflow.wordpress.com/2018/02/01/a-tale-of-tagless-final-cats-effect-and-streaming-fs2-rabbit-v0-1/">this blog post</a>.</p>

<p>Another great source of inspiration was <a href="https://www.youtube.com/watch?v=1h11efA4k8E">this talk</a> given by <a href="https://github.com/LukaJCB">Luka Jacobowitz</a> at Scale by the Bay.</p>

<h3 id="abstracting-over-the-effect-type">Abstracting over the effect type</h3>

<p>One thing you might have noticed in the examples above is that both <code class="highlighter-rouge">ItemRepository</code> interpreters are not fixed to <code class="highlighter-rouge">IO</code> or <code class="highlighter-rouge">Task</code> or any other effect type but rather requiring a parametric <code class="highlighter-rouge">F[_]</code> and an implicit instance of <code class="highlighter-rouge">Sync[F]</code>. This is a quite powerful technique for both library authors and application developers. Well know libraries such as <a href="https://http4s.org/">Http4s</a>, <a href="https://monix.io/">Monix</a> and <a href="https://functional-streams-for-scala.github.io/fs2/">Fs2</a> make a heavy use of it.</p>

<p>And by requiring a <code class="highlighter-rouge">Sync[F]</code> instance we are just saying that our implementation will need to suspend synchronous side effects.</p>

<p>Once at the edge of our program, commonly the main method, we can give <code class="highlighter-rouge">F[_]</code> a concrete type. At the moment, there are two options: <code class="highlighter-rouge">cats.effect.IO</code> and <code class="highlighter-rouge">monix.eval.Task</code>. But hopefully soon we’ll have a <code class="highlighter-rouge">Scalaz 8 IO</code> implementation as well (fingers crossed).</p>

<h3 id="principle-of-least-power">Principle of least power</h3>

<p>Abstracting over the effect type doesn’t only mean that we should require <code class="highlighter-rouge">Sync[F]</code>, <code class="highlighter-rouge">Async[F]</code> or <code class="highlighter-rouge">Effect[F]</code>. It also means that we should only require the minimal typeclass instance that satisfies our predicate. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Functor</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mf">1.</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

<span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</code></pre></div></div>

<p>Here our <code class="highlighter-rouge">bar</code> method just returns a pure value in the <code class="highlighter-rouge">F</code> context, thus we need an <code class="highlighter-rouge">Applicative[F]</code> instance that defines <code class="highlighter-rouge">pure</code>. On the other hand, our <code class="highlighter-rouge">foo</code> method just converts the inner <code class="highlighter-rouge">Int</code> into <code class="highlighter-rouge">String</code>, what we call a pure data transformation. So all we need here is a <code class="highlighter-rouge">Functor[F]</code> instance. Another example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.Monad</span>

<span class="k">def</span> <span class="n">fp</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">]</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="o">`</span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</code></pre></div></div>

<p>The above implementation makes use of a <code class="highlighter-rouge">for-comprehension</code> which is a syntactic sugar for <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">map</code>, so all we need is a <code class="highlighter-rouge">Monad[F]</code> instance because we also need an <code class="highlighter-rouge">Applicative[F]</code> instance for <code class="highlighter-rouge">bar</code>, otherwise we could just use a <code class="highlighter-rouge">FlatMap[F]</code> instance.</p>

<h3 id="final-thoughts">Final thoughts</h3>

<p>I think we got quite far with all these abstractions, giving us the chance to write clean and elegant code in a pure functional programming style, and there’s even more! Other topics worth mentioning that might require a blog post on their own are:</p>

<ul>
  <li>Dependency Injection
    <ul>
      <li>Tagless Final + implicits (MTL style) enables DI in an elegant way.</li>
    </ul>
  </li>
  <li>Algebras Composition
    <ul>
      <li>It is very common to have multiple algebras with a different <code class="highlighter-rouge">F[_]</code> implementation. In some cases, <code class="highlighter-rouge">FunctionK</code> (a.k.a. natural transformation) can be the solution.</li>
    </ul>
  </li>
</ul>

<p>What do you think about it? Have you come across a similar design problem? I’d love to hear your thoughts!</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/gvolpe.jpg" />
      
      <p>by Gabriel Volpe
    
    on May 09, 2018</p>

    
  <a href="https://twitter.com/volpegabriel87" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @volpegabriel87</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/gvolpe" aria-label="Follow @gvolpe on GitHub">Follow @gvolpe</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
