<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Optimizing Tagless Final – Part 2 – Monadic programs</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Optimizing Tagless Final – Part 2 – Monadic programs</h2>

  <p>In our previous post on optimizing tagless final programs we learned how we could use the <a href="https://github.com/LukaJCB/sphynx">sphynx library</a> to derive some optimization schemes for your tagless final code. In case you missed it and want to read up on it, you can find it <a href="https://typelevel.org/blog/2017/12/27/optimizing-final-tagless.html">right here</a> or you can watch my presentation on the topic <a href="https://www.youtube.com/watch?v=E9iRYNuTIYA">here</a>, but you should be able to follow this blog post without going through it all in detail.</p>

<h2 id="optimizing-monadic-programs">Optimizing monadic programs</h2>

<p>One of the questions I’ve been getting a lot, is if we can also do something like that for the monadic parts of our program.
The answer is yes, we can, however it will have to be quite a bit different.</p>

<p>I don’t think the differences are quite obvious, so we’ll go through them step by step.
With applicative programs, we’re optimizing a bunch of independent instructions.
That means, we can look at all of them and extract information out of them statically (i.e. without running the interpreter).
They can be seen as a sequence of instructions that we can fold down to a single monoid <code class="highlighter-rouge">M</code>, that holds the information that we need to optimize.
We then used that monoid to recreate a new interpreter that can take this extra information into account.</p>

<p>With monadic programs, we do not have such luxury.
We can only step through each of our instructions one at a time, because every instruction depends on the results of the prior one.
This means that we cannot extract any information beyond the very first instruction we have.
That might seem like a deal breaker, but there’s still a few things we can do.
We could, for example, build up our monoid <code class="highlighter-rouge">M</code> dynamically, after each monadic instruction.
Then, before invoking the next computation in the monadic sequence, we could take that monoid and recreate that next computation with that extra information.</p>

<p>Now, that might sound super abstract to you, and I wouldn’t disagree, so let’s look at a quick example.
Say, we’re using the <code class="highlighter-rouge">KVStore</code> algebra again from last time:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We could optimize programs with this algebra by caching the results of <code class="highlighter-rouge">get</code> and we could use that same cache to also cache key-value pairs we inserted using <code class="highlighter-rouge">put</code>.</p>

<p>So given this example program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="s">"cat"</span><span class="o">)</span>
  <span class="n">dog</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="n">cat</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">dog</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"dog"</span><span class="o">))</span>
  <span class="n">cat2</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"cat"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="nc">List</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">cat2</span><span class="o">).</span><span class="n">flatten</span>
</code></pre></div></div>

<p>The naively interpreted program would be doing the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="highlighter-rouge">key</code> passed by the user</li>
  <li>get the value “cat” back out of the store</li>
  <li>access the key-value store and maybe return a value associated with the key “cat”</li>
  <li>access the store again with the same “cat” key.</li>
</ol>

<p>Now if accessing the key-value store means going through a network layer this is of course highly inefficient.
Ideally our fully optimized program should do the following things:</p>
<ol>
  <li>put the value “cat” into the store with the <code class="highlighter-rouge">key</code> parameter passed by the user and cache it.</li>
  <li>access the cache to get the value “cat” associated with <code class="highlighter-rouge">key</code></li>
  <li>access the key-value-store and maybe return a value associated with the key “cat”</li>
  <li>access the cache to return the previous result for the “cat” key.</li>
</ol>

<p>Cool, next, let’s look at how we might get there.
First the type of our cache, which for our case can just be a <code class="highlighter-rouge">Map[String, String]</code>, but generically could just be any monoid.</p>

<p>Now what we want to do is transform any interpreter for <code class="highlighter-rouge">KVStore</code> programs into interpreters that</p>
<ol>
  <li>Look in the cache before performing a <code class="highlighter-rouge">get</code> action with the actual interpreter</li>
  <li>Write to the cache after performing either a <code class="highlighter-rouge">get</code> or <code class="highlighter-rouge">put</code> action.</li>
</ol>

<p>So how can we get there? It seems like we want to thread a bunch of state through our program, that we want to both read and write to.
If you’re familiar with FP folklore you might recognize that that description fits almost exactly to the <code class="highlighter-rouge">State</code> monad.
Furthermore, because we know that our <code class="highlighter-rouge">F[_]</code> is a monad, that means the <code class="highlighter-rouge">StateT</code> monad transformer over <code class="highlighter-rouge">F</code> will also be a monad.</p>

<p>Okay with that said, let’s try to develop function that turns any interpreter <code class="highlighter-rouge">KVStore[F]</code> into an interpreter into <code class="highlighter-rouge">StateT[F, M, A]</code>, so an <code class="highlighter-rouge">KVStore[StateT[F, M, ?]]</code>, where <code class="highlighter-rouge">M</code> is the monoid we use to accumulate our extracted information.
We’ll start with the <code class="highlighter-rouge">put</code> operation.
For <code class="highlighter-rouge">put</code>, we’ll want to call the interpreter to perform the action and then modify the state by adding the retrieved value into our cache.
To make the code a bit more legible we’ll also define a few type aliases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Cache</span> <span class="o">=</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span>
<span class="k">type</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">A</span><span class="o">]</span>

<span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">](</span><span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">*&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So far, so good, now let’s have a look at what to do with the <code class="highlighter-rouge">get</code> function.
It’s a bit more complex, because we want to read from the cache, as well as write to it if the cache didn’t include our key.
What we have to do is, get our current state, then check if the key is included, if so, just return it, otherwise call the interpreter to perform the <code class="highlighter-rouge">get</code> action and then write that into the cache.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">cache</span> <span class="k">&lt;-</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">get</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span><span class="o">]</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
              <span class="k">case</span> <span class="n">s</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
              <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">liftF</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
                             <span class="o">.</span><span class="n">flatTap</span><span class="o">(</span><span class="n">updateCache</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
            <span class="o">}</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>

<span class="k">def</span> <span class="n">updateCache</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">ov</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">CachedAction</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">ov</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">StateT</span><span class="o">.</span><span class="n">modify</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">updated</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="o">().</span><span class="n">pure</span><span class="o">[</span><span class="kt">CachedAction</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is quite something, so let’s try to walk through it step by step.
First we get the cache using <code class="highlighter-rouge">StateT.get</code>, so far so good.
Now, we check if the key is in the cache using <code class="highlighter-rouge">cache.get(key)</code>.
The result of that is an <code class="highlighter-rouge">Option[String]</code>, which we can pattern match to see if it did include the key.
If it did, then we can just return that <code class="highlighter-rouge">Option[String]</code> by lifting it into <code class="highlighter-rouge">CachedAction</code> using <code class="highlighter-rouge">pure</code>.
If it wasn’t in the cache, things are a bit more tricky.
First, we lift the interpreter action into <code class="highlighter-rouge">CachedAction</code> using <code class="highlighter-rouge">StateT.liftF</code>, that gives us a <code class="highlighter-rouge">CachedAction[Option[String]]</code>, which is already the return type we need and we could return it right there, but we still need to update the cache.
Because we already have the return type we need, we can use the <code class="highlighter-rouge">flatTap</code> combinator.
Then inside the <code class="highlighter-rouge">updateCache</code> function, we take the result of our interpreter, which is again an <code class="highlighter-rouge">Option[String]</code>, and update the cache if the value is present.
If it’s empty, we don’t want to do anything at all, so we just lift unit into <code class="highlighter-rouge">CachedAction</code>.</p>

<p>In case you’re wondering <code class="highlighter-rouge">flatTap</code> works just like <code class="highlighter-rouge">flatMap</code>, but will then <code class="highlighter-rouge">map</code> the result type back to the original one, making it a bit similar to a monadic version of the left shark (<code class="highlighter-rouge">&lt;*</code>) operator, making it very useful for these “fire-and-forget” operations.
It’s defined like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">flatTap</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fa</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">))</span>
</code></pre></div></div>

<p>And with that we now have a working function to turn any interpreter into an optimized interpreter.
We can also generalize this fairly easily into a function that will do all of the wiring for us.
To do so, we’ll generalize away from <code class="highlighter-rouge">KVStore</code> and <code class="highlighter-rouge">Cache</code> and instead use generic <code class="highlighter-rouge">Alg[_[_]]</code> and <code class="highlighter-rouge">M</code> parameters:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="n">program</span><span class="o">(</span><span class="n">withState</span><span class="o">(</span><span class="n">interpreter</span><span class="o">)).</span><span class="n">runEmptyA</span>
</code></pre></div></div>

<p>Just like last time, we have to use a <code class="highlighter-rouge">MonadProgram</code> wrapper around <code class="highlighter-rouge">Alg[F] =&gt; F[A]</code>, because Scala lacks rank-N types which would allow us to define values that work over ALL type constructors <code class="highlighter-rouge">F[_]: Monad</code> (Fortunately however, this will very probably soon be fixed in dotty, PR <a href="https://github.com/lampepfl/dotty/pull/4672">here</a>).</p>

<p>Now let’s see if we can actually use it, by checking it with a test interpreter that will print whenever we retrieve or insert values into the <code class="highlighter-rouge">KVStore</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimize</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">IO</span>, <span class="kt">Cache</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="n">program</span><span class="o">(</span><span class="s">"mouse"</span><span class="o">))(</span><span class="n">transform</span><span class="o">)</span>
  <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>

<span class="c1">// Put key: mouse, value: cat
// Get key: cat
</span></code></pre></div></div>

<p>It works and does exactly what we want! 
Nice! We could end this blog post right here, but there’s still a couple of things I’d like to slightly alter.</p>

<h3 id="refining-the-api">Refining the API</h3>

<p>As you were able to tell the implementation of our transformation from the standard interpreter to the optimized interpreter is already quite complex and that is for a very very simple algebra that doesn’t do a lot.
Even then, I initially wrote an implementation that packs everything in a single <code class="highlighter-rouge">StateT</code> constructor to avoid the overhead of multiple calls to <code class="highlighter-rouge">flatMap</code>, but considered the version I showed here more easily understandable.
For more involved algebras and more complex programs, all of this will become a lot more difficult to manage.
In our last blog post we were able to clearly separate the extraction of our information from the rebuilding of our interpreter with that information.
Let’s have a look at if we can do the same thing here.</p>

<p>First we’ll want to define an extraction method.
For applicative programs we used <code class="highlighter-rouge">Const[M, ?]</code>, however that cannot work here, as <code class="highlighter-rouge">Const</code> doesn’t have a <code class="highlighter-rouge">Monad</code> instance and also, because for extraction with monadic programs, we need to actually take the result of the computation into account. 
That means, that for every operation in our algebra, we want a way to turn it into our monoid <code class="highlighter-rouge">M</code>.
With that said, it seems we want a function <code class="highlighter-rouge">A =&gt; M</code>, where <code class="highlighter-rouge">A</code> is the result type of the operations in our algebra.
So what we can do here is define an algebra for <code class="highlighter-rouge">? =&gt; M</code>, in types an <code class="highlighter-rouge">Alg[? =&gt; M]</code>.</p>

<p>Let’s try to do define such an interpreter for our <code class="highlighter-rouge">KVStore</code> along with <code class="highlighter-rouge">Cache</code>/<code class="highlighter-rouge">Map[String, String</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">extract</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">Cache</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=&gt;</span> <span class="nc">Cache</span> <span class="k">=</span>
    <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Just as before we want to extract the cache piece by piece with every monadic step.
Whenever we get an <code class="highlighter-rouge">Option[String]</code> after using <code class="highlighter-rouge">get</code>, we can then turn that into a <code class="highlighter-rouge">Cache</code> if it’s non-empty.
The same goes for <code class="highlighter-rouge">put</code>, where we’ll create a Map using the key-value pair.
We now have a way to turn the results of our algebra operations into our information <code class="highlighter-rouge">M</code>, so far so good!</p>

<p>Next, we’ll need a way to rebuild our operations using that extracted information.
For that, let’s consider what that actually means.
For applicative programs this meant a function that given a state <code class="highlighter-rouge">M</code> and an interpreter <code class="highlighter-rouge">Alg[F]</code>, gave a  reconstructed interpreter inside the <code class="highlighter-rouge">F</code> context <code class="highlighter-rouge">F[Alg[F]]</code>.
So a function <code class="highlighter-rouge">(M, Alg[F]) =&gt; F[Alg[F]]</code>.</p>

<p>For monadic programs, there’s no need to precompute any values, as we’re dealing with fully sequential computations that can potentially update the state after every evaluation.
So we’re left with a function <code class="highlighter-rouge">(M, Alg[F]) =&gt; Alg[F]</code>.
Let’s try building that for <code class="highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">m</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Easy enough!
For <code class="highlighter-rouge">get</code> we look inside our cache and use the value if it’s there, otherwise we call the original interpreter to do its job.
For <code class="highlighter-rouge">put</code>, there’s nothing to gain from having access to our extracted information and the only thing we can do is call the interpreter and let it do what needs to be done.</p>

<p>Now we have a way to extract information and then also use that information, next up is finding a way to wire these two things together to get back to the behaviour we got using <code class="highlighter-rouge">StateT</code>.</p>

<p>And as a matter of fact, we’ll wire them back together using exactly <code class="highlighter-rouge">StateT</code>, as it’s monad instance does do exactly what we want.</p>

<p>Using our two functions <code class="highlighter-rouge">extract</code> and <code class="highlighter-rouge">rebuild</code> it’s fairly easy to get back to <code class="highlighter-rouge">KVStore[StateT[F, Cache, ?]]</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="n">extract</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">cache</span> <span class="k">=&gt;</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">cache</span><span class="o">,</span> <span class="n">interp</span><span class="o">).</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> 
      <span class="o">(</span><span class="n">cache</span> <span class="o">|+|</span><span class="err"> </span><span class="n">extract</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This is fairly straightforward, we use rebuild with our cache and the interpreter to get a new interpreter that will run the operation.
Then, we use the result, which is just an <code class="highlighter-rouge">F[Unit]</code>/<code class="highlighter-rouge">F[Option[String]]</code> respectively, and map it 
  using the extractor to get the newest <code class="highlighter-rouge">Cache</code> and using its <code class="highlighter-rouge">Monoid</code> instance to update the state and then we tuple it with the result, giving us an <code class="highlighter-rouge">F[(Cache, Unit)]</code> or <code class="highlighter-rouge">F[(Cache, Option[String])]</code>, which is exactly what the <code class="highlighter-rouge">StateT</code> constructor needs.</p>

<p>This is great, but can we generalize this to any algebra and any monoid?</p>

<p>The answer is yes, but it’s not exactly easy.
First let’s look at the actual problem.
We have two interpreters <code class="highlighter-rouge">extract</code> and <code class="highlighter-rouge">rebuild</code>, but we have no way to combine them, because <code class="highlighter-rouge">Alg</code>, is completely unconstrained and that means we can’t call any functions on a generic <code class="highlighter-rouge">Alg[F]</code> at all.
So, okay, we need to constrain our <code class="highlighter-rouge">Alg</code> parameter to be able to combine values of <code class="highlighter-rouge">Alg[F]</code> with values of <code class="highlighter-rouge">Alg[G]</code> in some way, but what kind of type class could that be?
Are there even type classes that operate on the kind of <code class="highlighter-rouge">Alg</code>?</p>

<h3 id="higher-kinded-things">Higher kinded things</h3>

<p>There are, they’re just hidden away in a small library called <code class="highlighter-rouge">Mainecoon</code>.
That library gives us higher kinded versions of things like functors and contravariant functors, called <code class="highlighter-rouge">FunctorK</code> and <code class="highlighter-rouge">ContravariantK</code> respectively.</p>

<p>Let’s have a quick look at <code class="highlighter-rouge">FunctorK</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span>
<span class="k">trait</span> <span class="nc">FunctorK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">mapK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span> <span class="kt">~&gt;</span> <span class="kt">G</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Instead of mapping over type constructors <code class="highlighter-rouge">F[_]</code>, we map over algebras <code class="highlighter-rouge">A[_[_]]</code> and insteading of using functions <code class="highlighter-rouge">A =&gt; B</code>, we use natural transformations <code class="highlighter-rouge">F ~&gt; G</code>.
This is nice, but doesn’t really get us that far.</p>

<p>What we really need is the equivalent of the <code class="highlighter-rouge">Applicative</code>/<code class="highlighter-rouge">Apply</code> <code class="highlighter-rouge">map2</code> operation.
<code class="highlighter-rouge">map2</code> looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>And a higher kinded version would look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
</code></pre></div></div>

<p>If you haven’t guessed yet <code class="highlighter-rouge">Tuple2K</code> is just a higher kinded version of <code class="highlighter-rouge">Tuple2</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">G</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>Unfortunately <code class="highlighter-rouge">Mainecoon</code> doesn’t have an <code class="highlighter-rouge">ApplyK</code> type class that gives us this <code class="highlighter-rouge">map2K</code> operation, but it gives the next best thing! 
A higher-kinded <code class="highlighter-rouge">Semigroupal</code>, which when combined with the higher kinded <code class="highlighter-rouge">Functor</code> gives us that higher kinded <code class="highlighter-rouge">Apply</code> type class.
It’s called <code class="highlighter-rouge">CartesianK</code> (because cats <code class="highlighter-rouge">Semigroupal</code> used to be called <code class="highlighter-rouge">Cartesian</code>, but is renamed to <code class="highlighter-rouge">SemigroupalK</code> in the next version) and looks like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@typeclass</span> 
<span class="k">trait</span> <span class="nc">CartesianK</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">productK</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now just like you can define <code class="highlighter-rouge">map2</code> using <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">product</code> we can do the same for <code class="highlighter-rouge">map2K</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map2K</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">af</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span> <span class="n">ag</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">G</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">G</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="n">H</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">productK</span><span class="o">(</span><span class="n">af</span><span class="o">,</span> <span class="n">ag</span><span class="o">).</span><span class="n">mapK</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="putting-it-all-together">Putting it all together</h3>

<p>Okay, after that quick detour, let’s have a look at how can make use of these type classes.</p>

<p>If we look at what we have and how we’d like to use the <code class="highlighter-rouge">map2K</code> function, we can infer the rest that we need quite easily.</p>

<p>We have an <code class="highlighter-rouge">Alg[F]</code> and a <code class="highlighter-rouge">Alg[? =&gt; M]</code>, and we want an <code class="highlighter-rouge">Alg[StateT[F, M, ?]]</code>, so given those two as the inputs to <code class="highlighter-rouge">map2K</code>, all that seems to be missing is the natural transformation <code class="highlighter-rouge">Tuple2K[F, ? =&gt; M, ?] ~&gt; StateT[F, M, ?]</code>.
Nice! As so often, the types guide us and show us the way.</p>

<p>Well let’s try to define just that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">M</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This looks good, but actually has a problem, to get an <code class="highlighter-rouge">Alg[F]</code> from <code class="highlighter-rouge">rebuild</code> we give it an <code class="highlighter-rouge">M</code> and an interpreter <code class="highlighter-rouge">Alg[F]</code>. 
The interpreter isn’t really a problem, but the <code class="highlighter-rouge">M</code> can prove problematic as we need to give it to the <code class="highlighter-rouge">rebuild</code> function after each monadic step to always receive the latest state.
If we look at our natural transformation above, that function will never receive the newest state.
So what can we do about this?
Well, we could be a bit more honest about our types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">FunctionM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">M</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">FunctionM</span><span class="o">]</span>
</code></pre></div></div>

<p>Hey, now we’re getting there. This works, but if we look into some of the data types provided by <code class="highlighter-rouge">Cats</code> we can acutally see that this is just <code class="highlighter-rouge">Kleisli</code> or <code class="highlighter-rouge">ReaderT</code>, so our <code class="highlighter-rouge">rebuild</code> should actually look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>And now, we can easily implement a correct version of that natural transformation from earlier:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Cool, then let us also adjust the rebuild function we created for <code class="highlighter-rouge">KVStore</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">o</span> <span class="k">@</span> <span class="nc">Some</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">pure</span><span class="o">(</span><span class="n">o</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
  <span class="o">})</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Cache</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Kleisli</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s stayed pretty much the same, we just needed to wrap the whole thing in a <code class="highlighter-rouge">Kleisli</code> and we’re good!</p>

<p>Now we can go ahead and define the full function signature:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="kt">:</span> <span class="kt">FunctorK:</span> <span class="kt">CartesianK</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">M:</span> <span class="kt">Monoid</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">MonadProgram</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span><span class="o">])</span>
  <span class="o">(</span><span class="n">rebuild</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
  
    <span class="k">val</span> <span class="n">tupleToState</span> <span class="k">=</span> <span class="k">new</span> <span class="o">(</span><span class="nc">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">?</span><span class="o">]</span> <span class="o">~&gt;</span> <span class="nc">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">])</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Tuple2K</span><span class="o">[</span><span class="kt">Kleisli</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span>, <span class="kt">?</span> <span class="k">=&gt;</span> <span class="kt">M</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
        <span class="nc">StateT</span><span class="o">(</span><span class="n">m</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">m</span><span class="o">))(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">fa</span><span class="o">.</span><span class="n">second</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">|+|</span> <span class="n">m</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">))</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">withState</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
      <span class="n">map2K</span><span class="o">(</span><span class="n">extract</span><span class="o">(</span><span class="n">interpreter</span><span class="o">),</span> <span class="n">rebuild</span><span class="o">))(</span><span class="n">tupleToState</span><span class="o">)</span>

    <span class="n">program</span><span class="o">(</span><span class="n">withState</span><span class="o">).</span><span class="n">runEmptyA</span>
  
  <span class="o">}</span>
</code></pre></div></div>

<p>That is all, we’ve got a fully polymorphic function that can optimize monadic programs.</p>

<p>Let’s use it!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">optimize</span><span class="o">(</span><span class="n">program</span><span class="o">)(</span><span class="n">extract</span><span class="o">)(</span><span class="n">rebuild</span><span class="o">)</span>
  <span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">printInterpreter</span><span class="o">)</span>
  <span class="o">.</span><span class="n">unsafeRunSync</span><span class="o">()</span>
</code></pre></div></div>

<p>Now, when we run this, it should be exactly the same result as when we ran it earlier using the direct <code class="highlighter-rouge">StateT</code> interpreter, but the resulting code is much cleaner.
However, it does have the drawback that you’ll now need additional constraints for every algebra to use this function.
That said though, one of the cool features of <code class="highlighter-rouge">Mainecoon</code> is that it comes with auto-derivation.
Meaning we can just add an annotation to any of our algebras and it will automatically derive the <code class="highlighter-rouge">FunctorK</code> and <code class="highlighter-rouge">CartesianK</code> instances.</p>

<p>In fact, that is exactly how I defined those two instances for the <code class="highlighter-rouge">KVStore</code> algebra:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@autoFunctorK</span>
<span class="nd">@autoCartesianK</span>
<span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</code></pre></div></div>

<p>This makes it fairly easy to use these extra type classes and helpts mitigate the drawbacks I mentioned.</p>

<h3 id="conclusions">Conclusions</h3>

<p>Today we’ve seen a way to make optimizing monadic tagless final programs easier and intuitive, all the code is taken from the sphynx library and can be found <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still be subject to change, because designing a good API is hard.</p>

<p>What do you think about this optimization scheme? Maybe you just prefer using <code class="highlighter-rouge">StateT</code> and being done with it, or maybe you like to use a typeclass based approach like the one we used last time?</p>

<p>Would love to hear from you all in the comments!</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/lukajacobowitz.jpg" />
      
      <p>by Luka Jacobowitz
    
    on Jun 27, 2018</p>

    
  <a href="https://twitter.com/LukaJacobowitz" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @LukaJacobowitz</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/LukaJCB" aria-label="Follow @LukaJCB on GitHub">Follow @LukaJCB</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
