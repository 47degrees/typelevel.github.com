<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | To change types, change values</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>To change types, change values</h2>

  <p><em>This is the seventh of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>;
more specifically, this post is meant as a followup to
<a href="/blog/2015/07/30/values-never-change-types.html">the previous entry</a>.
However, in a first for this series, it stands on its own, as
introductory matter.</em></p>

<p>A program is a system for converting data from one format to another,
which we have endowed with the color of magic.  In typed programming,
we use a constellation of types to mediate this transformation; a
function’s result can only be passed as another function’s argument to
the extent to which those parts of the functions’ types unify.</p>

<p>We rely on the richness of our types in these descriptions.  So it is
natural to want the types to change as you move to different parts of
the process; each change reflects the reality of what has just
happened.  For example, when you parse a string into an AST, your
program’s state has changed types, from <code class="highlighter-rouge">String</code> to <code class="highlighter-rouge">MyAST</code>.</p>

<p>But, as we have just seen, due to decisions we have made to simplify
our lives,
<a href="/blog/2015/07/30/values-never-change-types.html">values cannot change types</a>,
no matter how important it is to the sanity of our code.  At the same
time, we don’t want to give up the richness of using more than one
type to describe our data.</p>

<p>Fortunately, there is a solution that satisfies these competing
concerns: to change types, change values.  You can’t do anything about
the values you have, but you can create new ones of the right type,
and use those instead.</p>

<h2 id="type-changing-is-program-organization">Type-changing is program organization</h2>

<p>In values with complex construction semantics, it is common to write
imperative programs that leave “holes” in the data structures using
the terrible <code class="highlighter-rouge">null</code> misfeature of Java, Scala, and many other
languages.  This looks something like this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Document</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// this structure has three parts:
</span>  <span class="k">var</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span> <span class="c1">// ← a body of text,
</span>  <span class="k">var</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ an index of words to every
</span>    <span class="c1">// occurrence in the text,
</span>  <span class="k">var</span> <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="kc">null</span>
    <span class="c1">// ↑ the most frequently used words
</span>    <span class="c1">// in the text, and their number of
</span>    <span class="c1">// occurrences
</span><span class="o">...</span>
</code></pre></div></div>

<p>Now, we must fill in these variables, by computing and assigning to
each in turn.  First, we compute the corpus text.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initText</span><span class="o">()</span>
</code></pre></div></div>

<p>Then, we compute and fill in the word index.  If we didn’t fill in
<code class="highlighter-rouge">text</code> first, this compiles, but crashes at runtime.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initWordIndex</span><span class="o">()</span>
</code></pre></div></div>

<p>Finally, we figure out which words are most popular.  If we didn’t
fill in <code class="highlighter-rouge">wordIndex</code> first, this compiles, but crashes.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">initMostPopular</span><span class="o">()</span>
</code></pre></div></div>

<p>How do I know that?  Well, I have to inspect the definitions of these
three methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">initText</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">text</span> <span class="k">=</span> <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">.</span><span class="n">toFile</span><span class="o">).</span><span class="n">mkString</span>

  <span class="k">def</span> <span class="n">initWordIndex</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="n">r</span> <span class="n">findAllMatchIn</span> <span class="n">text</span>
    <span class="n">wordIndex</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
      <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">matched</span>
        <span class="k">val</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">start</span>
        <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="n">m</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">initMostPopular</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="n">mostPopular</span> <span class="k">=</span> <span class="n">wordIndex</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">toList</span>
      <span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
</code></pre></div></div>

<p>This method of organizing object initialization is popular because,
among other properties:</p>

<ol>
  <li>it <em>seems</em> self-documenting,</li>
  <li>you don’t have to pass data around, and</li>
  <li>steps can be customized by subclassing and overriding.</li>
</ol>

<p>However!  It has the tremendous drawback of preventing the compiler
from helping you get the order of initialization correct.  Go, look;
see if you can spot why I said the latter two calls would crash if you
don’t get the order exactly right.  Now, I have four questions for
you.</p>

<ol>
  <li>Would you trust yourself to notice these implicit dependencies
every time you look at this code?</li>
  <li>Suppose you commented on the dependencies.  Would you trust these
comments to be updated when the initialization details change?</li>
  <li>Would you trust subclasses that customize the initialization to
respect the order in which we call these three <code class="highlighter-rouge">init</code> functions?</li>
  <li>Could you keep track of this if the initialization was
significantly more complex?  (This <em>is</em> a toy example for a blog
post, after all.)</li>
</ol>

<p>Ironically, as your initialization becomes more complex, the compiler
becomes less able to help you with uninitialized-variable warnings and
the like.  But, this is not the natural order of things; it is a
consequence of using imperative variable initialization but not
representing this
<a href="https://github.com/facebook/flow/releases/tag/v0.14.0">variable refinement</a>
in the type system.  By initializing in a different way, we can
recover type safety.</p>

<div class="side-note">
  The implications of refinement, linked above, are much less severe
  than those of unrestricted type-changing of a variable.  So Flow did
  not solve, nor did it aim to solve, those difficulties by
  introducing the refinement feature.
</div>

<h2 id="the-four-types-of-document">The four types of <code class="highlighter-rouge">Document</code></h2>

<p>If we consider <code class="highlighter-rouge">Document</code> as the simple product of its three state
variables, with some special functions associated with them as
whatever <code class="highlighter-rouge">Document</code> methods we intend to support, we have a simple
3-tuple.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
 <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Let us no longer pretend that it is any more complicated than that.</p>

<p>But this cannot be mutated to fill these in as they are initialized,
you say!  Yes, that’s right, we want a <em>type-changing</em> transformation.
By <em>changing values</em>, this is easy.  There are three phases of
initialization, so four states, including uninitialized.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Path</span>
<span class="nc">String</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span>
<span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span> <span class="nc">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>For interesting phases, such as the final one, we might create a <code class="highlighter-rouge">case
class</code> to hold its contents, instead.  Let us call that class, for
this example, <code class="highlighter-rouge">Doc</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)])</span>
</code></pre></div></div>

<p>Finally, we can build 3 functions to take us through these steps.
Each begins by taking one as an argument, and produces the next state
as a return type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">initText</span><span class="o">(</span><span class="n">filename</span><span class="k">:</span> <span class="kt">Path</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="nc">Source</span><span class="o">.</span><span class="n">fromFile</span><span class="o">(</span><span class="n">filename</span><span class="o">.</span><span class="n">toFile</span><span class="o">).</span><span class="n">mkString</span>

  <span class="k">def</span> <span class="n">initWordIndex</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="s">"""\w+"""</span><span class="o">.</span><span class="n">r</span> <span class="n">findAllMatchIn</span> <span class="n">text</span>
    <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">words</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]()){</span>
       <span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">mtch</span><span class="o">)</span> <span class="k">=&gt;</span>
       <span class="k">val</span> <span class="n">word</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">matched</span>
       <span class="k">val</span> <span class="n">idx</span> <span class="k">=</span> <span class="n">mtch</span><span class="o">.</span><span class="n">start</span>
       <span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="n">word</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">::</span> <span class="n">m</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)))</span>
     <span class="o">})</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">initMostPopular</span><span class="o">(</span><span class="n">twi</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]))</span><span class="k">:</span> <span class="kt">Doc</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">)</span> <span class="k">=</span> <span class="n">twi</span>
    <span class="nc">Doc</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">wordIndex</span><span class="o">,</span>
        <span class="n">wordIndex</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">).</span><span class="n">toList</span>
          <span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="n">p</span> <span class="k">=&gt;</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">p</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>If we have a <code class="highlighter-rouge">Path</code>, we can get a <code class="highlighter-rouge">Doc</code> by <code class="highlighter-rouge">(initText _) andThen
initWordIndex andThen initMostPopular: Path =&gt; Doc</code>.  But that hardly
replicates the rich runtime behavior of our imperative version, does
it?  That is, we can do reordering of operations in a larger context
with <code class="highlighter-rouge">Document</code>, but not <code class="highlighter-rouge">Doc</code>.  Let us see what that means.</p>

<h2 id="many-docs">Many docs</h2>

<p>Dealing with one document in isolation is one thing, but suppose we
have a structure of <code class="highlighter-rouge">Document</code>s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocumentTree</span>
</code></pre></div></div>

<p>In the imperative mode, we can batch and reorder initialization.  Say,
for example, we don’t initialize <code class="highlighter-rouge">Document</code> when we create it.  This
tree then contains <code class="highlighter-rouge">Document</code>s that contain only <code class="highlighter-rouge">Path</code>s.  We can walk
the tree, doing step 1 for every <code class="highlighter-rouge">Document</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocumentTree
</span>  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Document</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDocument</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">dts</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
    <span class="o">}</span>

<span class="c1">// now we can initialize the text everywhere,
// given some dtree: DocumentTree
</span><span class="n">dtree</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">initText</span><span class="o">())</span>
</code></pre></div></div>

<p>The way software does, it got more complex.  And we can be ever less
sure that we’re doing things right, under this arrangement.</p>

<h2 id="the-four-phases-problem-stuck-in-a-tree">The four phases problem, stuck in a tree</h2>

<p>Our tree only supports one type of document.  We could choose the
final one, <code class="highlighter-rouge">Doc</code>, but there is no way to replicate more exotic
document tree initializations like the one above.</p>

<p>Instead, we want the type of the tree to adapt along with the document
changes.  If we have four states, <em>Foo</em>, <em>Bar</em>, <em>Baz</em>, and <em>Quux</em>, we
want four different kinds of <code class="highlighter-rouge">DocumentTree</code> to go along with them.  In
a language with type parameters, this is easy: we can model those four
as <code class="highlighter-rouge">DocTree[Foo]</code>, <code class="highlighter-rouge">DocTree[Bar]</code>, <code class="highlighter-rouge">DocTree[Baz]</code>, and
<code class="highlighter-rouge">DocTree[Quux]</code>, respectively, by adding a type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">SingleDoc</span><span class="o">[</span><span class="kt">D</span><span class="o">](</span><span class="n">id</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>Now we need a replacement for the <code class="highlighter-rouge">foreach</code> that we used with the
unparameterized <code class="highlighter-rouge">DocumentTree</code> to perform each initialization step on
every <code class="highlighter-rouge">Document</code> therein.  Now that <code class="highlighter-rouge">DocTree</code> is agnostic with respect
to the specific document type, this is a little more abstract, but
quite idiomatic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// add this to DocTree
</span>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">D2</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D2</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">SingleDoc</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">))</span>
      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
    <span class="o">}</span>
</code></pre></div></div>

<p>It’s worth comparing these side by side.  Now we should be able to
step through initialization of <code class="highlighter-rouge">DocTree</code> with <code class="highlighter-rouge">map</code>, just as with
<code class="highlighter-rouge">DocumentTree</code> and <code class="highlighter-rouge">foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dtp</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="s">"rt"</span><span class="o">,</span> <span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">Paths</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"hello.md"</span><span class="o">))))</span>
<span class="n">dtp</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">java.nio.file.Path</span><span class="o">]</span> <span class="k">=</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="n">hello</span><span class="o">.</span><span class="n">md</span><span class="o">)))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">dtp</span> <span class="n">map</span> <span class="nc">Doc</span><span class="o">.</span><span class="n">initText</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">tmtp7.DocTree</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">DocCategory</span><span class="o">(</span><span class="n">rt</span><span class="o">,</span><span class="nc">List</span><span class="o">(</span><span class="nc">SingleDoc</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="n">contents</span> <span class="n">of</span> <span class="n">the</span> <span class="n">hello</span><span class="o">.</span><span class="n">md</span> <span class="n">file</span><span class="o">!)))</span>
</code></pre></div></div>

<h2 id="you-wouldnt-avoid-writing-functions-would-you">You wouldn’t avoid writing functions, would you?</h2>

<p>There is nothing magical about <code class="highlighter-rouge">DocTree</code> that makes it especially
amenable to the introduction of a type parameter.  This is <em>not</em> a
feature whose proper use is limited to highly abstract or
general-purpose data structures; with its <code class="highlighter-rouge">String</code>s and <code class="highlighter-rouge">Int</code>s strewn
about, it is <em>utterly</em> domain-specific, “business” code.</p>

<p>In fact, if we were likely to annotate <code class="highlighter-rouge">Doc</code>s with more data, <code class="highlighter-rouge">Doc</code>
would be a perfect place to add a type parameter!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// suppose we add some "extra" data
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Doc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">wordIndex</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]],</span>
   <span class="n">mostPopular</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)],</span>
   <span class="n">extra</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span>
</code></pre></div></div>

<p>You can use a type parameter to represent one simple slot in an
otherwise concretely specified structure, as above.  You can
<a href="https://bitbucket.org/ermine-language/ermine-writers/src/9ec9a98c30bc9924cc49888895f8832e8ce4f8e1/writers/html/src/main/scala/com/clarifi/reporting/writers/HTMLDeps.scala?at=default#HTMLDeps.scala-37">use one to represent 10 slots</a>.</p>

<p>Parameterized types are the type system’s version of functions.  They
aren’t just for collections, abstract code, or highly general-purpose
libraries: they’re for <em>your</em> code!</p>

<p>Unless you are going to suggest that <em>functions</em> are “too academic”.
Or that functions have no place in “business logic”.  Or perhaps that,
while it would be nice to define functions to solve this, that, and
sundry, you’ll just do the quick no-defining-functions hack for now
and maybe come back to add some functions later when “paying off
technical debt”.  <em>Then</em>, I’m not sure what to say.</p>

<h2 id="the-virtuous-circle-of-fp-and-types">The virtuous circle of FP and types</h2>

<p>Now we are doing something very close to functional programming.
Moreover, we were led here not by a desire for referential
transparency, nor for purity, but merely for a way to represent the
states of our program in a more well-typed way.</p>

<p>In this series of posts, I have deliberately avoided discussion of
functional programming until this section; my chosen subject is types,
not functional programming.  But the features we have been considering
unavoidably coalesce here into an empirical argument for functional
programming.  Type parameters let us elegantly lift transformations
from one part of our program to another; the intractable complexities
of imperative type-changing direct us to program more functionally, by
computing new values instead of changing old ones, if we want access
to these features.  This, in turn, encourages ever more of our program
to be written in a functional style, just as the switch to different
<code class="highlighter-rouge">Doc</code> representations induced a switch to different document tree
representations, <code class="highlighter-rouge">map</code> instead of <code class="highlighter-rouge">foreach</code>.</p>

<h2 id="paying-it-back">Paying it Back</h2>

<p>Likewise, the use of functional programming style feeds back, in the
aforementioned virtuous circle, to encourage the use of stronger
types.</p>

<p>When we wanted stronger guarantees about the initialization of our
documents, and thereby also of the larger structures incorporating
them, we turned to the most powerful tool we have at our disposal for
describing and ensuring such guarantees: the type system.  In so
doing, we induced an explosion of explicit data representations; where
we had two, we now have eight, whose connections to each other are
mediated by the types of functions involved.</p>

<p>With the increase in the number of explicit concepts in the code comes
a greater need for an automatic method of keeping track of all these
connections.  The type system is ideally suited to this role.</p>

<div class="side-note">
  We induced more <em>explicit</em> data representation, not more
  representations overall.  The imperative <code>Document</code> has
  four stages of initialization, at each of which it exhibits
  different behavior.  All we have done is expose this fact to the
  type system level, at which our usage can be checked.
</div>

<h2 id="dont-miss-one">Don’t miss one!</h2>

<p>As it is declared, the type-changing <code class="highlighter-rouge">DocTree#map</code> has another
wonderful advantage over <code class="highlighter-rouge">DocumentTree#foreach</code>.</p>

<p>Let us say that each category should also have a document of its own,
not just a list of subtrees.  In refactoring, we adjust the
definitions of <code class="highlighter-rouge">DocumentCategory</code> or <code class="highlighter-rouge">DocCategory</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// imperative version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocumentCategory</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">Document</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">DocumentTree</span><span class="o">])</span>
   <span class="k">extends</span> <span class="nc">DocumentTree</span>

<span class="c1">// functional version
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">DocCategory</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
  <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">doc</span><span class="k">:</span> <span class="kt">D</span><span class="o">,</span>
   <span class="n">members</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>So far, so good.  Next, neither <code class="highlighter-rouge">foreach</code> nor <code class="highlighter-rouge">map</code> compile anymore.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TmTp7.scala:70: wrong number of arguments for pattern
⤹ tmtp7.DocumentCategory(name: String,doc: tmtp7.Document,
⤹                        members: List[tmtp7.DocumentTree])
      case DocumentCategory(_, dts) =&gt;
                           ^
TmTp7.scala:71: not found: value d
        f(d)
          ^
TmTp7.scala:91: wrong number of arguments for pattern
⤹ tmtp7.DocCategory[D](name: String,doc: D,members: List[tmtp7.DocTree[D]])
      case DocCategory(c, dts) =&gt;
                      ^
TmTp7.scala:92: not enough arguments for method
⤹ apply: (name: String, doc: D, members: List[tmtp7.DocTree[D]]
⤹        )tmtp7.DocCategory[D] in object DocCategory.
Unspecified value parameter members.
        DocCategory(c, dts map (_ map f))
                   ^
</code></pre></div></div>

<p>So let us fix <code class="highlighter-rouge">foreach</code> in the simplest way possible.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//                 added ↓
</span>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
</code></pre></div></div>

<p>This compiles.  It is wrong, and we can figure out exactly why by
trying the same shortcut with <code class="highlighter-rouge">map</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="k">case</span> <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>We are treating the <code class="highlighter-rouge">d: D</code> like the <code class="highlighter-rouge">name: String</code>, just passing it
through.  It is “ignored” in precisely the same way as the <code class="highlighter-rouge">foreach</code>
ignores the new data.  But this version does not compile!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">TmTp7</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">90</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">d.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">D</span><span class="o">)</span>
 <span class="kt">required:</span> <span class="kt">D2</span>
        <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
                       <span class="o">^</span>
</code></pre></div></div>

<p>More broadly, <code class="highlighter-rouge">map</code> must return a <code class="highlighter-rouge">DocTree[D2]</code>.  By implication, the
second argument must be a <code class="highlighter-rouge">D2</code>, not a <code class="highlighter-rouge">D</code>.  We can fix it by using
<code class="highlighter-rouge">f</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      <span class="nc">DocCategory</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">),</span> <span class="n">dts</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="n">map</span> <span class="n">f</span><span class="o">))</span>
</code></pre></div></div>

<p>Likewise, we should make a similar fix to <code class="highlighter-rouge">DocumentTree#foreach</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="nc">DocumentCategory</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">d</span><span class="o">,</span> <span class="n">dts</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">f</span><span class="o">(</span><span class="n">d</span><span class="o">)</span>
      <span class="n">dts</span> <span class="n">foreach</span> <span class="o">(</span><span class="k">_</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">)</span>
</code></pre></div></div>

<p>But only in the case of <code class="highlighter-rouge">map</code> did we get help from the compiler.
That’s because <code class="highlighter-rouge">DocumentTree</code> is not the only thing to gain a type
parameter in this new design.  When we made <code class="highlighter-rouge">DocTree</code> take one, it was
only natural to define <code class="highlighter-rouge">map</code> with one, too.</p>

<p>We can see how this works out by looking at both <code class="highlighter-rouge">foreach</code> and <code class="highlighter-rouge">map</code>
as the agents of our practical goal: transformation of the tree by
transforming the documents therein.  <code class="highlighter-rouge">foreach</code> works like this.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              document transformer
               (Document =&gt; Unit)
 DocumentTree ~~~~~~~~~~~~~~~~~~~&gt; DocumentTree
 ------------                      -----------------
initial state                      final state
  (old tree)                       (same type, “new”
                                    but same tree)
</code></pre></div></div>

<p>The way <code class="highlighter-rouge">map</code> looks at <code class="highlighter-rouge">DocTree</code> is very similar, and we give it the
responsibilities that <code class="highlighter-rouge">foreach</code> had, so it is unsurprising that the
“shape” we imagine for transformation is similar.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                    (D =&gt; D2)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D2]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (changed type,
                                      changed value!)
</code></pre></div></div>

<p>The replacement of <code class="highlighter-rouge">D</code> with <code class="highlighter-rouge">D2</code> also means that values of type <code class="highlighter-rouge">D</code>
cannot occur anywhere in the result, as <code class="highlighter-rouge">D</code> is abstract, so only
appears as <code class="highlighter-rouge">doc</code> by virtue of being the type parameter passed to
<code class="highlighter-rouge">DocTree</code> and its data constructors (er, “subclasses”).</p>

<p>As our result type is <code class="highlighter-rouge">DocTree[D2]</code>, we have two options, considering
only the result type:</p>

<ol>
  <li>return a <code class="highlighter-rouge">DocTree</code> with no <code class="highlighter-rouge">D2</code>s in its representation, one role of
<code class="highlighter-rouge">None</code> and <code class="highlighter-rouge">Nil</code> in <code class="highlighter-rouge">Option</code> and <code class="highlighter-rouge">List</code> respectively, or</li>
  <li>make <code class="highlighter-rouge">D2</code>s from the <code class="highlighter-rouge">D</code>s in the <code class="highlighter-rouge">DocTree[D]</code> we have in hand, by
passing them to the ‘document transformer’ <code class="highlighter-rouge">D =&gt; D2</code>.</li>
</ol>

<p>Similarly, no <code class="highlighter-rouge">DocTree[D]</code> values can appear anywhere in the result.
As with the <code class="highlighter-rouge">D</code>s, they must all be transformed or dropped, with a
different ‘empty’ <code class="highlighter-rouge">DocTree</code> chosen.</p>

<h2 id="the-dangers-of-simplifying">The dangers of “simplifying”</h2>

<p>Suppose we instead defined <code class="highlighter-rouge">map</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span>
</code></pre></div></div>

<p>If you subscribe to the idea of type parameters being for wonky
academics, this is “simpler”.  And it’s fine, I suppose, if you only
have one <code class="highlighter-rouge">D</code> in mind, one document type in mind.  Setting aside that
we have four, there is another problem.  Let’s take a look at the
“shape” of this transformation.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               document transformer
                     (D =&gt; D)
    DocTree[D] ~~~~~~~~~~~~~~~~~~~~&gt; DocTree[D]
 -------------                       ----------------
 initial state                       final state
  (old tree)                         (but no promise,
                                      same type!)
</code></pre></div></div>

<p>The problem with a <code class="highlighter-rouge">D =&gt; D</code> transformer is that we can’t make promises
that all our data passed through it.  After all, a source <code class="highlighter-rouge">d</code> has the
same type as <code class="highlighter-rouge">f(d)</code>.  We could even get away with</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">D</span> <span class="o">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">DocTree</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">map[D2]</code> is strictly more general.  <strong>Even if we have only one <code class="highlighter-rouge">D</code> in
mind for <code class="highlighter-rouge">DocTree</code>, it still pays to type-parameterize it and to add
‘type-changing’ extra type parameters like <code class="highlighter-rouge">D2</code>.</strong></p>

<h2 id="the-dangers-of-missing-values">The dangers of missing values</h2>

<p>Have you ever started getting a new bill, then missed a payment
because you thought you were covered for the month?</p>

<p>Have you ever gone on vacation and, in your relief at having not left
anything important at home, left something behind when packing for
your return trip?</p>

<p>This kind of thing cannot be characterized in the manner of “well, I
would just get a runtime error if I didn’t have a type checker, so
it’s fine.”  Yet it simply falls out of the system we have chosen;
moreover, we have barely begun to consider the possibilities.</p>

<p>In this series, I have focused on existential types, which we can in
one sense consider merely abstract types that the compiler checks that
we treat as independent, like <code class="highlighter-rouge">D</code> and <code class="highlighter-rouge">D2</code>.  Existential types are
only one natural outcome of the system of type abstraction brought to
us by type parameters; there are many more interesting conclusions,
like the ones described above.</p>

<p>Next, in
<a href="/blog/2016/01/28/existential-inside.html">“It’s existential on the inside”</a>,
we will see how deeply intertwined universal and existential types
really are.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Sep 21, 2015</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
