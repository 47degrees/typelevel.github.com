<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Values never change types</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Values never change types</h2>

  <p><em>This is the sixth of a series of articles on “Type Parameters and
Type Members”.  If you haven’t yet, you should
<a href="/blog/2015/07/13/type-members-parameters.html">start at the beginning</a>,
which introduces code we refer to throughout this article without
further ado.</em></p>

<p>In a subtyping language such as Java or Scala, first-class
existentials are a helpful ally for modeling values and methods that
abstract over subtypes in different ways.  In a language with
mutation, such as Java or Scala, existentials help deal with certain
kinds of state changes without violating type safety.</p>

<p>But values, <em>themselves</em>, never change types.  When you first practice
with existentials, the Java and Scala compilers seem to become
veritable minefields of type errors—do something slightly different in
your code, and everything falls apart.  But this is just about
<a href="http://blog.higher-order.com/blog/2014/12/21/maximally-powerful/">nothing being a free lunch</a>:
<strong>the wide variety of values meeting any given existential type,
combined with the possibility for mutation, means a sound typechecker
must be very conservative about what it permits when using those
values</strong>.</p>

<p>So, in this article, we’ll explore some of these type error pitfalls,
see why it’s perfectly reasonable for the compilers to complain about
these pieces of code, and fix the errors using the equivalence rules
we’ve learned about in previous articles.  This is a big topic, so in
the next article, we’ll talk about taking advantage of the freedoms
that the compilers are concerned about in this one.</p>

<h2 id="aliasing-prevents-replacement">Aliasing prevents replacement</h2>

<p>Let’s say you have a list of strings, <code class="highlighter-rouge">strs: List[String]</code>.  But you
want that value to change: you want it to be a <code class="highlighter-rouge">List[Int]</code> instead.
Maybe every value in the list parses to an integer and you want to
“map in place”; maybe you want to use <code class="highlighter-rouge">-1</code> for every string that can’t
be parsed.</p>

<p>Generic systems like those of Java, Scala, and the ML family don’t let
you do this for a few reasons.</p>

<p>First, with regard to structures like <code class="highlighter-rouge">List</code>, let’s suppose we are
adding this feature to the type system, and that the list has type
<code class="highlighter-rouge">List[String]</code> before replacement, and <code class="highlighter-rouge">List[Int]</code> after.  What type
does it have when we’re halfway done?  The type system requires us to
<em>guarantee</em> that there are no strings, only ints, left once we’re
done; how do we track our progress?  Remember that vague promises of
“I tested the code” are meaningless to the type system; you have to
<em>prove</em> it mathematically.  This is a solvable problem, but the known
solutions far complicate the type system beyond the design goals of
these languages: the cost is far too high for the benefit.</p>

<p>Second, let us suppose that we’ve solved the first problem.  Or, let
us suppose that we introduce a structure for which this isn’t a
problem.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OneThing</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</code></pre></div></div>

<p>There, no chance of “halfway done” there!  But something else happens.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">strs</span><span class="o">.</span><span class="n">value</span> <span class="k">=</span> <span class="mi">42</span>
<span class="c1">// won't compile, just a thought experiment
</span></code></pre></div></div>

<p>Now, presumably, completely aside from the value, the variable <code class="highlighter-rouge">strs</code>
has <em>changed types</em> to <code class="highlighter-rouge">OneThing[Int]</code>.  Not just the value in it, the
variable itself.  OK, so what if that variable came from someplace
else?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">replaceWithInt</span><span class="o">(</span><span class="n">ote</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
  <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="k">=</span> <span class="mi">42</span>

<span class="k">val</span> <span class="n">strs</span><span class="k">:</span> <span class="kt">OneThing</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">OneThing</span><span class="o">(</span><span class="s">"hi"</span><span class="o">)</span>
<span class="n">replaceWithInt</span><span class="o">(</span><span class="n">strs</span><span class="o">)</span>
<span class="c1">// also won't compile, thought experiment
</span></code></pre></div></div>

<p>Now, the type of <code class="highlighter-rouge">replaceWithInt</code> must contain a note that “by the
way, the type of <code class="highlighter-rouge">ote</code>, and any variables that refer to it, and any
variables that refer to <em>those</em> variables, and so on until it stops,
will change as a result of this call”.</p>

<p>This is a problem of <em>aliases</em>, all the locations that may refer to a
value.  If you change the type of the value, you also have to update
every reference to it, at compile time!  This is <em>the type system</em>;
your promise that you have no other references is not good enough.
You have to <em>prove</em> it.</p>

<p>As with the previous problem, the known solutions to this problem
would complicate the type systems of Java and Scala beyond their
design goals.  In a sense, <strong>this aspect of their type systems can be
considered to encourage functional programming</strong>.  A type-changing map
that builds a new list of the new type, or what have you, instead of
mutating the old one, is <em>trivial</em> in the Java/Scala generics systems.
There are no chances of aliasing problems, because no one could
possibly have an unknown reference to the value you just constructed.
This is a even more obvious design choice in the ML family languages,
which make no secret of favoring functional programming.</p>

<h2 id="assignment-rewrites-existentials">Assignment rewrites existentials</h2>

<p><a href="/blog/2015/07/16/method-equiv.html">We saw earlier</a> that a simple get from a
<code class="highlighter-rouge">List&lt;?&gt;</code>, followed by adding that value right back to the same list,
didn’t work, but if we took that <code class="highlighter-rouge">xs</code> and passed it to a
type-parameterized version, everything worked fine.  Why is that?</p>

<p>If you have a <em>mutable</em> variable of an existential type, the
existentialized part of the type may have different [type] values at
different parts of the program.  Let’s use
<a href="/blog/2015/07/23/type-projection.html#a-good-reason-to-use-type-members">the <code class="highlighter-rouge">StSource</code> from the projection post</a>.
Note that the <code class="highlighter-rouge">S</code> member is existential, because we did not bind it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="n">mxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is Int
</span><span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">mxs</span><span class="o">.</span><span class="n">init</span>
<span class="c1">// now I'm going to change mxs
</span><span class="n">mxs</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="s">"ab"</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span><span class="o">))</span>
<span class="c1">// at this point in the program, the S is String
</span><span class="n">mxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>

<span class="nc">TmTp6</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">14</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">tmtp6.Tmtp4Funs.s1.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span><span class="k">#</span><span class="kt">S</span><span class="o">)</span>
 <span class="n">required</span><span class="k">:</span> <span class="k">_</span><span class="err">2</span><span class="kt">.S</span> <span class="kt">where</span> <span class="kt">val</span> <span class="k">_</span><span class="err">2</span><span class="kt">:</span> <span class="kt">tmtp4.StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="n">mxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
         <span class="o">^</span>
</code></pre></div></div>

<p>And it’s good that this happens, because the value we got from <code class="highlighter-rouge">init</code>
is definitely incompatible with the argument type to <code class="highlighter-rouge">emit</code>.</p>

<p>If we don’t want to track when this happens—and we certainly can’t
decide, in all cases, when a mutable variable such as this has been
overwritten so as to change its existentials, given the freedoms
afforded by Java—how can we treat a mutable variable with existentials
as safe?  The type system makes a simplifying assumption: <em>every
reference to the variable gets fresh values to fill in the
existentials</em>.</p>

<p>If it helps, you can think of a mutable variable as an <em>immutable</em>
variable that wraps its type with an extra layer.  In fact, that’s
<a href="https://github.com/scala/scala/blob/v2.11.7/src/library/scala/runtime/ObjectRef.java#L14-L17">what scalac does when you capture a <code class="highlighter-rouge">var</code></a>.
So <code class="highlighter-rouge">mxs</code> is, in a sense, of type <code class="highlighter-rouge">Ref[StSource[String]]</code>, where</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Ref</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">value</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</code></pre></div></div>

<p>So, by substitution, the variable <code class="highlighter-rouge">mxs</code> is really a pair of functions,
<code class="highlighter-rouge">() =&gt; StSource[String]</code> and <code class="highlighter-rouge">StSource[String] =&gt; Unit</code>.  The “getter”
returns <code class="highlighter-rouge">StSource[String]</code>; each time you invoke that getter, you
might get an <code class="highlighter-rouge">StSource[String]</code> with a different <code class="highlighter-rouge">S</code> member, because
the <code class="highlighter-rouge">forSome</code> effectively occurs inside the body, as described in
<a href="/blog/2015/07/27/nested-existentials.html#what-if-we-list-different-existentials">the substitutions of “Nested existentials”</a>.</p>

<p>Of course, this means you can take advantage of this in your own
designs, to get <em>some</em> of the behavior of a type-changing value
mutation.  The use of variable references to delineate existentials
means that, even when we replace <code class="highlighter-rouge">mxs</code> above, the behavior of the
variable in the context of an instance hasn’t really changed, so
nothing about the containing value’s type has changed.  We thus
preserve our property, that values never change types.</p>

<p>When you make a single reference, it has to be consistent; subsequent
mutations have no effect on the value we got from that reference.  So
we can pass that reference somewhere that asserts that this doesn’t
happen in its own context, such as a type-parameterized
≡<em><sub><small>m</small></sub></em> method.  If you have a mutable variable
of type <code class="highlighter-rouge">List&lt;T&gt;</code>, even if you don’t know what <code class="highlighter-rouge">T</code> is, you know that
any updates to that variable will keep the same <code class="highlighter-rouge">T</code>.</p>

<h2 id="making-variables-read-only-matters">Making variables read-only matters</h2>

<p>If I change the variable to <code class="highlighter-rouge">final</code> in Java, and remove mutation, I
shouldn’t have this problem anymore.  Surprisingly, I do; this is what
happened in
<a href="/blog/2015/07/16/method-equiv.html">the original <code class="highlighter-rouge">copyToZero</code> example</a>,
where the argument was declared <code class="highlighter-rouge">final</code>.  I assume that this is just a
simplifying assumption in <code class="highlighter-rouge">javac</code>, that the extra guarantee of
unchanging existentials offered by <code class="highlighter-rouge">final</code> isn’t understood by the
compiler.</p>

<p>In the case of Scala, though, <strong>when you are using existential type
members, Scala can understand the implications of an immutable
variable, declared with <code class="highlighter-rouge">val</code></strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="n">s1</span> <span class="k">=</span> <span class="n">imxs</span><span class="o">.</span><span class="n">init</span>
<span class="c1">// you can do whatever you want here; the compiler will stop you from
// changing imxs
</span><span class="n">imxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>It can’t pull off this trick for type parameters, having just as much
trouble as Java there.  So this is another reason for
<a href="/blog/2015/07/13/type-members-parameters.html">our original rule of thumb</a>.</p>

<h2 id="naming-the-existential">Naming the existential</h2>

<p>The benefit we get from
<a href="/blog/2015/07/16/method-equiv.html">passing <code class="highlighter-rouge">copyToZeroP</code>’s argument to <code class="highlighter-rouge">copyToZeroT</code></a>
is that we <em>name</em> the existential for the single reference to the
argument that we make.  We name it <code class="highlighter-rouge">T</code> there, for the scope of its
invocation.</p>

<p>Likewise, in Scala, each <code class="highlighter-rouge">val</code> introduces, while it is in scope, each
existential member it has, as a type name.  There are
<a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#paths">a lot of rules in Scala</a>
for exactly when this happens, but you may want to simply experiment.
We got a hint of what that name is
<a href="/blog/2015/07/23/type-projection.html#type-parameters-see-existentially">when we used <code class="highlighter-rouge">StSource</code> existentially in the REPL</a>.
Here’s the previous example again, with a type annotation for <code class="highlighter-rouge">s1</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">imxs</span><span class="k">:</span> <span class="kt">StSource</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">StSource</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">toString</span><span class="o">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">))</span>
<span class="k">val</span> <span class="n">s1</span><span class="k">:</span> <span class="kt">imxs.S</span> <span class="o">=</span> <span class="n">imxs</span><span class="o">.</span><span class="n">init</span>
<span class="n">imxs</span><span class="o">.</span><span class="n">emit</span><span class="o">(</span><span class="n">s1</span><span class="o">)</span>
</code></pre></div></div>

<p>We have gained convenience, not power, with this <em>path-dependent
types</em> feature; we can always pass into a type-parameterized local
method, with only the inconvenience of having to write out the whole
polymorphic method and call dance.  Moreover, this is nowhere near
<a href="/blog/2015/07/23/type-projection.html#a-failed-attempt-at-simplified-emitting">a solution to the type projection problem</a>;
there are too many things that a type parameter can do that we can’t
with this feature.  But we’ll dive into that in a later post.</p>

<h2 id="by-name-existential-arguments-arent-equivalent">By-name existential arguments aren’t equivalent!</h2>

<p>There is another little corner case in method equivalence to consider.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">copyToZeroNP</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="k">def</span> <span class="n">copyToZeroNT</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span>
</code></pre></div></div>

<p>These method types are not equivalent!  That’s because <code class="highlighter-rouge">copyToZeroNP</code>
can be called with a by-name <em>that evaluates to a list with a
different element type each time</em>; <code class="highlighter-rouge">copyToZeroNT</code> doesn’t allow this.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">time</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">t</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"even"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
  <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">66</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
<span class="o">}</span>

<span class="n">copyToZeroNP</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// ok
</span><span class="n">copyToZeroNT</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>  <span class="c1">// not ok
</span></code></pre></div></div>

<p>In effect, <code class="highlighter-rouge">=&gt;</code> is like a type constructor; we can think of these
arguments as <code class="highlighter-rouge">byname[PList[_]]</code> and <code class="highlighter-rouge">byname[PList[T]]</code>.  So we have
exactly the same problem as we had with
<a href="/blog/2015/07/27/nested-existentials.html#method-equivalence-%E2%80%A6-broken"><code class="highlighter-rouge">plenLength</code> and <code class="highlighter-rouge">plenLengthTP</code></a>.</p>

<p>Unfortunately,
<a href="https://issues.scala-lang.org/browse/SI-9419">Scala currently accepts this, where it shouldn’t</a>.</p>

<p>The difference between these two methods gives us a hint about working
with existentials: if we can shift the scope for a given existential
outside the function that keeps giving us different types on every
reference, we might have an easier time working with it, even if we
can’t change it to a <code class="highlighter-rouge">val</code>; maybe it needs to be lazy and not saved,
for example.  So, despite the occasional convenience of path-dependent
types, <strong>type parameterized methods are still your best friends when
working with existential types</strong>.</p>

<p>In
<a href="/blog/2015/09/21/change-values.html">the next article, “To change types, change values”</a>,
we’ll look at some programs that make use of the two kinds of “type
changing” discussed above.  After that, we’ll finally talk about
methods that <em>return</em> values of existential type, rather than merely
taking them as arguments.</p>

<p><em>This article was tested with Scala 2.11.7.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Jul 30, 2015</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
