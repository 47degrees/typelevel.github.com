<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Primitive recursion with fix and Mu</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Primitive recursion with fix and Mu</h2>

  <p>Consider the simple cons-list datatype.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Equal</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">syntax</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">option</span><span class="o">.</span><span class="k">_</span><span class="o">,</span>
       <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">anyVal</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">function</span><span class="o">.</span><span class="k">_</span><span class="o">,</span>
       <span class="n">scala</span><span class="o">.</span><span class="n">reflect</span><span class="o">.</span><span class="n">runtime</span><span class="o">.</span><span class="n">universe</span><span class="o">.</span><span class="n">reify</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XNil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And a simple function over this structure.  Say, a simple summing
function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And that seems to work out alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">XNil</span><span class="o">()))))</span>
<span class="n">nums</span><span class="k">:</span> <span class="kt">XCons</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>Has it ever struck you as curious that, though its own value was
required to construct a value like <code class="highlighter-rouge">sum</code>, the system has no problem
with that?</p>

<p>Oh, well, that’s just a recursive function, you say.  Well, what’s so
special about recursive functions?  Why do they get special treatment
so that they can define themselves with themselves?</p>

<h2 id="induction-and-termination">Induction and termination</h2>

<p>First, let’s be clear: there’s a limit to how much of <code class="highlighter-rouge">sum</code> can be
used in its own definition.</p>

<p>Let us consider the moral equivalent of the statement “this function
gives the sum of a list of integers because it is the function that
gives the sum of a list of integers.”</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum2</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">sum2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
</code></pre></div></div>

<p>scalac will compile this definition; it is well-typed.  However, it
will be nonsensical at runtime, because it is nonsense; it will either
throw some exception or loop forever.</p>

<p>Let us consider a similar case: the infinite list of 42s.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="mi">42</span> <span class="o">#::</span> <span class="n">fortyTwos</span>
<span class="n">fortyTwos</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">fortyTwos</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<p>The definition of <code class="highlighter-rouge">fortyTwos</code> is like that of <code class="highlighter-rouge">sum</code>; it uses its own
value while constructing said value.  A similar definition to <code class="highlighter-rouge">sum2</code>
is, likewise, nonsense, though scalac can catch this particular case:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="kt">fortyTwos2</span> <span class="kt">does</span> <span class="kt">nothing</span> <span class="kt">other</span> <span class="kt">than</span> <span class="kt">call</span> <span class="kt">itself</span> <span class="kt">recursively</span>
       <span class="k">val</span> <span class="n">fortyTwos2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fortyTwos2</span>
                                     <span class="o">^</span>
</code></pre></div></div>

<p>Obviously, functions <em>aren’t</em> special; non-function values, like
functions, can be defined using their own values.  But how can we
characterize the difference between the good, terminating definitions,
and the bad, nonterminating definitions?</p>

<p>Proof systems like Coq and Agda perform a strong check on recursive
definitions; for definitions like <code class="highlighter-rouge">sum</code>, they require the recursion
match the structure of the data type, just as ours does, so that each
recursive call is known to operate over smaller data.  For definitions
like <code class="highlighter-rouge">fortyTwos</code>, they apply other strategies.  In Scala, we have to
make do with informality.</p>

<p>I like to think of it this way: <strong>a recursive definition must always
perform at least one inductive step</strong>.  <code class="highlighter-rouge">sum</code> does so because, in the
recursive case, it gives “supposing I have the sum of <code class="highlighter-rouge">tail</code>, the sum
is the <code class="highlighter-rouge">head</code> plus that.”  <code class="highlighter-rouge">fortyTwos</code> does because it says “the value
<code class="highlighter-rouge">fortyTwos</code> is <code class="highlighter-rouge">42</code> consed onto the value <code class="highlighter-rouge">fortyTwos</code>.”  It is, at
least, the start of a systematic way of thinking about terminating
recursive definitions.</p>

<h2 id="abstracting-the-recursion">Abstracting the recursion</h2>

<p>Now that we have a framework for thinking about what is required in a
recursive definition, we can start abstracting over it.</p>

<p>The above recursive definitions were accomplished with special
language support: the right-hand side of any term definition, <code class="highlighter-rouge">val</code> or
<code class="highlighter-rouge">def</code>, can refer to the thing being so defined.  Scalaz provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/std/function$.html">the <code class="highlighter-rouge">fix</code> function</a>,
which, if it were provided intrinsically, would eliminate the need for
this language support.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fix</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(=&gt;</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">a</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In this definition, the value returned by <code class="highlighter-rouge">f</code> <em>is</em> the value given to
it as an argument.  It’s a by-name argument because that’s how we
enforce the requirement: <code class="highlighter-rouge">f</code> must perform at least one inductive step
in the definition of its result, though it can refer to that result by
its argument, which we enforce by requiring it to return a value
<em>before</em> evaluating that argument.</p>

<p>Let’s redefine <code class="highlighter-rouge">sum</code> with <code class="highlighter-rouge">fix</code>, after importing it from
<code class="highlighter-rouge">scalaz.std.function</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">sum3</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">fix</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">Int</span><span class="o">](</span><span class="n">rec</span> <span class="k">=&gt;</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">rec</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">})</span>
</code></pre></div></div>

<p>And Scala thinks that’s alright.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sum3</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">51</span>
</code></pre></div></div>

<p>The interesting thing here is that <code class="highlighter-rouge">sum3</code>’s definition doesn’t refer
to the name <code class="highlighter-rouge">sum3</code>; the recursion is entirely inside the <code class="highlighter-rouge">fix</code>
argument.  So one advantage of <code class="highlighter-rouge">fix</code> is that it’s easy to write
recursive values as expressions without giving them a name.</p>

<p>For example, there’s the definition of <code class="highlighter-rouge">fortyTwos</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">fix</span><span class="o">[</span><span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="mi">42</span> <span class="o">#::</span> <span class="k">_</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Stream</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="o">?)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res2</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">toList</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">,</span> <span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="for-special-data-structures">For special data structures</h2>

<p>It can be inconvenient to avoid evaluating the argument when providing
an induction step.  Fortunately, the requirement that <code class="highlighter-rouge">f</code> be nonstrict
in its argument is too strong to characterize the space of values that
can be defined with <code class="highlighter-rouge">fix</code>-style recursion.</p>

<p>For a given data type, there’s often a way to abstract out the
nonstrictness.  For example, here’s an <code class="highlighter-rouge">Equal</code> instance combinator
that is fully evaluated, but doesn’t force the argument until after
the (equivalent) result has been produced.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lazyEqual</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">A</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">A</span> <span class="n">equal</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equalIsNatural</span> <span class="k">=</span> <span class="n">A</span><span class="o">.</span><span class="n">equalIsNatural</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Given that, we can produce a <code class="highlighter-rouge">fix</code> variant for <code class="highlighter-rouge">Equal</code> that passes the
<code class="highlighter-rouge">Equal</code> argument strictly.  You’re simply not allowed to invoke any of
the typeclass’s methods.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fixEq</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">fix</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">lazyEqual</span><span class="o">(</span><span class="n">A</span><span class="o">)))</span>
</code></pre></div></div>

<p>And now, we have the machinery to build a fully derived <code class="highlighter-rouge">Equal</code>
instance for <code class="highlighter-rouge">XList</code>, without function recursion, by defining the base
case and inductive step!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">`list equal`</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">]</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
    <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]]{</span>
      <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
    <span class="o">})</span>
</code></pre></div></div>

<p>That works out to interesting compiled output.  Note especially the
last line, and its (strict) use of <code class="highlighter-rouge">rec</code> towards the end.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">reify</span><span class="o">(</span><span class="n">fixEq</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">rec</span> <span class="k">=&gt;</span>
     <span class="o">|</span>     <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">])]]{</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
     <span class="o">|</span>       <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
     <span class="o">|</span>     <span class="o">}))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">reflect.runtime.universe.Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span> <span class="k">=</span> 
<span class="nc">Expr</span><span class="o">[</span><span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]](</span><span class="nc">$read</span><span class="o">.</span><span class="n">fixEq</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](((</span><span class="k">implicit</span> <span class="n">rec</span><span class="o">)</span> <span class="k">=&gt;</span>
 <span class="nc">Equal</span><span class="o">.</span><span class="n">equalBy</span><span class="o">[</span><span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">Tuple2</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">$read.XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]]</span>
 <span class="o">(((</span><span class="n">x0$1</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x0$1</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">$read</span><span class="o">.</span><span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">None</span>
  <span class="k">case</span> <span class="nc">$read</span><span class="o">.</span><span class="nc">XCons</span><span class="o">((</span><span class="n">x</span> <span class="k">@</span> <span class="k">_</span><span class="o">),</span> <span class="o">(</span><span class="n">xs</span> <span class="k">@</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="nc">Tuple2</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">))</span>
<span class="o">}))(</span><span class="n">option</span><span class="o">.</span><span class="n">optionEqual</span><span class="o">(</span><span class="n">tuple</span><span class="o">.</span><span class="n">tuple2Equal</span><span class="o">(</span><span class="n">anyVal</span><span class="o">.</span><span class="n">intInstance</span><span class="o">,</span> <span class="n">rec</span><span class="o">))))))</span>
</code></pre></div></div>

<p>f0, a binary serialization library,
<a href="https://github.com/joshcough/f0/blob/v1.1.1/src/main/scala/f0/Readers.scala#L216-L222">uses a similar technique</a>
to help define codecs on recursive data structures.</p>

<h2 id="what-about-xlist">What about <code class="highlighter-rouge">XList</code>?</h2>

<p>If we can abstract out the idea of recursive value definitions, what
about recursive type definitions?  Well, thanks to higher kinds, sure!
Scalaz doesn’t provide it, but it is commonly called <code class="highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]])</span>
</code></pre></div></div>

<p>We have to put a class in the middle of it so that we don’t have an
infinite type; Haskell has a similar restriction.  But the principle
is the same as with <code class="highlighter-rouge">fix</code>: feed one datatype induction step <code class="highlighter-rouge">F</code> to the
higher-order type <code class="highlighter-rouge">Mu</code> and it will feed <code class="highlighter-rouge">F</code>’s result back to itself.</p>

<p>For example, here is the equivalent definition of <code class="highlighter-rouge">XList</code> with <code class="highlighter-rouge">Mu</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">α</span><span class="o">)]}</span>
<span class="k">type</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
</code></pre></div></div>

<p>Note the typelambda’s similarity to the second type argument to
<code class="highlighter-rouge">#equalBy</code> above.  And for demonstration, the isomorphism with
<code class="highlighter-rouge">XList</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">onetotwo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">XNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">None</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Mu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="nc">Some</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">xs</span><span class="o">))))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">twotoone</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">value</span> <span class="n">cata</span> <span class="o">({</span><span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">XCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">twotoone</span><span class="o">(</span><span class="n">xs</span><span class="o">))},</span> <span class="nc">XNil</span><span class="o">())</span>
</code></pre></div></div>

<p>Of course, <code class="highlighter-rouge">fix</code> lends itself to both of these definitions; I have
left its use off here.  But let’s check those functions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">XList2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">3</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">4</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">42</span><span class="o">,</span><span class="nc">Mu</span><span class="o">(</span><span class="nc">None</span><span class="o">)))))))))))))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">twotoone</span><span class="o">(</span><span class="n">res11</span><span class="o">)</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">XList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">XCons</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span><span class="nc">XNil</span><span class="o">()))))</span>
</code></pre></div></div>

<h2 id="fix-over-mu"><code class="highlighter-rouge">fix</code> over <code class="highlighter-rouge">Mu</code></h2>

<p>And, finally, the associated general <code class="highlighter-rouge">Equal</code> definition for <code class="highlighter-rouge">Mu</code>.  The
<code class="highlighter-rouge">contramap</code> step is just noise to deal with the fact that the <code class="highlighter-rouge">Mu</code>
structure has to actually exist; you can ignore it for the most part.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">equalMu</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=&gt;</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]])</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">fixEq</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[</span><span class="kt">F</span><span class="o">]](</span><span class="n">emf</span> <span class="k">=&gt;</span> <span class="n">fa</span><span class="o">(</span><span class="n">emf</span><span class="o">)</span> <span class="n">contramap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">value</span><span class="o">))</span>
</code></pre></div></div>

<p>The evidence we really want is <code class="highlighter-rouge">forall a. Equal[a] =&gt; Equal[F[a]]</code>,
but that’s too hard to express in Scala, so this does it in a pinch.
All we’re interested in is that we can derive <code class="highlighter-rouge">F</code>’s equality given the
equality of any type argument given to it.  Let’s prove that we have
such an <code class="highlighter-rouge">Equal</code>-lifter:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// redefined because Tuple2Equal scalaz is strict on equalIsNatural
</span><span class="k">class</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">_1</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A1</span><span class="o">],</span> <span class="n">_2</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">A2</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">Equal</span><span class="o">[(</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">),</span> <span class="n">f2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A1</span><span class="o">,</span> <span class="kt">A2</span><span class="o">))</span> <span class="k">=</span>
    <span class="n">_1</span><span class="o">.</span><span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">_2</span><span class="o">.</span><span class="n">equal</span><span class="o">(</span><span class="n">f1</span><span class="o">.</span><span class="n">_2</span><span class="o">,</span> <span class="n">f2</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equalIsNatural</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">_1</span><span class="o">.</span><span class="n">equalIsNatural</span> <span class="o">&amp;&amp;</span> <span class="n">_2</span><span class="o">.</span><span class="n">equalIsNatural</span>
<span class="o">}</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">tup2eq</span><span class="o">[</span><span class="kt">A1:</span> <span class="kt">Equal</span>, <span class="kt">A2:</span> <span class="kt">Equal</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Tuple2Equal</span><span class="o">[</span><span class="kt">A1</span>, <span class="kt">A2</span><span class="o">](</span><span class="n">implicitly</span><span class="o">,</span> <span class="n">implicitly</span><span class="o">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Blah</span> <span class="c1">// just a placeholder
</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="o">{</span><span class="k">implicit</span> <span class="n">X</span><span class="k">:</span> <span class="kt">Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]]]}</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Blah</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Equal</span><span class="o">[</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Blah</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>And now that we have <code class="highlighter-rouge">F</code> equality, we’re done, because <code class="highlighter-rouge">Mu</code> is <code class="highlighter-rouge">F</code>s
all the way down.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">equalMu</span><span class="o">[</span><span class="kt">XList2Step</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="k">#</span><span class="kt">λ</span><span class="o">](</span><span class="k">implicit</span> <span class="n">fa</span> <span class="k">=&gt;</span> <span class="n">implicitly</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.Equal</span><span class="o">[</span><span class="kt">Mu</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">α</span><span class="o">)]]]</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Equal$$anon$2</span><span class="nd">@de52bcf</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="n">equal</span> <span class="o">(</span><span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">))</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span> <span class="n">equal</span> <span class="o">(</span><span class="n">onetotwo</span><span class="o">(</span><span class="n">nums</span><span class="o">),</span> <span class="n">onetotwo</span><span class="o">(</span><span class="nc">XCons</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="n">nums</span><span class="o">)))</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.4 &amp; Scalaz 7.0.6.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Apr 14, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
