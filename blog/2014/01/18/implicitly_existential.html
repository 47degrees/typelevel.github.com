<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | When implicitly isn't specific enough</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>When implicitly isn't specific enough</h2>

  <p>When working with implicit-encoded dependent function types, such as
<code class="highlighter-rouge">scalaz.Unapply</code> and numerous Shapeless operations, you’d frequently
like to acquire instances of those functions to see what types get
calculated for them.</p>

<p>For example, <code class="highlighter-rouge">++</code> on Shapeless <code class="highlighter-rouge">HList</code>s is driven by <code class="highlighter-rouge">Prepend</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="o">++[</span><span class="kt">S</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">suffix</span> <span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prepend</span> <span class="k">:</span> <span class="kt">Prepend</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">S</span><span class="o">])</span>
  <span class="k">:</span> <span class="kt">prepend.Out</span> <span class="o">=</span> <span class="n">prepend</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span>
</code></pre></div></div>

<p>So given some <code class="highlighter-rouge">HList</code>s, we can expect to be able to combine them in a
couple ways.  First, by using the syntax function above, and then by
acquiring a value of <code class="highlighter-rouge">prepend</code>’s type directly and invoking it, just
as in the body of the above function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">shapeless._</span><span class="o">,</span> <span class="n">ops</span><span class="o">.</span><span class="n">hlist</span><span class="o">.</span><span class="k">_</span>
<span class="k">import</span> <span class="nn">scalaz._</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="n">string</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">std</span><span class="o">.</span><span class="n">tuple</span><span class="o">.</span><span class="k">_</span><span class="o">,</span> <span class="n">syntax</span><span class="o">.</span><span class="n">applicative</span><span class="o">.</span><span class="k">_</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohi</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="s">"hi"</span> <span class="o">::</span> <span class="nc">HNil</span>
<span class="n">ohi</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]</span><span class="err">]</span>
        <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohi</span> <span class="o">++</span> <span class="n">ohi</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span><span class="err">]</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">String</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
  <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">13399</span><span class="n">e98</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">ohipohi.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Back over in Scalaz, for purposes of an <code class="highlighter-rouge">Applicative</code> instance,
<code class="highlighter-rouge">(String, Int)</code> selects its second type parameter.  Just as the
<code class="highlighter-rouge">To*OpsUnapply</code> functions acquire <code class="highlighter-rouge">Unapply</code> instances to do their
work:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nc">ToApplicativeOpsUnapply</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">v</span><span class="k">:</span> <span class="kt">FA</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">F0</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ApplicativeOps</span><span class="o">[</span><span class="kt">F0.M</span>,<span class="kt">F0.A</span><span class="o">](</span><span class="n">F0</span><span class="o">(</span><span class="n">v</span><span class="o">))(</span><span class="n">F0</span><span class="o">.</span><span class="nc">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>We can acquire an instance and use it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t2ap</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]]</span>
<span class="n">t2ap</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,<span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
<span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">18214797</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t2ap</span><span class="o">.</span><span class="nc">TC</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="the-mysterious-result">The mysterious result</h2>

<p>Now let’s get that first element out of that tuple we got by calling
<code class="highlighter-rouge">point</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">res5</span><span class="o">.</span><span class="n">_1</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">31</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">value</span> <span class="k">_</span><span class="err">1</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">a</span> <span class="kt">member</span> <span class="kt">of</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
              <span class="n">res5</span><span class="o">.</span><span class="n">_1</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Uh, huh?  Let’s try adding the <code class="highlighter-rouge">HList</code>s we got from <code class="highlighter-rouge">ohipohi</code> before.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cala</span><span class="o">&gt;</span> <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">32</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi.Out</span>,<span class="kt">ohipohi.Out</span><span class="o">]</span>
              <span class="n">res3</span> <span class="o">++</span> <span class="n">res3</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>The clue is in the type report in the above: path-dependent type
members of <code class="highlighter-rouge">t2ap</code> and <code class="highlighter-rouge">ohipohi</code> appear.  That wouldn’t be a problem,
normally, as we know what they are, but <strong>they’re existential</strong> to
Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">30</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Cannot</span> <span class="kt">prove</span> <span class="kt">that</span> <span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">=:=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Int</span><span class="o">).</span>
              <span class="n">implicitly</span><span class="o">[</span><span class="kt">t2ap.M</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="kt">=:=</span> <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
                        <span class="o">^</span>
</code></pre></div></div>

<h2 id="implicitly-only-gives-what-you-ask-for"><code class="highlighter-rouge">implicitly</code> only gives what you ask for</h2>

<p>The explanation lies with the <code class="highlighter-rouge">implicitly</code> calls we made to acquire
the specific dependent functions we wanted to use.  Let’s look at the
definition of <code class="highlighter-rouge">implicitly</code> and see if it can enlighten:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
</code></pre></div></div>

<p>In other words, <code class="highlighter-rouge">implicitly</code> returns exactly what you asked for,
type-wise.  Recall the inferred type of <code class="highlighter-rouge">ohipohi</code> when it was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ohipohi</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
           <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
</code></pre></div></div>

<p>Not coincidentally, <em>this is the exact type we gave as a type
parameter to <code class="highlighter-rouge">implicitly</code></em>.  What’s important is that <code class="highlighter-rouge">Out</code>, the type
member of <code class="highlighter-rouge">Prepend</code> that determines its result type, is existential in
both cases.</p>

<p>In other words, the rule of <code class="highlighter-rouge">implicitly</code> is “you asked for it, you got
it”.</p>

<h2 id="a-more-specific-implicitly">A more specific <code class="highlighter-rouge">implicitly</code></h2>

<p>The answer here is to simulate the weird way in which dependent method
types, like <code class="highlighter-rouge">++</code> and <code class="highlighter-rouge">ToApplicativeOpsUnapply</code>, can pass through extra
type information about their implicit parameters that would otherwise
be lost.  We do this by reinventing <code class="highlighter-rouge">implicitly</code>.</p>

<p>The first try is obvious: follow the comment in the <code class="highlighter-rouge">Predef.scala</code>
source and give <code class="highlighter-rouge">implicitly</code> a singleton type result.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitly2</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="kt">with</span> <span class="kt">e.</span><span class="k">type</span> <span class="o">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi2</span> <span class="k">=</span> <span class="n">implicitly2</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi2</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]</span>
     <span class="k">with</span> <span class="n">e</span><span class="o">.</span><span class="k">type</span> <span class="o">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mi">4</span><span class="n">abe65da</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi2</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">ohipohi2.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">33</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
              <span class="n">prepend</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span><span class="kt">ohipohi2.Out</span>,<span class="kt">ohipohi2.Out</span><span class="o">]</span>
              <span class="n">res9</span> <span class="o">++</span> <span class="n">res9</span>
                   <span class="o">^</span>
</code></pre></div></div>

<p>Not quite good enough.</p>

<h2 id="an-even-more-albeit-less-specific-implicitly">An even more, albeit less, specific <code class="highlighter-rouge">implicitly</code></h2>

<p>I think it’s strange that the above doesn’t work, but we can deal with
it by being a little more specific.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">implicitlyDepFn</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">DepFn2</span><span class="o">[</span><span class="k">_</span>,<span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">e</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
    <span class="k">:</span> <span class="kt">T</span> <span class="o">{</span><span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="kt">e.Out</span><span class="o">}</span> <span class="k">=</span> <span class="n">e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ohipohi3</span> <span class="k">=</span> <span class="n">implicitlyDepFn</span><span class="o">[</span><span class="kt">Prepend</span><span class="o">[</span><span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span>, <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">String</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">]]</span>
<span class="n">ohipohi3</span><span class="k">:</span> <span class="kt">shapeless.ops.hlist.Prepend</span><span class="o">[</span>
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]</span>,
              <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]{</span>
                <span class="k">type</span> <span class="kt">Out</span> <span class="o">=</span> <span class="n">shapeless</span><span class="o">.::[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
                            <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.HNil</span><span class="o">]]]]</span>
          <span class="o">}</span> <span class="k">=</span> <span class="n">shapeless</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">hlist$Prepend$$anon$58</span><span class="k">@</span><span class="mf">7306572f</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">ohipohi3</span><span class="o">(</span><span class="n">ohi</span><span class="o">,</span> <span class="n">ohi</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">ohipohi3.Out</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res11</span> <span class="o">++</span> <span class="n">res11</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">shapeless.::</span><span class="err">[</span><span class="kt">Int</span><span class="o">,</span><span class="n">shapeless</span><span class="o">.::[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">shapeless.::</span><span class="o">[</span><span class="kt">String</span>,
       <span class="kt">shapeless.HNil</span><span class="o">]]]]]]]</span><span class="err">]</span>
   <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">hi</span> <span class="o">::</span> <span class="nc">HNil</span>
</code></pre></div></div>

<p>Now that’s more like it.  The trick is in the return type of
<code class="highlighter-rouge">implicitlyDepFn</code>, which includes the structural refinement <code class="highlighter-rouge">{type Out
= e.Out}</code>.</p>

<p>Again, it’s weird that this structural refinement isn’t subsumed by
the return type <code class="highlighter-rouge">e.type</code> from <code class="highlighter-rouge">implicitly2</code>’s definition, but I’m not
sure it’s wrong, either, given the ephemeral nature of type stability.</p>

<p>Thankfully, most of the evidence for dependent function types in
Shapeless extends from the <code class="highlighter-rouge">DepFn*</code> traits, so you only need one of
these special <code class="highlighter-rouge">implicitly</code> variants for each, rather than one for each
individual dependent function type you wish to acquire instances of in
this way.</p>

<h2 id="and-likewise-with-unapply">And likewise with <code class="highlighter-rouge">Unapply</code></h2>

<p>We can similarly acquire instances of <code class="highlighter-rouge">scalaz.Unapply</code> conveniently.
I believe this function will be supplied with Scalaz 7.0.6, and it is
<a href="https://github.com/scalaz/scalaz/pull/621">already included in the 7.1 development branch</a>,
so you will be able to write <code class="highlighter-rouge">Unapply[TC, type]</code> to get instances as
with plain typeclass lookup in Scalaz, but it’s easy enough to define
yourself.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">unap</span><span class="o">[</span><span class="kt">TC</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">MA</span><span class="o">](</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">TC</span>, <span class="kt">MA</span><span class="o">])</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">U</span><span class="o">.</span><span class="n">A</span>
<span class="o">}</span> <span class="k">=</span> <span class="n">U</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">t2ap2</span> <span class="k">=</span> <span class="n">unap</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
<span class="n">t2ap2</span><span class="k">:</span> <span class="kt">U.</span><span class="k">type</span><span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">,</span> <span class="n">A</span><span class="o">);</span> <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span><span class="o">}</span> 
  <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">3</span><span class="n">adb9933</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">t2ap2</span><span class="o">.</span><span class="nc">TC</span><span class="o">.</span><span class="n">point</span><span class="o">(</span><span class="mi">42</span><span class="o">)</span>
<span class="n">res13</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span><span class="mi">42</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res13</span><span class="o">.</span><span class="n">_1</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
</code></pre></div></div>

<p><em>This article was tested with Scala 2.10.3, Scalaz 7.0.5, and
Shapeless 2.0.0-M1.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Jan 18, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
