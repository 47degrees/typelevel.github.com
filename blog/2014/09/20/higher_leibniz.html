<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Higher Leibniz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Higher Leibniz</h2>

  <p>We’ve previously seen
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">the basic implementation and motivation for <code class="highlighter-rouge">scalaz.Leibniz</code></a>.
But there’s still quite a bit more to this traditionally esoteric
member of the Scalaz collection of well-typed stuff.</p>

<h2 id="strictly-necessarily-strict">Strictly necessarily strict</h2>

<p>The word “witness” implies that <code class="highlighter-rouge">Leibniz</code> is a passive bystander in
your function; sitting back and telling you that some type is equal to
another type, otherwise content to let the <em>real</em> code do the real
work.  The fact that <code class="highlighter-rouge">Leibniz</code> lifts into functions (which are a
member of the <em>everything</em> set, you’ll agree) might reinforce the
notion that <code class="highlighter-rouge">Leibniz</code> is spooky action at a distance.</p>

<p>But one of the nice things about <code class="highlighter-rouge">Leibniz</code> is that there’s really no
cheating: the value with its shiny new type is dependent on the
<code class="highlighter-rouge">Leibniz</code> actually existing, and its <code class="highlighter-rouge">subst</code>, however much a glorified
identity function it might be, completing successfully.</p>

<p>To see this in action, let’s check in with the bastion of not
evaluating stuff, Haskell.</p>

<h2 id="the-haskell-implementation">The Haskell implementation</h2>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE RankNTypes, PolyKinds #-}</span>
<span class="kr">module</span> <span class="nn">Leib</span>
  <span class="p">(</span> <span class="kt">Leib</span><span class="p">()</span>
  <span class="p">,</span> <span class="nf">subst</span>
  <span class="p">,</span> <span class="nf">lift</span>
  <span class="p">,</span> <span class="nf">symm</span>
  <span class="p">,</span> <span class="nf">compose</span>
  <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Functor</span>

<span class="kr">data</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="p">{</span>
  <span class="n">subst</span> <span class="o">::</span> <span class="n">forall</span> <span class="n">f</span><span class="o">.</span> <span class="n">f</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="p">}</span>

<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">a</span>
<span class="n">refl</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="n">id</span>

<span class="n">lift</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="n">lift</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runOn</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">On</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">On</span> <span class="n">c</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">On</span> <span class="p">{</span>
  <span class="n">runOn</span> <span class="o">::</span> <span class="n">c</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">symm</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">a</span>
<span class="n">symm</span> <span class="n">ab</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">ab</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">refl</span>

<span class="kr">newtype</span> <span class="kt">Dual</span> <span class="n">c</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">Dual</span> <span class="p">{</span>
  <span class="n">runDual</span> <span class="o">::</span> <span class="n">c</span> <span class="n">b</span> <span class="n">a</span>
<span class="p">}</span>

<span class="n">compose</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">b</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">c</span>
<span class="n">compose</span> <span class="o">=</span> <span class="n">subst</span>
</code></pre></div></div>

<p>We use <a href="http://www.haskell.org/haskellwiki/Newtype">newtypes</a> in place
of type lambdas, and a value instead of a method, but the
implementation is otherwise identical.</p>

<h2 id="its-really-there">It’s really there</h2>

<p>OK.  Let’s try to make a fake <code class="highlighter-rouge">Leib</code>.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span>
<span class="n">badForce</span> <span class="o">=</span> <span class="kt">Leib</span> <span class="o">$</span> <span class="nf">\</span><span class="kr">_</span> <span class="o">-&gt;</span> <span class="ne">error</span> <span class="s">"sorry for fibbing"</span>
</code></pre></div></div>

<p>The following code will signal an error only if forcing the <em>head
cons</em> of the <code class="highlighter-rouge">subst</code>ed list signals such an error.  We never give
Haskell the chance to force anything else.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Oh well, let’s try to bury it behind combinators.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">symm</span> <span class="o">.</span> <span class="n">symm</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="n">subst</span> <span class="p">(</span><span class="n">compose</span> <span class="n">refl</span> <span class="o">$</span> <span class="n">badForce</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">Int</span> <span class="kt">String</span><span class="p">)</span> <span class="p">[</span><span class="mi">42</span><span class="p">]</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="mi">33</span>
<span class="o">***</span> <span class="kt">Exception</span><span class="o">:</span> <span class="n">sorry</span> <span class="n">for</span> <span class="n">fibbing</span>
</code></pre></div></div>

<p>Hmm.  We have two properties:</p>

<ol>
  <li>The <code class="highlighter-rouge">id</code> from <code class="highlighter-rouge">refl</code>?  The type-substituted data actually goes
through that function.  The same goes for the <code class="highlighter-rouge">subst</code> method in
Scala.</li>
  <li>When using <code class="highlighter-rouge">Leibniz</code> combinators, the strictness forms a chain to
all underlying <code class="highlighter-rouge">Leibniz</code> evidence.  If there are any missing
values, the transform will also fail.</li>
</ol>

<h2 id="higher-kinded-leibniz">Higher kinded <code class="highlighter-rouge">Leibniz</code></h2>

<p>Let’s try a variant on <code class="highlighter-rouge">Leib</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">H</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">H</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="highlighter-rouge">LeibF[G, H]</code> can replace <code class="highlighter-rouge">G</code> with <code class="highlighter-rouge">H</code> in <strong>any</strong> type
function”.  But, whereas the
<a href="https://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">kind</a>
of the types that Leib discusses is <code class="highlighter-rouge">*</code>, for <code class="highlighter-rouge">LeibF</code> it’s <code class="highlighter-rouge">*-&gt;*</code>.  So,
<code class="highlighter-rouge">LeibF[List, List]</code> exhibits that the <em>type constructors</em> <code class="highlighter-rouge">List</code> and
<code class="highlighter-rouge">List</code> are equal.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">refl</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">LeibF</span><span class="o">[</span><span class="kt">G</span>, <span class="kt">G</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Interestingly, except for the kinds of type parameters, these
definitions are exactly the same as for <code class="highlighter-rouge">Leib</code>.  Does that hold for
lift?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> , <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">x</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">x</span>, <span class="kt">?</span><span class="o">]]]](</span><span class="nc">LeibF</span><span class="o">.</span><span class="n">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">?</span><span class="o">]])</span>
</code></pre></div></div>

<p>Despite that we are positively buried in type lambdas (yet moderated
by <a href="https://github.com/non/kind-projector">Kind Projector</a>) now,
absolutely!</p>

<p>As an exercise, adapt your <code class="highlighter-rouge">symm</code> and <code class="highlighter-rouge">compose</code> methods from the last
part for <code class="highlighter-rouge">LeibF</code>, by only changing type parameters and switching any
<code class="highlighter-rouge">refl</code> references.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">symm</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">compose</span><span class="o">[</span><span class="kt">A</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">B</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">LeibF</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<p>You can write a <code class="highlighter-rouge">Leibniz</code> and associated combinators for types of
<em>any</em> kind; the principles and implementation techniques outlined
above for types of kind <code class="highlighter-rouge">*-&gt;*</code> apply to all kinds.</p>

<h2 id="whence-polykinds">Whence <code class="highlighter-rouge">PolyKinds</code>?</h2>

<p>You have to define a new <code class="highlighter-rouge">Leib</code> variant and set of combinators for
each kind you wish to support.  There is no need to do this in
Haskell, though.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">k</span> <span class="kt">Leib</span> <span class="kt">[]</span>
<span class="kt">Leib</span> <span class="kt">[]</span> <span class="o">::</span> <span class="p">(</span><span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">*</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">lift</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="kt">[]</span><span class="p">)</span>
<span class="err">λ</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span>
<span class="n">compose</span> <span class="p">(</span><span class="n">refl</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="kt">[]</span> <span class="kt">[]</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span> <span class="o">-&gt;</span> <span class="kt">Leib</span> <span class="n">a</span> <span class="kt">[]</span>
</code></pre></div></div>

<p>In Haskell, we can take advantage of the fact that the actual
implementations are kind-agnostic, by having those definitions be
applicable to all kinds via
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/kind-polymorphism.html">the <code class="highlighter-rouge">PolyKinds</code> language extension</a>,
mentioned at the top of the Haskell code above.  No such luck in
Scala.</p>

<h2 id="better-gadts">Better GADTs</h2>

<p><a href="http://d.hatena.ne.jp/xuwei/20140706/1404612620">In a post from a couple months ago</a>,
Kenji Yoshida outlines an interesting way to simulate the missing
type-evidence features of Scala’s GADT support with <code class="highlighter-rouge">Leibniz</code>.  This
works in Haskell, too, in case you are comfortable with turning on
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/other-type-extensions.html#universal-quantification"><code class="highlighter-rouge">RankNTypes</code></a>
but not
<a href="http://www.haskell.org/ghc/docs/7.8.3/html/users_guide/data-type-extensions.html#gadt"><code class="highlighter-rouge">GADTs</code></a>
somehow.</p>

<p>Let’s examine Kenji’s GADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For completeness, let’s also see the Haskell version, including the
function that demands so much hoop-jumping in Scala, but just works in
Haskell.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# LANGUAGE GADTs #-}</span>
<span class="kr">module</span> <span class="nn">FooXY</span> <span class="kr">where</span>

<span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span>
  <span class="kt">X</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">a</span>
  <span class="kt">Y</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="kt">X</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">bar</span>
</code></pre></div></div>

<p>Note that the Haskell type system understands that when <code class="highlighter-rouge">hoge</code>’s first
argument’s data constructor is <code class="highlighter-rouge">X</code>, the type variables <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code>
must be the same type, and therefore by implication the argument of
type <code class="highlighter-rouge">f a c</code> must also be of type <code class="highlighter-rouge">f b c</code>.  This is what we’re trying
to get Scala to understand.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">hoge1</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>This transliteration of the above Haskell <code class="highlighter-rouge">hoge</code> function fails to
compile, as Kenji notes, with the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">…</span><span class="o">/</span><span class="nc">LeibnizArticle</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">39</span><span class="kt">:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">bar.</span><span class="k">type</span> <span class="o">(</span><span class="kt">with</span> <span class="kt">underlying</span> <span class="k">type</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">C</span><span class="o">])</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>,<span class="kt">C</span><span class="o">]</span>
      <span class="k">case</span> <span class="n">X</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">bar</span>
                  <span class="o">^</span>
</code></pre></div></div>

<h2 id="the-overridden-cata-method">The overridden <code class="highlighter-rouge">cata</code> method</h2>

<p>Kenji introduces a <code class="highlighter-rouge">cata</code> method on <code class="highlighter-rouge">Foo</code> to constrain use of the
<code class="highlighter-rouge">Leibniz.force</code> hack, while still providing external code with usable
<code class="highlighter-rouge">Leibniz</code> evidence that can be lifted to implement <code class="highlighter-rouge">hoge</code>.  However,
by implementing the method in a slightly different way, we can use
<code class="highlighter-rouge">refl</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">x</span><span class="o">(</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">y</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can replace the pattern match (and all other such pattern
matches) with an equivalent <code class="highlighter-rouge">cata</code> invocation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">hoge2</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span><span class="o">.</span><span class="n">cata</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">),</span>
           <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sys</span> <span class="n">error</span> <span class="s">"nonexhaustive"</span><span class="o">)</span>
</code></pre></div></div>

<p>So why can we get away with <code class="highlighter-rouge">Leib.refl</code>, whereas the function version
Kenji presents cannot?  Compare the <code class="highlighter-rouge">cata</code> signature in <code class="highlighter-rouge">Foo</code> versus
<code class="highlighter-rouge">X</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
  <span class="k">def</span> <span class="n">cata</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>We supplied <code class="highlighter-rouge">A</code> for both the <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> type parameters in our
<code class="highlighter-rouge">extends</code> clause, so that substitution also applies in all methods
from <code class="highlighter-rouge">Foo</code> that we’re implementing, including <code class="highlighter-rouge">cata</code>.  At that point
it’s obvious to the compiler that <code class="highlighter-rouge">refl</code> implements the requested
<code class="highlighter-rouge">Leib</code>.</p>

<p>Incidentally, a similar style of substitution underlies the definition
of <code class="highlighter-rouge">refl</code>.</p>

<h2 id="the-leib-member">The <code class="highlighter-rouge">Leib</code> member</h2>

<p>What if we don’t want to write or maintain an overriding-style <code class="highlighter-rouge">cata</code>?
After all, that’s an n² commitment.  Instead, we can incorporate a
<code class="highlighter-rouge">Leib</code> value in the GADT.  First, let’s see what the equivalent
Haskell is, without the <code class="highlighter-rouge">GADTs</code> extension:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">X</span> <span class="p">(</span><span class="kt">Leib</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Y</span> <span class="n">a</span> <span class="n">b</span>

<span class="n">hoge</span> <span class="o">::</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="n">c</span>
<span class="n">hoge</span> <span class="p">(</span><span class="kt">X</span> <span class="n">leib</span><span class="p">)</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">runDual</span> <span class="o">.</span> <span class="n">subst</span> <span class="n">leib</span> <span class="o">.</span> <span class="kt">Dual</span> <span class="o">$</span> <span class="n">bar</span>
</code></pre></div></div>

<p>We needed <code class="highlighter-rouge">RankNTypes</code> to implement <code class="highlighter-rouge">Leib</code>, of course, but perhaps
that’s acceptable.  It’s useful in
<a href="https://ermine-language.github.io/">Ermine</a>, which supports rank-N
types but not GADTs as of this writing.</p>

<p>The above is simple enough to port to Scala, though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">X</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">leib</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Y</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>

<span class="k">def</span> <span class="n">hoge3</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bar</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">X</span><span class="o">(</span><span class="n">leib</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">leib</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">?</span>, <span class="kt">C</span><span class="o">]](</span><span class="n">bar</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>It feels a little weird that <code class="highlighter-rouge">X</code> now must retain <code class="highlighter-rouge">Foo</code>’s
type-system-level separation of the two type parameters.  But this
style may more naturally integrate in your ADTs, and it is much closer
to the original non-working <code class="highlighter-rouge">hoge1</code> implementation.</p>

<p>It also feels a little weird that you have to waste a slot carting
around this evidence of type equality.  As demonstrated in section
“It’s really there” above, though, <em>it matters that the instance
exists</em>.</p>

<p>You can play games with this definition to make it easier to supply
the wholly mechanical <code class="highlighter-rouge">leib</code> argument to <code class="highlighter-rouge">X</code>, e.g. adding it as an
<code class="highlighter-rouge">implicit val</code> in the second parameter list so it can be imported and
implicitly supplied on <code class="highlighter-rouge">X</code> construction.  The basic technique is
exactly the same as above, though.</p>

<h2 id="leibniz-mastery"><code class="highlighter-rouge">Leibniz</code> mastery</h2>

<p>This time we talked about</p>

<ul>
  <li>Why it matters that <code class="highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="highlighter-rouge">Leibniz</code>es,</li>
  <li>simulating GADTs with <code class="highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.2,
<a href="https://github.com/non/kind-projector">Kind Projector</a> 0.5.2, and
<a href="http://www.haskell.org/platform/">GHC</a> 7.8.3.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Sep 20, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
