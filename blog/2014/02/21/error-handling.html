<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | How do I error handle thee?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>How do I error handle thee?</h2>

  <p>Scala has several ways to deal with error handling, and often times people
get confused as to when to use what. This post hopes to address that.</p>

<p><em>Let me count the ways.</em></p>

<h2 id="option"><code class="highlighter-rouge">Option</code></h2>

<p>People coming to Scala from Java-like languages are often told <code class="highlighter-rouge">Option</code> is
a replacement for <code class="highlighter-rouge">null</code> or exception throwing. Say we have a function that
creates some sort of interval, but only allows intervals where the lower bound
comes first.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Interval</span><span class="o">(</span><span class="k">val</span> <span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&gt;</span> <span class="n">high</span><span class="o">)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Lower bound must be smaller than upper bound!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here we want to create an <code class="highlighter-rouge">Interval</code>, but we want to ensure that the lower bound
is smaller than the upper bound. If it isn’t, we throw an exception. The idea here
is to have some sort of “guarantee” that if at any point I’m given an <code class="highlighter-rouge">Interval</code>,
the lower bound is smaller than the upper bound (otherwise an exception would have
been thrown).</p>

<p>However, throwing exceptions breaks our ability to reason about a function/program.
Control is handed off to the call site, and we hope the call site catches it – if not,
it propagates further up until at some point something catches it, or our program
crashes. We’d like something a bit cleaner than that.</p>

<p>Enter <code class="highlighter-rouge">Option</code> – given our <code class="highlighter-rouge">Interval</code> constructor, construction may or may not succeed.
Put another way, after we enter the constructor, we may or may not have a valid
<code class="highlighter-rouge">Interval</code>. <code class="highlighter-rouge">Option</code> is a type that represents a value that may or may not be there;
it can either be <code class="highlighter-rouge">Some</code> or <code class="highlighter-rouge">None</code>. Let’s use what’s called a <em>smart constructor</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Interval</span> <span class="k">private</span><span class="o">(</span><span class="k">val</span> <span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Interval</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">low</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">high</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Interval</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Interval</span><span class="o">(</span><span class="n">low</span><span class="o">,</span> <span class="n">high</span><span class="o">))</span>
    <span class="k">else</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We make our class <code class="highlighter-rouge">final</code> so nothing can inherit from it, and we make our constructor
private so nobody can create an instance of <code class="highlighter-rouge">Interval</code> without going through our own
smart constructor function, <code class="highlighter-rouge">Interval.apply</code>. Our <code class="highlighter-rouge">apply</code> function takes some relevant
parameters, and returns an <code class="highlighter-rouge">Option[Interval]</code> that may or may not contain our constructed
<code class="highlighter-rouge">Interval</code>. Our function does not arbitrarily kick control back to the call site due
to an exception and we can reason about it much more easily.</p>

<h2 id="either-and-scalaz"><code class="highlighter-rouge">Either</code> and <code class="highlighter-rouge">scalaz.\/</code></h2>

<p>So, <code class="highlighter-rouge">Option</code> gives us <code class="highlighter-rouge">Some</code> or <code class="highlighter-rouge">None</code>, which is all we need if there is only one thing
that could go wrong. For instance, the standard library’s <code class="highlighter-rouge">Map[K, V]</code> has a function <code class="highlighter-rouge">get</code>
that given a key of type <code class="highlighter-rouge">K</code>, returns <code class="highlighter-rouge">Option[V]</code> – clearly if the key exists, the associated
value is returned (wrapped in a <code class="highlighter-rouge">Some</code>). If the key does not exist, it returns a <code class="highlighter-rouge">None</code>.</p>

<p>But sometimes one of several things can go wrong. Let’s say we have some wonky type that
wants a string that is exactly of length 5 and another string that is a palindrome.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="nc">None</span>
    <span class="k">else</span> <span class="nc">Some</span><span class="o">(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="c1">// say this returns None
</span></code></pre></div></div>

<p>Clearly something went wrong here, but we don’t know what. If the strings were sent over
from some front end via JSON or something, when we send an error back hopefully we have
something more descriptive than “Something went wrong.” What we want is instead of <code class="highlighter-rouge">None</code>,
we want something more descriptive. We can look into <code class="highlighter-rouge">Either</code> for this, where we use
<code class="highlighter-rouge">Left</code> to hold some sort of error value (similar to <code class="highlighter-rouge">None</code>), and <code class="highlighter-rouge">Right</code> to hold a successful
one (similar to <code class="highlighter-rouge">Some</code>).</p>

<p>To manipulate such values that may or may not exist (presumably obtained from functions that may or may not
fail), we use monadic functions such as <code class="highlighter-rouge">flatMap</code>, often in the form of monad comprehensions, or
for comprehensions as Scala calls them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="o">...</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="o">...</span>

<span class="k">for</span> <span class="o">{</span>
  <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">foo</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">bar</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">baz</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="n">d</span> <span class="k">&lt;-</span> <span class="n">quux</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">d</span>
</code></pre></div></div>

<p>In the case of <code class="highlighter-rouge">Option</code>, if any of <code class="highlighter-rouge">foo/bar/baz/quux</code> returns a <code class="highlighter-rouge">None</code>, that <code class="highlighter-rouge">None</code> simply
gets threaded through the rest of the computation – no <code class="highlighter-rouge">try/catch</code> statements marching off
the right side of the screen!</p>

<p>For comprehensions in Scala require the type we’re working with to have <code class="highlighter-rouge">flatMap</code> and
<code class="highlighter-rouge">map</code>. <code class="highlighter-rouge">flatMap</code>, along with <code class="highlighter-rouge">pure</code> and some laws, are the requisite functions needed
to form a monad – <code class="highlighter-rouge">map</code> can be defined in terms of <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">pure</code>.
With <code class="highlighter-rouge">scala.util.Either</code> however, we don’t have those – we have
to use an explicit conversion via <code class="highlighter-rouge">Either#right</code> or <code class="highlighter-rouge">Either#left</code> to get a
<code class="highlighter-rouge">RightProjection</code> or <code class="highlighter-rouge">LeftProjection</code> (respectively), which specifies in what direction we bias
the <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> calls. The convention however, is that the right side is the “correct”
(or “right”, if you will) side and the left represents the failure case, but it is tedious to
continously call <code class="highlighter-rouge">Either#right</code> on values of type <code class="highlighter-rouge">Either</code> to achieve this.</p>

<p>Thankfully, we have an alternative in the Scalaz library via
<code class="highlighter-rouge">scalaz.\/</code> (I just pronounce this “either” – some say disjoint union or just “or”), a right-biased
version of <code class="highlighter-rouge">scala.util.Either</code> – that is, calling <code class="highlighter-rouge">\/#map</code> maps over the value if it’s in
a “right” (<code class="highlighter-rouge">scalaz.\/-</code>), otherwise if it’s “left” (<code class="highlighter-rouge">scalaz.-\/</code>) it just threads it through
without touching it, much like how <code class="highlighter-rouge">Option</code> behaves. We can therefore alter the earlier function:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">scalaz.\/</code> also has several useful methods not found on <code class="highlighter-rouge">Either</code>.</p>

<h2 id="try"><code class="highlighter-rouge">Try</code></h2>

<p>As of Scala 2.10, we have <code class="highlighter-rouge">scala.util.Try</code> which is essentially an either, with the left type
fixed as <code class="highlighter-rouge">Throwable</code>. There are two problems (that I can think of at this moment) with this:</p>

<ol>
  <li>We want to avoid exceptions where we can.</li>
  <li>It violates the monad laws.</li>
</ol>

<p>A big factor in our ability to deal with all these error handling types nicely
is using their monadic properties in for comprehensions.</p>

<p>For an explanation of the monad laws, there is a nice post
<a href="http://eed3si9n.com/learning-scalaz/Monad+laws.html">here</a> describing them (using Scala). <code class="highlighter-rouge">Try</code>
violates the left identity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Try</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"oops"</span><span class="o">)</span>

<span class="n">foo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// exception is thrown
</span>
<span class="nc">Try</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">foo</span><span class="o">)</span> <span class="c1">// scala.util.Failure
</span></code></pre></div></div>

<p>This can cause unexpected behavior when used, perhaps in a monad/for comprehension. Furthermore,
<code class="highlighter-rouge">Try</code> encourages the use of <code class="highlighter-rouge">Throwable</code>s which breaks control flow and parametricity.
While it certainly may be convenient to be able to wrap an arbitrarily code block with the <code class="highlighter-rouge">Try</code> constructor
and let it catch any exception that may be thrown, we still recommend using an algebraic data type
describing the errors and using <code class="highlighter-rouge">YourErrorType \/ YourReturnType</code>.</p>

<h2 id="scalazvalidation"><code class="highlighter-rouge">scalaz.Validation</code></h2>

<p>Going back to our previous example with validating wonky strings, we see an improvement that
could be made.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">WonkyError</span> <span class="kt">\/</span> <span class="kt">Wonky</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">))</span>
    <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">palindrome</span> <span class="o">!=</span> <span class="n">palindrome</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="o">-\/(</span><span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span>
    <span class="k">else</span> <span class="o">\/-(</span><span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">five</span><span class="o">,</span> <span class="n">palindrome</span><span class="o">))</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span> <span class="c1">// -\/(MustHaveLengthFive("foo"))
</span></code></pre></div></div>

<p>The fact that one string must have a length of 5 can be checked and reported separately from the other 
being palindromic. Note that in the above example <code class="highlighter-rouge">"foo"</code> does not satisfy the length requirement,
and <code class="highlighter-rouge">"bar"</code> does not satisfy the palindromic requirement, yet only <code class="highlighter-rouge">"foo"</code>’s error is reported
due to how <code class="highlighter-rouge">\/</code> works. What if we want to report any and all errors that could be reported
(“foo” does not have a length of 5 and “bar” is not palindromic)?</p>

<p>If we want to validate several properties at once, and return any and all validation errors,
we can turn to <code class="highlighter-rouge">scalaz.Validation</code>. The modified function would look something like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">WonkyError</span>

<span class="k">final</span> <span class="k">class</span> <span class="nc">Wonky</span> <span class="k">private</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Wonky</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">checkFive</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">five</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">5</span><span class="o">)</span> <span class="nc">MustHaveLengthFive</span><span class="o">(</span><span class="n">five</span><span class="o">).</span><span class="n">failNel</span>
    <span class="k">else</span> <span class="n">five</span><span class="o">.</span><span class="n">success</span>

  <span class="k">def</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="o">.</span><span class="n">reverse</span><span class="o">)</span> <span class="nc">MustBePalindromic</span><span class="o">(</span><span class="n">p</span><span class="o">).</span><span class="n">failNel</span>
    <span class="k">else</span> <span class="n">p</span><span class="o">.</span><span class="n">success</span>

  <span class="k">def</span> <span class="n">validate</span><span class="o">(</span><span class="n">five</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">palindrome</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ValidationNel</span><span class="o">[</span><span class="kt">WonkyError</span>, <span class="kt">Wonky</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">checkFive</span><span class="o">(</span><span class="n">five</span><span class="o">)</span> <span class="o">|@|</span> <span class="n">checkPalindrome</span><span class="o">(</span><span class="n">palindrome</span><span class="o">))</span> <span class="o">{</span> <span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">new</span> <span class="nc">Wonky</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">p</span><span class="o">)</span> <span class="o">}</span>
<span class="o">}</span>

<span class="cm">/* Somewhere else.. */</span>
<span class="c1">// Failure(NonEmptyList(MustHaveLengthFive("foo"), MustBePalindromic("bar")))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"foo"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Failure(NonEmptyList(MustBePalindromic("bar")))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"bar"</span><span class="o">)</span>

<span class="c1">// Success(Wonky("monad", "radar"))
</span><span class="nc">Wonky</span><span class="o">.</span><span class="n">validate</span><span class="o">(</span><span class="s">"monad"</span><span class="o">,</span> <span class="s">"radar"</span><span class="o">)</span>
</code></pre></div></div>

<p>Awesome! However, there is one caveat – we cannot in good conscience use
<code class="highlighter-rouge">scalaz.Validation</code> in a for comprehension. Why? Because there is no valid
monad for it. <code class="highlighter-rouge">Validation</code>’s accumulative nature works via its <code class="highlighter-rouge">Applicative</code>
instance, but due to how the instance works, there is no consistent monad
(every monad is an applicative functor, where monadic bind is consistent with
applicative apply). However, you can use the <code class="highlighter-rouge">Validation#disjunction</code> function to
convert it to a <code class="highlighter-rouge">scalaz.\/</code>, which can then be used in a for comprehension.</p>

<p>One more thing to note: in the above code snippet I used
<code class="highlighter-rouge">ValidationNel</code>, which is just a type alias.
<code class="highlighter-rouge">ValidationNel[E, A]</code> stands for for 
<code class="highlighter-rouge">Validation[NonEmptyList[E], A]</code> – the actual <code class="highlighter-rouge">Validation</code> will take
anything on the left side that is a <code class="highlighter-rouge">Semigroup</code>, and <code class="highlighter-rouge">ValidationNel</code> is
provided as a convenience as often times you may want a non-empty
list of errors describing the various errors that happened in a function.
However, you can do several interesting things with other semigroups.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/adelbertchang.jpeg" />
      
      <p>by Adelbert Chang
    
    on Feb 21, 2014</p>

    
  <a href="https://twitter.com/adelbertchang" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @adelbertchang</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/adelbertc" aria-label="Follow @adelbertc on GitHub">Follow @adelbertc</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
