<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | A function from type equality to Leibniz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>A function from type equality to Leibniz</h2>

  <p>The Scala standard library provides evidence of two types being equal
at the data level: a value of type
<a href="http://www.scala-lang.org/api/2.11.1/scala/Predef$$$eq$colon$eq.html"><code class="highlighter-rouge">(A =:= B)</code></a>
witnesses that <code class="highlighter-rouge">A</code> and <code class="highlighter-rouge">B</code> are the same type. Accordingly, it provides
an implicit conversion from <code class="highlighter-rouge">A</code> to <code class="highlighter-rouge">B</code>. So you can write <code class="highlighter-rouge">Int</code>-summing
functions on your generic foldable types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">XList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=:=</span> <span class="nc">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That works because <code class="highlighter-rouge">ev</code> is inserted as an implicit conversion over
that lambda’s second parameter.</p>

<h2 id="fragility">Fragility</h2>

<p>That’s not really what we want, though. In particular, flipping <code class="highlighter-rouge">A</code>
and <code class="highlighter-rouge">Int</code> in the <code class="highlighter-rouge">ev</code> type declaration will break it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>….scala:5: overloaded method value + with alternatives:
  (x: Int)Int &lt;and&gt;
  (x: Char)Int &lt;and&gt;
  (x: Short)Int &lt;and&gt;
  (x: Byte)Int
 cannot be applied to (A)
    xs.foldLeft(0)(_ + _)
                     ^
</code></pre></div></div>

<p>That doesn’t make sense, though. Type equality is symmetric: Scala
knows it goes both ways, so why is this finicky?</p>

<p>Additionally, we apply the conversion for each <code class="highlighter-rouge">Int</code>. It is a logical
implication that, if <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">B</code>, then <code class="highlighter-rouge">List[A]</code> must be <code class="highlighter-rouge">List[B]</code> as
well. But we can’t get that cheap, single conversion without a cast.</p>

<h2 id="substitution">Substitution</h2>

<p>Scalaz instead provides
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/scalaz/Leibniz.html"><code class="highlighter-rouge">Leibniz</code></a>,
a more perfect type equality. A simplified version follows, which we
will use for the remainder.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This reads “<code class="highlighter-rouge">Leib[A, B]</code> can replace <code class="highlighter-rouge">A</code> with <code class="highlighter-rouge">B</code> in <strong>any</strong> type
function”. That “any” is pretty important: it gives us both the
theorem that we want, and a tremendous consequent power that gives us
most of what we can get in Scala from value-level type equality, by
choosing the right <code class="highlighter-rouge">F</code> type parameter to <code class="highlighter-rouge">subst</code>.</p>

<h2 id="what-could-it-be">What could it be?</h2>

<p>Following the Scalazzi rules, where no <code class="highlighter-rouge">null</code>, type testing or
casting, or <code class="highlighter-rouge">AnyRef</code>-defined functions are permitted, what might go in
the body of that function? Even if you know what <code class="highlighter-rouge">A</code> is, as a <code class="highlighter-rouge">Leib</code>
implementer, it’s hidden behind the unknown <code class="highlighter-rouge">F</code>. Even if you know that
<code class="highlighter-rouge">B</code> is a supertype of <code class="highlighter-rouge">A</code>, you don’t know that <code class="highlighter-rouge">F</code> is covariant,
<a href="/blog/2014/03/09/liskov_lifting.html">by scalac or otherwise</a>.
Even if you know that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">B</code> is <code class="highlighter-rouge">Double</code>, what are you
going to do with that information?</p>

<p>So there’s only one thing this <code class="highlighter-rouge">Leib</code> could be, because you <strong>do</strong>
have an <code class="highlighter-rouge">F</code> of <em>something</em>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">refl</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">fa</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Every type is equal to itself. Every well-formed <code class="highlighter-rouge">Leib</code> instance
starts out this way, in this function.</p>

<h2 id="recovery">Recovery</h2>

<p>So, it’s great that <em>we</em> know the implication of the <code class="highlighter-rouge">subst</code> method’s
generality. But that’s not good enough; we had that with <code class="highlighter-rouge">=:=</code>
already. We want to write well-typed operations that represent all the
implications of the <code class="highlighter-rouge">Leib</code> type equality as <em>new</em> <code class="highlighter-rouge">Leib</code>s representing
<em>those</em> type equalities.</p>

<p>First, let’s solve the original problem, using infix type application
to show the similarity to <code class="highlighter-rouge">=:=</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum2</span><span class="o">(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">List</span><span class="o">](</span><span class="n">xs</span><span class="o">).</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>There is no more implicit conversion, the result of <code class="highlighter-rouge">subst</code> is the same
object as the argument, and <code class="highlighter-rouge">[List]</code> would be inferred, but I have
merely specified it for clarity in this example.</p>

<p>This doesn’t compose, though. What if, having <code class="highlighter-rouge">subst</code>ed <code class="highlighter-rouge">Int</code> into
that <code class="highlighter-rouge">List</code> type, I now want to <code class="highlighter-rouge">subst</code> <code class="highlighter-rouge">List[A]</code> for <code class="highlighter-rouge">List[Int]</code> in
some type function? Specifically, what about a <code class="highlighter-rouge">Leib</code> that represents
that type equality? To handle that, we can <code class="highlighter-rouge">subst</code> into <code class="highlighter-rouge">Leib</code> itself!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">Lambda</span><span class="o">[</span><span class="kt">X</span> <span class="k">=&gt;</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">F</span><span class="o">[</span><span class="kt">X</span><span class="o">]]]](</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<p>Again, the final <code class="highlighter-rouge">[F[A]]</code> could be inferred.</p>

<p>As an exercise, define the <code class="highlighter-rouge">symm</code> and <code class="highlighter-rouge">compose</code> operations, which
represent that <code class="highlighter-rouge">Leib</code> is symmetric and transitive as well. Hints: the
<code class="highlighter-rouge">symm</code> body is the same except for the type parameters given, and
<code class="highlighter-rouge">compose</code> doesn’t use <code class="highlighter-rouge">refl</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">symm</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">A</span><span class="o">]</span>
<span class="k">def</span> <span class="n">compose</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">],</span> <span class="n">bc</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">Leib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">C</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="leib-power">Leib power</h2>

<p>In Scalaz, <code class="highlighter-rouge">Leibniz</code> is already defined, and
<a href="https://github.com/scalaz/scalaz/blob/v7.0.6/core/src/main/scala/scalaz/syntax/TraverseSyntax.scala#L22-L26">used in a few places</a>.
Though their <code class="highlighter-rouge">subst</code> definitions are completely incompatible at the
scalac level, they have a weird equivalence due to the awesome power
of <code class="highlighter-rouge">subst</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.===</span>

<span class="k">def</span> <span class="n">toScalaz</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span> <span class="k">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">===</span> <span class="kt">?</span><span class="o">](</span><span class="nc">Leibniz</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>

<span class="k">def</span> <span class="n">toLeib</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ab</span><span class="k">:</span> <span class="kt">A</span> <span class="o">===</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">B</span> <span class="o">=</span>
  <span class="n">ab</span><span class="o">.</span><span class="n">subst</span><span class="o">[</span><span class="kt">A</span> <span class="kt">Leib</span> <span class="kt">?</span><span class="o">](</span><span class="nc">Leib</span><span class="o">.</span><span class="n">refl</span><span class="o">)</span>
</code></pre></div></div>

<p>…where <code class="highlighter-rouge">?</code> is to type-lambdas as <code class="highlighter-rouge">_</code> is to Scala lambdas, thanks to
<a href="https://github.com/non/kind-projector#kind-projector">the Kind Projector plugin</a>.</p>

<p>And so it would be with any pair of <code class="highlighter-rouge">Leibniz</code> representations with such
<code class="highlighter-rouge">subst</code> methods that you might define. Unfortunately, <code class="highlighter-rouge">=:=</code> cannot
participate in this universe of isomorphisms; it lacks the <code class="highlighter-rouge">subst</code>
method that serves as the <code class="highlighter-rouge">Leibniz</code> certificate of authenticity. You can
get a <code class="highlighter-rouge">=:=</code> from a <code class="highlighter-rouge">Leibniz</code>, but not vice versa.</p>

<p>Why would you want that weak sauce anyway?</p>

<h2 id="looking-up">Looking up</h2>

<p>These are just the basics.  Above:</p>

<ul>
  <li>The weakness of Scala’s own <code class="highlighter-rouge">=:=</code>,</li>
  <li>the sole primitive <code class="highlighter-rouge">Leibniz</code> operator <code class="highlighter-rouge">subst</code>,</li>
  <li>how to logically derive other type equalities,</li>
  <li>the isomorphism between each <code class="highlighter-rouge">Leibniz</code> representation and all
others.</li>
</ul>

<p><a href="/blog/2014/09/20/higher_leibniz.html">In the next part</a>, we’ll
look at:</p>

<ul>
  <li>Why it matters that <code class="highlighter-rouge">subst</code> always executes to use a type equality,</li>
  <li>the Haskell implementation,</li>
  <li>higher-kinded type equalities and their <code class="highlighter-rouge">Leibniz</code>es,</li>
  <li>why
<a href="https://github.com/scala/scala/blob/v2.11.1/src/library/scala/Predef.scala#L399-L402">the <code class="highlighter-rouge">=:=</code> singleton trick</a>
is unsafe,</li>
  <li>simulating GADTs with <code class="highlighter-rouge">Leibniz</code> members of data constructors.</li>
</ul>

<p><em>This article was tested with Scala 2.11.1, Scalaz 7.0.6, and Kind
Projector 0.5.2.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Jul 02, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
