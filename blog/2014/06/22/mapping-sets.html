<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | How can we map a Set?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>How can we map a Set?</h2>

  <p>Scalaz used to have a <code class="highlighter-rouge">scalaz.Functor</code> for <code class="highlighter-rouge">scala.collection.Set</code> but
it was <a href="https://github.com/scalaz/scalaz/pull/276">eventually removed</a>
because it relied on
<a href="http://www.scala-lang.org/api/2.10.3/index.html#scala.Any">Any’s == method</a>. You
can read more about why <code class="highlighter-rouge">Functor[Set]</code> is a bad idea at
<a href="http://failex.blogspot.jp/2013/06/fake-theorems-for-free.html">Fake Theorems for Free</a>.</p>

<p>If <code class="highlighter-rouge">Set</code> had been truly parametric, we wouldn’t have been able to
define a <code class="highlighter-rouge">Functor</code> in the first place. Luckily, a truly parametric Set
has recently been added to Scalaz as <code class="highlighter-rouge">scalaz.ISet</code>, with preliminary
benchmarks also showing some nice performance improvements. I highly
recommend using <code class="highlighter-rouge">ISet</code> whenever you can!</p>

<p>Now we can see the problem more clearly; the type of <code class="highlighter-rouge">map</code> on <code class="highlighter-rouge">ISet</code>
is too restrictive to be used inside of a <code class="highlighter-rouge">Functor</code> because of the
<code class="highlighter-rouge">scalaz.Order</code> constraint:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">ISet</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>And it might seem like we’ve lost something useful by not having a
<code class="highlighter-rouge">Functor</code> available. For example, we can’t write the following:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span> <span class="c1">// a non-empty Set
</span><span class="k">val</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="n">nes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>Which is because the <code class="highlighter-rouge">map</code> function on <code class="highlighter-rouge">scalaz.OneAnd</code> requires a
<code class="highlighter-rouge">scalaz.Functor</code> for the <code class="highlighter-rouge">F[_]</code> type parameter, which is <code class="highlighter-rouge">ISet</code> in the
above example.</p>

<p>But we have a solution! It’s called
<a href="http://docs.typelevel.org/api/scalaz/nightly/#scalaz.Coyoneda">Coyoneda</a>
(also known as the Free Functor) and it’ll hopefully be able to
demonstrate why not having <code class="highlighter-rouge">Functor[ISet]</code> available has no
fundamental, practical consequences.</p>

<p>Coyoneda
<a href="http://blog.higher-order.com/blog/2013/11/01/free-and-yoneda/">can be defined in Scala</a>
like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">I</span>
  <span class="k">def</span> <span class="n">k</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">A</span>
  <span class="k">def</span> <span class="n">fi</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">I</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>There are just three parts to it:</p>

<ol>
  <li><code class="highlighter-rouge">I</code> - an existential type</li>
  <li><code class="highlighter-rouge">k</code> - a mapping from <code class="highlighter-rouge">I</code> to <code class="highlighter-rouge">A</code></li>
  <li><code class="highlighter-rouge">fi</code> - a value of <code class="highlighter-rouge">F[I]</code></li>
</ol>

<p>We can create a couple of functions to help with constructing a
Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="nc">_k</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span> <span class="o">}</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">B</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">type</span> <span class="kt">I</span> <span class="o">=</span> <span class="n">A</span>
    <span class="k">val</span> <span class="n">k</span> <span class="k">=</span> <span class="nc">_k</span>
    <span class="k">val</span> <span class="n">fi</span> <span class="k">=</span> <span class="n">fa</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">identity</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>The constructors allow any type constructor to become a Coyoneda value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="mi">1</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">))</span>
</code></pre></div></div>

<p>Now here’s the special part; we can define a <code class="highlighter-rouge">Functor</code> for all
Coyoneda values:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">coyonedaFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>,<span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">ya</span><span class="k">:</span> <span class="kt">Coyoneda</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">(</span><span class="n">ya</span><span class="o">.</span><span class="n">fi</span><span class="o">)(</span><span class="n">f</span> <span class="n">compose</span> <span class="n">ya</span><span class="o">.</span><span class="n">k</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>What’s interesting is that the <code class="highlighter-rouge">F[_]</code> type does <em>not</em> have to have a
<code class="highlighter-rouge">Functor</code> defined for the Coyoneda to be mapped!</p>

<p>Let’s use this to try out our original example. We’ll define a type
alias to make things a bit cleaner:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">ISetF</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Coyoneda</span><span class="o">[</span><span class="kt">ISet</span>, <span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>And we can use this new type instead of a plain <code class="highlighter-rouge">ISet</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Scala has a really hard time with inference here, so we have to help it out.
</span><span class="k">val</span> <span class="n">functor</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">.</span><span class="n">oneAndFunctor</span><span class="o">[</span><span class="kt">ISetF</span><span class="o">](</span><span class="nc">Coyoneda</span><span class="o">.</span><span class="n">coyonedaFunctor</span><span class="o">[</span><span class="kt">ISet</span><span class="o">])</span>
<span class="k">import</span> <span class="nn">functor.functorSyntax._</span>

<span class="k">val</span> <span class="n">nes</span> <span class="k">=</span> <span class="nc">OneAnd</span><span class="o">[</span><span class="kt">ISetF</span>, <span class="kt">String</span><span class="o">](</span><span class="s">"2014-05-01"</span><span class="o">,</span> <span class="nc">Coyoneda</span><span class="o">.</span><span class="n">lift</span><span class="o">(</span><span class="nc">ISet</span><span class="o">.</span><span class="n">fromList</span><span class="o">(</span><span class="s">"2014-06-01"</span> <span class="o">::</span> <span class="s">"2014-06-22"</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)))</span>
<span class="k">val</span> <span class="nc">OneAnd</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=</span> <span class="n">nes</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseDate</span><span class="o">)</span>
</code></pre></div></div>

<p>So we’ve been able to map the Coyoneda! But how do we do something
useful with it?</p>

<p>We couldn’t define a <code class="highlighter-rouge">Functor</code> because it needs <code class="highlighter-rouge">scalaz.Order</code> on the
output type, but we can use the <code class="highlighter-rouge">map</code> method directly on <code class="highlighter-rouge">ISet</code>. We
can use that function by running the Coyoneda like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Converts ISetF back to an ISet, using ISet#map with the Order constraint
</span><span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">t</span><span class="o">.</span><span class="n">fi</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">t</span><span class="o">.</span><span class="n">k</span><span class="o">).</span><span class="n">insert</span><span class="o">(</span><span class="n">h</span><span class="o">)</span>
</code></pre></div></div>

<p>And we’re done!</p>

<p>We’ve been able to use Coyoneda to treat an <code class="highlighter-rouge">ISet</code> as a <code class="highlighter-rouge">Functor</code>,
even though its map function is too constrained to have one defined
directly. This same technique applies to <code class="highlighter-rouge">scala.collection.Set</code> and
any other type-constructor which would otherwise require a
<a href="http://okmij.org/ftp/Haskell/types.html#restricted-datatypes">restricted <code class="highlighter-rouge">Functor</code></a>. I
hope this has demonstrated that <code class="highlighter-rouge">Functor[Set]</code> not existing has no
practical consequences, other than scalac not being as good at
type-inference.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Brian McKenna
    
    on Jun 22, 2014</p>

    
  <a href="https://twitter.com/puffnfresh" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @puffnfresh</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/puffnfresh" aria-label="Follow @puffnfresh on GitHub">Follow @puffnfresh</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
