<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | When can Liskov be lifted?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>When can Liskov be lifted?</h2>

  <p>Scalaz avoids
<a href="http://docs.scala-lang.org/tutorials/tour/variances.html">variance in the sense of the Scala type parameter annotation</a>,
with its associated higher-kind implications, except where it has
historically featured variance; even here, variance is vanishing as
<a href="https://github.com/scalaz/scalaz/pull/630">unsoundness in its released implementations is discovered</a>.</p>

<p>There is a deeply related concept in Scalaz’s typeclasses, though:
<em>covariant and contravariant
functors</em>. <a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Functor"><code class="highlighter-rouge">Functor</code></a>
is traditional shorthand for covariant functor, whereas
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Contravariant"><code class="highlighter-rouge">Contravariant</code></a>
represents contravariant functors.</p>

<p>These concepts are related, but neither subsumes the other. A
<code class="highlighter-rouge">Functor</code> instance does not require its parameter to be
Scala-covariant. A type can be Scala-covariant over a parameter
without having a legal <code class="highlighter-rouge">Functor</code> instance.</p>

<h2 id="liskov"><code class="highlighter-rouge">Liskov</code></h2>

<p><a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Liskov"><code class="highlighter-rouge">Liskov</code></a>,
also known as <code class="highlighter-rouge">&lt;~&lt;</code> and very close to Scala’s own
<a href="http://www.scala-lang.org/api/current/#scala.Predef$$$less$colon$less"><code class="highlighter-rouge">&lt;:&lt;</code></a>,
represents a subtyping relationship, and is defined by the ability to
lift it into Scala-covariant and Scala-contravariant parameter
positions, like so:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCo</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">+</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="k">def</span> <span class="n">liftCt</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">-</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>As <code class="highlighter-rouge">Liskov</code> is, soundly, Scala-variant, this can be implemented
without a cast. However, it can only be called with Scala-covariant
<code class="highlighter-rouge">F</code>.</p>

<p>By definition, applying an <code class="highlighter-rouge">A &lt;~&lt; B</code> to a value of type <code class="highlighter-rouge">A</code> should
yield a value of type <code class="highlighter-rouge">B</code>, but must also do nothing but return the
value; in other words, it is an <em>operational identity</em>. Despite the
limitation of <code class="highlighter-rouge">liftCo</code>, for functorial values that are <em>parametrically
sound</em>, even for Scala-invariant <code class="highlighter-rouge">F</code>, it is operationally sound to
lift <code class="highlighter-rouge">Liskov</code>, though impossible to implement without exploiting Scala
soundness holes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCvf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>For example,
<a href="https://github.com/scalaz/scalaz/blob/v7.1.0-M5/core/src/main/scala/scalaz/IList.scala#L434-L437">this is sound for <code class="highlighter-rouge">scalaz.IList</code></a>.</p>

<h2 id="but-ilistint-isnt-a-subtype-of-ilistany">But <code class="highlighter-rouge">IList[Int]</code> isn’t a subtype of <code class="highlighter-rouge">IList[Any]</code>!</h2>

<p>Sure, as far as Scala is concerned.  But <code class="highlighter-rouge">Liskov</code> is all about making
claims that can’t directly be proven due to the language’s
limitations.  Haskell allows you to constrain functions with type
equalities, which is very important when working with type families;
Scala doesn’t, so we get
<a href="http://docs.typelevel.org/api/scalaz/stable/7.0.4/doc/#scalaz.Leibniz"><code class="highlighter-rouge">Leibniz</code></a>
instead.</p>

<p>A type is a set of values.  Where <em>Y</em> is a supertype of <em>X</em>, every
value in <em>X</em> is in <em>Y</em>.  Since <code class="highlighter-rouge">IList[String]("hi", "there")</code> has the
same representation as <code class="highlighter-rouge">IList[Any]("hi", "there")</code>, they are the same
value.  This is true for <em>all</em> <code class="highlighter-rouge">IList[String]</code>s, but the opposite is
not true; therefore, <code class="highlighter-rouge">IList[Any]</code> is an <code class="highlighter-rouge">IList[String]</code> supertype,
regardless of what Scala knows.</p>

<p>So doing a casting <code class="highlighter-rouge">Liskov</code> lift, like that into <code class="highlighter-rouge">IList</code>, is
essentially “admitted” in a proof system sense.  You are saying, “I
can’t prove that this subtype relationship holds, but it does, so
assume it.”</p>

<p><strong>To decide whether an admitted <code class="highlighter-rouge">A &lt;~&lt; B</code> is sound</strong>: suppose that the
compiler admits that subtyping relationship.  Can it then draw
incorrect conclusions, about the sets of values, derived from that
assumption?  This is the cardinal rule.</p>

<p>By extension, <strong>to decide whether an <code class="highlighter-rouge">F</code> permits Liskov lifting</strong>:
does the above rule pass given <code class="highlighter-rouge">F[A] &lt;~&lt; F[B]</code> <em>for all</em> <code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">B</code>
where <code class="highlighter-rouge">B</code> is a supertype of <code class="highlighter-rouge">A</code>?</p>

<h2 id="parametrically-sound-covariance">Parametrically sound covariance</h2>

<p>Because a <code class="highlighter-rouge">Liskov</code> must be an operational identity, it is essential
that, given any value of <code class="highlighter-rouge">F[A]</code>, for all supertypes <code class="highlighter-rouge">B</code> of <code class="highlighter-rouge">A</code>, the
representation of <code class="highlighter-rouge">F[B]</code> must be identical.  You can determine this by
analyzing the subclasses of <code class="highlighter-rouge">F</code> as an algebraic data type, where the
key test is to ensure that <code class="highlighter-rouge">A</code> <em>never</em> appears in the primitive
contravariant position: as the parameter to a function.  This test is
not quite enough to prove that <code class="highlighter-rouge">Liskov</code> lifting is sound, but it gets
us most of the way.</p>

<p>For example, an <code class="highlighter-rouge">IList</code> of <code class="highlighter-rouge">"hi"</code> and <code class="highlighter-rouge">"there"</code> has exactly the same
representation whether you instantiated the <code class="highlighter-rouge">IList</code> with <code class="highlighter-rouge">String</code> or
with <code class="highlighter-rouge">Any</code>. So that is a good first test. If a class changes its
construction behavior based on manifest type information, or its basic
data construction functions violate
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">the rules of parametricity</a>,
that is a good sign that the data type cannot follow these rules.</p>

<p>This data type analysis is recursive: a data type being variant in a
parametrically sound way over a parameter requires that all
appearances of that parameter in elements of your data type are also
parametrically sound in that way. For example, if your <code class="highlighter-rouge">F[A]</code> contains
an <code class="highlighter-rouge">IList[A]</code> in its representation, you may rely on <code class="highlighter-rouge">IList</code>’s
parametrically sound covariance when considering <code class="highlighter-rouge">F</code>’s.</p>

<p>Any <code class="highlighter-rouge">var</code>, or <code class="highlighter-rouge">var</code>-like thing such as an <code class="highlighter-rouge">Array</code>, places its
parameter in an invariant position, because it features a getter
(return type) and setter (parameter type). So its presence in the data
model invalidates <code class="highlighter-rouge">Liskov</code> lifting if the type parameter appears
within it.</p>

<p>Obviously, runtime evidence of a type parameter’s value eliminates the
possibility of lifting <code class="highlighter-rouge">Liskov</code> over that parameter.</p>

<p>You cannot perform this representation analysis without considering
all subclasses of a class under consideration. For example,
considering only
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.HashSet"><code class="highlighter-rouge">HashSet</code></a>,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.Set"><code class="highlighter-rouge">collection.immutable.Set</code></a>
appears to allow <code class="highlighter-rouge">Liskov</code> lifting. However,
<a href="http://www.scala-lang.org/api/current/#scala.collection.immutable.TreeSet"><code class="highlighter-rouge">TreeSet</code></a>,
a subclass of <code class="highlighter-rouge">Set</code>, contains a function <code class="highlighter-rouge">(A, A) =&gt; Ordering</code>. If
<em>any</em> representation contains a contradiction like this, <code class="highlighter-rouge">Liskov</code>
lifting is unsafe. You cannot constrain <code class="highlighter-rouge">Liskov</code> application by a
runtime test.</p>

<p>If you permit open subclassing, you must either declare the
requirement to preserve parametric covariance, or accept that it will
be violated, and so forbid <code class="highlighter-rouge">Liskov</code> lifting.</p>

<p>Data that doesn’t use a type parameter doesn’t affect its parametric
soundness.  For example, here <code class="highlighter-rouge">A</code> is invariant, but <code class="highlighter-rouge">B</code> is covariant:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">VA</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span>
</code></pre></div></div>

<h2 id="gadts">GADTs</h2>

<p>Some features of Scala resist simple ADT analysis, so must be
considered separately from the above.  Despite their sound covariance
considering only the representational rules in the previous section,
they still break the cardinal rule by allowing the compiler to make
invalid assumptions about the sets of values.  A “recoverable phantom”
implies a type relationship that forbids <code class="highlighter-rouge">Liskov</code>-lifting, for
example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>In pattern matching, given a <code class="highlighter-rouge">Gimme[A]</code> over unknown <code class="highlighter-rouge">A</code>, matching
<code class="highlighter-rouge">GimmeI</code> successfully recovers the type equality <code class="highlighter-rouge">A ~ Int</code>; therefore,
<code class="highlighter-rouge">Liskov</code>-lifting is unsound for <code class="highlighter-rouge">Gimme</code>.  For example, lifting
<code class="highlighter-rouge">Int &lt;~&lt; Any</code>, applying to <code class="highlighter-rouge">GimmeI</code>, and matching, gives us
<code class="highlighter-rouge">Any ~ Int</code>, which is nonsense.</p>

<p>We can reason about this type equality as a value member of <code class="highlighter-rouge">GimmeI</code>
of type <code class="highlighter-rouge">Leibniz[⊥, ⊤, A, Int]</code>, which places <code class="highlighter-rouge">A</code> in a
representationally invariant position.</p>

<p>Some other GADTs invalidate covariance. For example:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">P</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">PP</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">P</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">extends</span> <span class="n">P</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>The pattern match of a <code class="highlighter-rouge">P[A]</code> to <code class="highlighter-rouge">PP[_,_]</code> can theoretically determine
<code class="highlighter-rouge">A ~ (x, y) forSome {type x; type y}</code>, so <code class="highlighter-rouge">Liskov</code> cannot be lifted
into <code class="highlighter-rouge">P</code>.</p>

<p>However, not all GADTs invalidate <code class="highlighter-rouge">Liskov</code>-lifting:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">class</span> <span class="nc">FAM</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">AM</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AM</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Matching <code class="highlighter-rouge">AM[A]</code> to <code class="highlighter-rouge">FAM[_,_]</code> reveals nothing about <code class="highlighter-rouge">A</code>; its use of
GADTs only introduces a new existential unrelated to <code class="highlighter-rouge">A</code>.  Considering
only <code class="highlighter-rouge">B</code>, as the <code class="highlighter-rouge">A</code> parameter is called in <code class="highlighter-rouge">FAM</code>, its covariance is
sound in <code class="highlighter-rouge">FAM</code>, so <code class="highlighter-rouge">Liskov</code>s can be lifted into <code class="highlighter-rouge">AM</code>.</p>

<h2 id="contravariance">Contravariance</h2>

<p><code class="highlighter-rouge">Liskov</code>s can also be lifted into parametrically sound contravariant
positions.  This looks a bit like:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftCtf</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Contravariant</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">&lt;~&lt;</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="o">&lt;~&lt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>Analysis of parametrically sound contravariance is essentially the
same as that for covariance.  The only difference is that, for <code class="highlighter-rouge">F[A]</code>,
<code class="highlighter-rouge">A</code> can <em>only</em> appear in the primitive contravariant position: the
function parameter type.</p>

<p>With regard to recursion, the “flipping” behavior of
Scala-contravariance applies.  For example, this data type is soundly
contravariant over <code class="highlighter-rouge">A</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">IList</code> is soundly covariant over <code class="highlighter-rouge">A</code>, and <code class="highlighter-rouge">IList[A]</code> appears in
soundly contravariant position, making <code class="highlighter-rouge">A</code> contravariant.  Meanwhile,
<code class="highlighter-rouge">A</code> is soundly <em>co</em>variant in this data type built upon <code class="highlighter-rouge">IOf</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">IOf2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">IOf</span><span class="o">[</span><span class="kt">IOf</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span>
</code></pre></div></div>

<h2 id="some-surprises">Some surprises</h2>

<p>Despite the unsoundness of <code class="highlighter-rouge">Liskov</code>-lifting into <code class="highlighter-rouge">Gimme</code> earlier, it
may seem surprising that Scala allows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">GimmeC</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">GimmeCI</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>Moreover, this isn’t a bug; it’s perfectly sound.  That is because,
while matching <code class="highlighter-rouge">GimmeI</code> causes Scala to infer <code class="highlighter-rouge">A ~ Int</code>, it won’t do
that for <code class="highlighter-rouge">GimmeCI</code>!  Scala can soundly determine that <code class="highlighter-rouge">A ⊇ Int</code> when
it matches <code class="highlighter-rouge">GimmeCI</code>, but I do not think it even goes so far as to do
that as of this writing.  We can’t blame Scala for this difference;
Scala has declared up front that its type system encodes what it
believes, and is <em>our</em> responsibility to follow the cardinal rule of
not violating its assumptions if we lift <code class="highlighter-rouge">Liskov</code> into <code class="highlighter-rouge">Gimme</code>.</p>

<p>As stated earlier, <code class="highlighter-rouge">Liskov</code> cannot be lifted into
<code class="highlighter-rouge">collection.immutable.Set</code>; <code class="highlighter-rouge">TreeSet</code> exists to trivially demonstrate
the problem, but even if <code class="highlighter-rouge">TreeSet</code> was not there, we would not be able
to honestly do it because <code class="highlighter-rouge">c.i.Set</code> is open to new subclasses that
could perform similar violations.  However, despite lacking a
<code class="highlighter-rouge">Functor</code>, <code class="highlighter-rouge">scalaz.ISet</code> <em>does</em> allow <code class="highlighter-rouge">Liskov</code>-lifting.
<a href="https://github.com/scalaz/scalaz/blob/ac8c4684ef89f1b950e71237819d78f573e552ea/core/src/main/scala/scalaz/ISet.scala#L552-L561">Do the ADT analysis yourself, if you like.</a>
Well, so, once you convert your <code class="highlighter-rouge">ISet[Int]</code> to <code class="highlighter-rouge">ISet[Any]</code>, you can’t
do many operations on it, but that’s neither here nor there.</p>

<h2 id="should-this-function-exist">Should this function exist?</h2>

<p>The Scalaz community has settled on a definition of
covariant-functoriality that conforms with the principle of parametric
soundness. The rejection of <code class="highlighter-rouge">Functor</code> instances
<a href="https://github.com/scalaz/scalaz/pull/307">for the <code class="highlighter-rouge">scala.collection.*</code> classes</a>,
which have subclasses with mutable values over their parameters, and
<a href="https://github.com/scalaz/scalaz/pull/276">for <code class="highlighter-rouge">collection.immutable.Set</code></a>,
which has the <code class="highlighter-rouge">TreeSet</code> case stated above and violates parametricity
in the construction of <code class="highlighter-rouge">HashSet</code>s, speak to this. As far as I know,
Scalaz contains no <code class="highlighter-rouge">Functor</code>s that are both Scala-invariant and
violate the rules delineated above.</p>

<p>So how do you feel about the provision of a combinator of the type of
<code class="highlighter-rouge">liftCvf</code> for Scalaz’s <code class="highlighter-rouge">Functor</code>?</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Mar 09, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
