<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Why is ADT pattern matching allowed?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Why is ADT pattern matching allowed?</h2>

  <p>One of the rules of
<a href="https://dl.dropboxusercontent.com/u/7810909/talks/parametricity/4985cb8e6d8d9a24e32d98204526c8e3b9319e33/parametricity.pdf">the Scalazzi Safe Scala Subset</a>
is “no type casing”; in other words, testing the type via
<code class="highlighter-rouge">isInstanceOf</code> or type patterns isn’t allowed.  It’s one of the most
important rules therein for preservation of free theorems.  Common
functional programming practice in Scala <em>seems</em> to violate this rule
in a subtle way.  However, as we will see, that practice carves out a
very specific exception to this rule that, morally, isn’t an exception
at all, carrying convenient advantages and none of the drawbacks.</p>

<h2 id="why-forbid-type-tests">Why forbid type tests?</h2>

<p>With the “no type tests” rule, we forbid writing functions like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">revmaybe</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">allInts</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">forall</span><span class="o">{</span><span class="k">case</span> <span class="k">_:</span><span class="kt">Int</span> <span class="o">=&gt;</span> <span class="kc">true</span>
                          <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span><span class="o">}</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">allInts</span><span class="o">)</span> <span class="n">xs</span><span class="o">.</span><span class="n">reverse</span> <span class="k">else</span> <span class="n">xs</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Which violates the
<a href="http://failex.blogspot.com/2013/06/fake-theorems-for-free.html">free theorem</a>
of <code class="highlighter-rouge">revmaybe</code>’s type <code class="highlighter-rouge">revmaybe(xs map f) = revmaybe(xs) map f</code>, as
follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">i</span><span class="k">:</span><span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">revmaybe</span><span class="o">(</span><span class="n">xs</span> <span class="n">map</span> <span class="n">f</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">revmaybe</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span> <span class="n">map</span> <span class="n">f</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Some</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="adts-are-ok-to-go">ADTs are OK to go</h2>

<p>On the other hand, the Scalazzi rules are totally cool with pattern
matching to separate the parts of
<a href="https://www.haskell.org/haskellwiki/Algebraic_data_type">ADTs</a>.  For
example, this is completely fine.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">headOption</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Even more exotic matches, where we bring type information forward into
runtime, are acceptable, as long as they’re in the context of ADTs.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="k">def</span> <span class="n">eval</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">ex</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddExpr</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="adts-use-type-tests">ADTs use type tests</h2>

<p>Let’s look at the compiled code of the <code class="highlighter-rouge">eval</code> body, specifically, the
<code class="highlighter-rouge">case</code> line.</p>

<div class="language-nasm highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         <span class="mi">2</span><span class="o">:</span> <span class="n">aload_2</span>       
         <span class="mi">3</span><span class="o">:</span> <span class="n">instanceof</span>    <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>         <span class="mi">6</span><span class="o">:</span> <span class="n">ifeq</span>          <span class="mi">39</span>
         <span class="mi">9</span><span class="o">:</span> <span class="n">aload_2</span>       
        <span class="mi">10</span><span class="o">:</span> <span class="n">checkcast</span>     <span class="err">#</span><span class="mi">60</span>                 <span class="c1">// class adts/AddExpr
</span>        <span class="mi">13</span><span class="o">:</span> <span class="n">astore_3</span>      
        <span class="mi">14</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">15</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">63</span>                 <span class="c1">// Method adts/AddExpr.x:()I
</span>        <span class="mi">18</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">4</span>
        <span class="mi">20</span><span class="o">:</span> <span class="n">aload_3</span>       
        <span class="mi">21</span><span class="o">:</span> <span class="n">invokevirtual</span> <span class="err">#</span><span class="mi">66</span>                 <span class="c1">// Method adts/AddExpr.y:()I
</span>        <span class="mi">24</span><span class="o">:</span> <span class="n">istore</span>        <span class="mi">5</span>
        <span class="mi">26</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">4</span>
        <span class="mi">28</span><span class="o">:</span> <span class="n">iload</span>         <span class="mi">5</span>
        <span class="mi">30</span><span class="o">:</span> <span class="n">iadd</span>          
</code></pre></div></div>

<p>So, instead of calling <code class="highlighter-rouge">unapply</code> to presumably check whether <code class="highlighter-rouge">AddExpr</code>
matches, scalac checks and casts its argument to <code class="highlighter-rouge">AddExpr</code>.  Why does
it do that?  Let’s see if we could use <code class="highlighter-rouge">AddExpr.unapply</code> instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">AddExpr</span><span class="o">.</span><span class="n">unapply</span> <span class="k">_</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">adts.AddExpr</span> <span class="o">=&gt;</span> <span class="nc">Option</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function1</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>In other words, the <code class="highlighter-rouge">unapply</code> call can’t tell you whether an <code class="highlighter-rouge">Expr</code> is
an <code class="highlighter-rouge">AddExpr</code>; it can’t be called with arbitrary <code class="highlighter-rouge">Expr</code>.</p>

<p>The only actual check here is inserted by scalac as part of compiling
the pattern match expression, and it is a type test, supposedly
verboten under Scalazzi rules.  <code class="highlighter-rouge">headOption</code>, too, is implemented with
type tests and casts, not <code class="highlighter-rouge">unapply</code> calls.</p>

<p>We’ve exhorted Scala users to avoid type tests, but then turn around
and say that type tests are OK!  What’s going on?</p>

<h2 id="an-equivalent-form">An equivalent form</h2>

<p>In every case where we use pattern matching on an ADT, there’s an
equivalent way we could write the expression without pattern matching,
by adding an encoding of the whole ADT as a method on the class or
trait we use as the base type.  Let’s redefine the <code class="highlighter-rouge">Option</code> type with
such a method to see how this is done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MNothing</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">nothing</span>
<span class="o">}</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Just</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">get</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Maybe</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">nothing</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">just</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">just</span><span class="o">(</span><span class="n">get</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>It’s key to our reasoning that we completely avoid <code class="highlighter-rouge">match</code> in our
implementations; in other words, the <code class="highlighter-rouge">fold</code> is <em>matchless</em>.</p>

<p>With the <code class="highlighter-rouge">fold</code> method, the following two expressions are equivalent,
notwithstanding scalac’s difficulty optimizing the latter, even in the
presence of inlining.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="n">selector</span><span class="k">:</span> <span class="kt">Maybe</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>

<span class="n">selector</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="s">"default case"</span><span class="o">,</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<p>It’s a simple formula: the fold takes as many arguments as there are
cases, always returns the given, sole type parameter, and each
argument is a function that results in that same parameter.  There’s a
free theorem that a <code class="highlighter-rouge">fold</code> implementation on data structures without
recursion, like <code class="highlighter-rouge">Maybe</code>, can only invoke one of these arguments and
return the result directly, just as the pattern match does.</p>

<p>If you prefer the clarity of named cases, just use Scala’s named
arguments.  Here’s that last fold:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selector</span><span class="o">.</span><span class="n">fold</span><span class="o">(</span><span class="n">nothing</span> <span class="k">=</span> <span class="s">"default case"</span><span class="o">,</span>
              <span class="n">just</span> <span class="k">=</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</code></pre></div></div>

<h2 id="gadt-folds">GADT folds</h2>

<p>Encoding <code class="highlighter-rouge">Expr</code> is a little bit more complicated.  For the full power
of the type, we have to turn to <code class="highlighter-rouge">Leibniz</code> to encode the matchless
<code class="highlighter-rouge">fold</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Leibniz</span><span class="o">,</span> <span class="nc">Leibniz</span><span class="o">.{===,</span> <span class="n">refl</span><span class="o">}</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="n">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What does this mean?  The type <code class="highlighter-rouge">Int === T</code>, seen in the <code class="highlighter-rouge">add</code> argument
signature, is inhabited if and only if the type <code class="highlighter-rouge">T</code> <strong>is</strong> the type
<code class="highlighter-rouge">Int</code>.  So an implementation of <code class="highlighter-rouge">fold</code> can only call the <code class="highlighter-rouge">add</code>
function if it can prove that type equality.  There is, of course, one
that can:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Not only does <code class="highlighter-rouge">AddExpr2</code> know that <code class="highlighter-rouge">Expr2</code>’s type parameter is <code class="highlighter-rouge">Int</code>,
we must make the type substitution when implementing methods from
<code class="highlighter-rouge">Expr2</code>!  At that point it is enough to mention <code class="highlighter-rouge">refl</code>, the evidence
that every type is equal to itself, to satisfy <code class="highlighter-rouge">add</code>’s signature.</p>

<p>This may seem a little magical, but it is no less prosaic than
implementing <code class="highlighter-rouge">java.lang.Comparable</code> by making this substitution.  So
you can do this sort of thing every day even in Java.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Comparable</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">T</span> <span class="n">o</span><span class="o">);</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">MyData</span> <span class="kd">implements</span> <span class="n">Comparable</span><span class="o">&lt;</span><span class="n">MyData</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compareTo</span><span class="o">(</span><span class="n">MyData</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>   <span class="c1">// note T is replaced by MyData</span>
    <span class="c1">// ...</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If only Java had higher kinds, you could go the rest of the way and
actually implement
<a href="https://www.haskell.org/haskellwiki/Generalised_algebraic_datatype#Motivating_example">GADTs</a>.</p>

<p>Moving on, let’s see another case for <code class="highlighter-rouge">Expr2</code>, and finally to tie it
all together, <code class="highlighter-rouge">eval2</code> with some extra constant data in for good
measure.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ConcatExpr2</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr2</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span>
  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">add</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">,</span>
              <span class="n">concat</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">,</span> <span class="nc">String</span> <span class="o">===</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span>
    <span class="n">concat</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">refl</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">eval2</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">ex</span><span class="k">:</span> <span class="kt">Expr2</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">ex</span><span class="o">.</span><span class="n">fold</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">intIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">intIsT</span><span class="o">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">),</span>
          <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">strIsT</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">strIsT</span><span class="o">(</span><span class="s">"one"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Using the <code class="highlighter-rouge">Leibniz</code> proof is, unfortunately, more involved than
producing it in the fold implementations.  See my previous posts,
<a href="/blog/2014/07/02/type_equality_to_leibniz.html">“A function from type equality to Leibniz”</a>
and
<a href="/blog/2014/09/20/higher_leibniz.html">“Higher Leibniz”</a>,
for many
details on applying <code class="highlighter-rouge">Leibniz</code> proof to make type transformations.</p>

<p>While the pattern matching <code class="highlighter-rouge">eval</code> didn’t have to explicitly apply type
equality evidence – it <em>just knew</em> that <code class="highlighter-rouge">Int</code> was <code class="highlighter-rouge">T</code> when the
<code class="highlighter-rouge">IntExpr</code> pattern matched – Scala has holes in its implementation,
discussed in the aforementioned posts on <code class="highlighter-rouge">Leibniz</code>, that sometimes
make the above implementation strategy an attractive choice even
though pattern matching is available.</p>

<h2 id="we-could-but-thats-good-enough-so-we-wont">We could, but that’s good enough, so we won’t</h2>

<p>You might have noticed that adding another case to <code class="highlighter-rouge">Expr</code> caused us
not only to implement an extra <code class="highlighter-rouge">fold</code>, but to add another argument to
the base <code class="highlighter-rouge">fold</code> to represent the new case, and then go through every
implementation to add that argument.  This isn’t so bad for just two
cases, but indeed has quadratic growth, to the point that adding a new
case to a large datatype is a majorly annoying project all by itself.</p>

<p>There is an interesting property of <code class="highlighter-rouge">fold</code>, though: the strategy isn’t
available for our first function, <code class="highlighter-rouge">revmaybe</code>, to discriminate
arguments of arbitrary type!  To do that, we would have to add a
signature like this to <code class="highlighter-rouge">Any</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">any</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
<span class="c1">// and, in the body of class Int
</span><span class="k">override</span> <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">int</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">,</span> <span class="n">any</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=&gt;</span> <span class="n">Z</span><span class="o">)</span><span class="k">:</span> <span class="kt">Z</span> <span class="o">=</span> <span class="n">int</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
</code></pre></div></div>

<p>Obviously, you cannot do this.</p>

<p>You can only add <code class="highlighter-rouge">fold</code> methods to types you know; I can only call
<code class="highlighter-rouge">fold</code> in <code class="highlighter-rouge">expr2</code> by virtue of the fact that I know that the argument
has type <code class="highlighter-rouge">Expr2[T]</code> for some <code class="highlighter-rouge">T</code>.  If the argument was just <code class="highlighter-rouge">T</code>, I
wouldn’t have enough static type information to call <code class="highlighter-rouge">fold</code>.  So the
use of <code class="highlighter-rouge">fold</code>s doesn’t break parametricity.  Equivalently, <strong>a pattern
match that could be implemented using a matchless fold also does not
break parametricity</strong>.</p>

<p>As we have seen, it is unfortunately inconvenient to actually go
through the bother of writing <code class="highlighter-rouge">fold</code> methods, when pattern matching is
there.  But it is enough to reason that <em>we could</em> write a matchless
<code class="highlighter-rouge">fold</code> and replace the pattern matching with it, to prove that the
pattern matching is safe, no matter how many underlying type tests
scalac might use to implement it.</p>

<p>A simple test follows: <strong>if you could write a matchless fold, and use
that instead, the pattern match is type-safe</strong>.</p>

<h2 id="a-selector-subtlety">A selector subtlety</h2>

<p>Here’s a pattern match that violates parametricity.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">MNothing</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="s">"default case"</span>
  <span class="k">case</span> <span class="nc">Just</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">justcase</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wait, but didn’t we rewrite that using a <code class="highlighter-rouge">fold</code> earlier?  Not quite.
Oh, I didn’t mention?  The type of <code class="highlighter-rouge">selector</code> is <code class="highlighter-rouge">T</code>, because we’re in
a function like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">notIdentity</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">selector</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
  <span class="c1">// match expression above goes here
</span></code></pre></div></div>

<p>Scala will permit this pattern match to go forward.  It doesn’t
require us to prove that the selector is of the ADT root type we
happened to define; that’s an arbitrary point as far as Scala’s
subtyping system is concerned.  All that is required is that the
static type of <code class="highlighter-rouge">selector</code> be a supertype of each of <code class="highlighter-rouge">MNothing[_]</code> and
<code class="highlighter-rouge">Just[_]</code>, which <code class="highlighter-rouge">T</code> is, not being known to be more refined than
<code class="highlighter-rouge">Any</code>.</p>

<p>The test works here, though!  What is ambiguous to scalac is a bright
line in our reasoning. We can’t define a matchless <code class="highlighter-rouge">fold</code> that can be
invoked on this <code class="highlighter-rouge">selector</code>, so we reach the correct conclusion, that
the match violates parametricity.</p>

<h2 id="the-rule-revisited">The rule revisited</h2>

<p>So we’ve carved out a clear “exception” to the “no type tests”
Scalazzi rule, and seen that it isn’t an exception at all.  There’s a
straightforward test you can apply to your pattern matches,</p>

<p><strong>If and only if I could, hypothetically, write a matchless fold, or
use an existing one, and rewrite this in its terms, this pattern
match is safe.</strong></p>

<p>but beware the subtle case where the match’s selector has a wider type
than you anticipated.</p>

<p>Finally, this is a rule specifically about expressions that don’t
violate our ability to reason about code.  This doesn’t hold for
arbitrary type-unsafe rewrites: that you could write a program safely
means you <em>should</em> write it safely.  Unlike arbitrary rewrites into
nonfunctional code, the pattern match uses no
non-referentially-transparent and no genuinely non-parametric
expressions.</p>

<p><em>This article was tested with Scala 2.11.4 and Scalaz 7.1.0.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Nov 10, 2014</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
