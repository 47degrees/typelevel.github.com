<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Choosing variance for a phantom type</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Choosing variance for a phantom type</h2>

  <p>When you use a type parameter to abstract over actual data in your
ADT, there is typically only one
<a href="/blog/2016/02/04/variance-and-functors.html">variance</a> that makes
sense, if you choose to incorporate subtyping into your designs at
all. This is
<a href="/blog/2014/03/09/liskov_lifting.html#parametrically-sound-covariance">the natural, ‚Äúparametrically sound‚Äù variance</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">P</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>

<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Running</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">](</span>
  <span class="n">run</span><span class="k">:</span> <span class="o">(</span><span class="kt">I</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">V</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">I</span>, <span class="kt">T</span>, <span class="kt">V</span><span class="o">]</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Inject</span><span class="o">[</span><span class="kt">I</span><span class="o">](</span>
  <span class="n">config</span><span class="k">:</span> <span class="kt">I</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">I</span>, <span class="kt">Any</span>, <span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>There are only four interesting possibilities, each of which is
illustrated above.</p>

<ol>
  <li><code class="highlighter-rouge">V</code> occurs in only covariant positions, so can be marked covariant.</li>
  <li><code class="highlighter-rouge">T</code> occurs in only contravariant positions, so can be marked
contravariant.</li>
  <li><code class="highlighter-rouge">I</code> occurs in a pattern that meets neither of standards 1 and 2, so
may only be marked invariant, while still making sense.</li>
  <li><code class="highlighter-rouge">P</code> meets <em>both</em> standards 1 and 2, so‚Ä¶now what?</li>
</ol>

<p>The fourth case is interesting to me, firstly, because the design of
variance in Scala has not accounted for it; it is ‚Äúphantom‚Äù,
<a href="/blog/2016/02/04/variance-and-functors.html#one-more-thing">the missing fourth variance</a>.
I like to write it as I did in
<a href="https://failex.blogspot.com/2016/09/the-missing-diamond-of-scala-variance.html">‚ÄúThe missing diamond of Scala variance‚Äù</a>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyModel</span><span class="o">[</span><span class="kt">üëªP</span>, <span class="kt">I</span>, <span class="kt">-T</span>, <span class="kt">+V</span><span class="o">]</span>
</code></pre></div></div>

<p>Second, and more practically, it illuminates the role of variance in
pattern matching in a way that can be difficult to see with that
confusing data in the way.</p>

<h2 id="it-can-be-covariant">It can be covariant</h2>

<p>The rule for a type parameter being parametrically¬†covariant says we
have to look at all the positions in the data where the type parameter
occurs; if every one of them is a covariant position, then the type
parameter may be marked covariant. Consider a simplified version of
<code class="highlighter-rouge">MyModel</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">AStr</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">AnInt</span> <span class="k">extends</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The type parameter <code class="highlighter-rouge">P</code> appears in no positions, so it vacuously
satisfies the requirement ‚Äúevery occurrence is in covariant position‚Äù.</p>

<p>So let us mark <code class="highlighter-rouge">P</code> covariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gimme</span><span class="o">[</span><span class="kt">+P</span><span class="o">]</span>
<span class="c1">// otherwise the same
</span></code></pre></div></div>

<h2 id="it-can-be-contravariant">It can be contravariant</h2>

<p>The rule for contravariance is also based on the occurrences of the
type parameter: if every occurrence is in contravariant position, then
the type parameter may be contravariant.</p>

<p>This rule seems to be contradict the rule for covariance, except that
all ‚Äúevery‚Äù statements are always true when the set under
consideration is empty.</p>

<ol>
  <li>Set <strong>S</strong> is empty.</li>
  <li>Every element of set <strong>S</strong> is a dog.</li>
  <li>No element of set <strong>S</strong> is a dog.</li>
</ol>

<p>2 and 3 can be true at the same time, but only if¬†1¬†is true, too. So
let us mark <code class="highlighter-rouge">P</code> contravariant, in a renamed ADT.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">-P</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">UnStr</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">UnInt</span> <span class="k">extends</span> <span class="nc">Gotme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="the-usual-relationships">The usual relationships</h2>

<p>Since you can choose any variance for phantom parameters, the
important question is: what kind of type relationships should
exist¬†within my ADT?</p>

<p>At first, this seems to be merely a question of how values of <code class="highlighter-rouge">Gimme</code>
and <code class="highlighter-rouge">Gotme</code> types ought to widen.</p>

<ol>
  <li>Every <code class="highlighter-rouge">Gimme[Cat]</code> is a <code class="highlighter-rouge">Gimme[Animal]</code>, and</li>
  <li>every <code class="highlighter-rouge">Gotme[Animal]</code> is a <code class="highlighter-rouge">Gotme[Cat]</code>. Moreover,</li>
  <li>every <code class="highlighter-rouge">Gimme[Nothing]</code> is a <code class="highlighter-rouge">Gimme[T]</code> no matter what <code class="highlighter-rouge">T</code> is, and</li>
  <li>every <code class="highlighter-rouge">Gotme[Any]</code> is a <code class="highlighter-rouge">Gotme[T]</code> no matter what <code class="highlighter-rouge">T</code> is.</li>
</ol>

<p>Obviously, if neither of these behaviors‚Äîthe 1/3 nor the 2/4‚Äîis
desirable, you shouldn‚Äôt use variance. In my experience, this is the
case for most phantom¬†types. If one is desirable, then it may be fine,
but there‚Äôs more to consider.</p>

<h2 id="extracting-the-covariant">Extracting the covariant</h2>

<p>Pattern-matching on the covariant <code class="highlighter-rouge">Gimme</code> reveals fully safe type
information. Unlike <code class="highlighter-rouge">ClassTag</code>¬†and¬†<code class="highlighter-rouge">TypeTag</code>, which are egregiously
broken for this use case, this method of carrying type information
forward into runtime is closed and
<a href="https://imgur.com/a04WoHn">Scalazzi</a>-safe.</p>

<p>What type information is revealed?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gimme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">P</span><span class="o">,</span> <span class="kt">P</span><span class="o">)</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="c1">// implicitly[P &lt;:&lt; String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">String</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">P</span><span class="o">]</span>
    <span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="s">"there"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">AnInt</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="mi">84</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If we left <code class="highlighter-rouge">Gimme</code>‚Äôs type parameter invariant, all three tests above
would succeed. In the case of this code, on the other hand,</p>

<ol>
  <li><code class="highlighter-rouge">AStr.type</code> (the type of <code class="highlighter-rouge">AStr</code>) widens to <code class="highlighter-rouge">Gimme[String]</code>,</li>
  <li><code class="highlighter-rouge">Gimme[String]</code> can widen to <code class="highlighter-rouge">Gimme[P]</code> as long as <code class="highlighter-rouge">P</code> is a
<em>supertype</em> of <code class="highlighter-rouge">String</code>.</li>
</ol>

<p>Because we‚Äôre reversing this process, we have to assume that #2 could
have happened.</p>

<p>The expression <code class="highlighter-rouge">("hi", "there")</code> still compiles because <code class="highlighter-rouge">P</code>, while
otherwise mysterious, <em>surely is</em> a supertype of <code class="highlighter-rouge">String</code>. So the two
<code class="highlighter-rouge">String</code>s can widen to <code class="highlighter-rouge">P</code>.</p>

<p>Things do not work out so well for all such functions.</p>

<h2 id="extracting-the-contravariant">Extracting the contravariant</h2>

<p>Matching on the contravariant <code class="highlighter-rouge">Gotme</code> likewise reveals fully safe
type¬†information.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">mklength</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">g</span><span class="k">:</span> <span class="kt">Gotme</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">P</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="n">g</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnStr</span> <span class="k">=&gt;</span>
    <span class="c1">// implicitly[P =:= String]   will fail
</span>    <span class="n">implicitly</span><span class="o">[</span><span class="kt">P</span> <span class="k">&lt;:</span><span class="kt">&lt;</span> <span class="kt">String</span><span class="o">]</span>
    <span class="c1">// implicitly[String &lt;:&lt; P]   will fail
</span>    <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="nc">UnInt</span> <span class="k">=&gt;</span> <span class="n">identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now <code class="highlighter-rouge">P &lt;:&lt; String</code>, which failed for the covariant form but succeeds
for the contravariant. On the other hand, we lost <code class="highlighter-rouge">String &lt;:&lt; P</code>,
which only works for the covariant form. That‚Äôs because</p>

<ol>
  <li><code class="highlighter-rouge">UnStr.type</code> widens to <code class="highlighter-rouge">Gotme[String]</code>;</li>
  <li><code class="highlighter-rouge">Gotme[String]</code> can widen to <code class="highlighter-rouge">Gotme[P]</code> as long as <code class="highlighter-rouge">P</code> is a
<em>subtype</em> of <code class="highlighter-rouge">String</code>.</li>
</ol>

<p>In the covariant form, we knew that every <code class="highlighter-rouge">String</code> was a <code class="highlighter-rouge">P</code>. In this
code, we know instead that every <code class="highlighter-rouge">P</code> is a <code class="highlighter-rouge">String</code>. Functions that can
handle any <code class="highlighter-rouge">String</code> are thus able to handle any <code class="highlighter-rouge">P</code>, logically, so the
type¬†<code class="highlighter-rouge">String¬†=&gt;¬†Int</code> widens to <code class="highlighter-rouge">P¬†=&gt;¬†Int</code>.</p>

<h2 id="extracting-the-invariant">Extracting the invariant</h2>

<p><code class="highlighter-rouge">gimme</code> would not work with the contravariant¬†GADT; likewise,
<code class="highlighter-rouge">mklength</code> would not work with the covariant¬†GADT.</p>

<p>An invariant GADT supports both, as well as some supported by
neither. For example, we could produce a <code class="highlighter-rouge">(P,¬†P)¬†=&gt;¬†P</code> from a pattern
match. We can do this because the equivalent of <code class="highlighter-rouge">AStr</code> for invariant
<code class="highlighter-rouge">Gimme</code> tells us <code class="highlighter-rouge">P¬†=¬†String</code>, so all three <code class="highlighter-rouge">implicitly</code> checks
succeed.</p>

<p>From the behavior of pattern matching over these three sorts of GADTs,
I take away two lessons about variance in Scala.</p>

<ol>
  <li>It is impractical to infer variance in Scala, because you cannot
mechanically infer what sort of GADT pattern matching functions
ought to be possible to write.</li>
  <li>The type flexibility of a generic type with variance comes at the
cost of decreased flexibility in pattern-matching
code. <a href="https://en.wikipedia.org/wiki/TANSTAAFL">There ain‚Äôt no such thing as a free lunch.</a></li>
</ol>

<h2 id="a-gadt-skolem">A GADT skolem</h2>

<p>The ‚Äúreverse widening‚Äù of pattern matching lifts¬†the¬†veil on one of
the more confusing references in type errors, a ‚ÄúGADT¬†skolem‚Äù.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">uncons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">::</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">c</span><span class="o">@(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">c</span><span class="o">)</span>
  <span class="c1">//                      ‚Üë
</span>  <span class="c1">// [error] type mismatch;
</span>  <span class="c1">//  found   : ::[?A1] where type ?A1 &lt;: A
</span>  <span class="c1">//            (this is a GADT skolem)
</span>  <span class="c1">//  required: ::[A]
</span>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="nc">None</span>
<span class="o">}</span>
</code></pre></div></div>

<p>These ‚ÄúGADT skolems‚Äù appear all the time in sensible, compiling
code. Take a <code class="highlighter-rouge">List</code> with some variance carelessly tossed in.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">+A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">MyCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">MyNil</span> <span class="k">extends</span> <span class="nc">MyList</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span>
</code></pre></div></div>

<p>Constructing <code class="highlighter-rouge">MyCons[String]</code>, here‚Äôs what can happen.</p>

<ol>
  <li><code class="highlighter-rouge">MyCons[String]</code> widens to <code class="highlighter-rouge">MyList[String]</code>.</li>
  <li><code class="highlighter-rouge">MyList[String]</code> can widen to <code class="highlighter-rouge">MyList[U]</code> for any supertype <code class="highlighter-rouge">U</code> of
<code class="highlighter-rouge">String</code>.</li>
</ol>

<p>So in this code, we cannot reverse <code class="highlighter-rouge">MyList[A]</code> down to
<code class="highlighter-rouge">MyCons[A]</code>. But we <em>can</em> get <code class="highlighter-rouge">MyList[L]</code>, where <code class="highlighter-rouge">L</code> is an otherwise
mysterious subtype of <code class="highlighter-rouge">A</code>. <code class="highlighter-rouge">L</code> is the GADT¬†skolem, similar to <code class="highlighter-rouge">?A1</code> in
the above compiler error. The difference is that this code compiles.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">drop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">MyNil</span> <span class="k">=&gt;</span> <span class="nc">MyNil</span>
    <span class="k">case</span> <span class="nc">MyCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: MyList[L]  (L is a GADT skolem)
</span>    <span class="c1">// L &lt;: A, therefore
</span>    <span class="c1">// MyList[L] &lt;: MyList[A] by covariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<h2 id="mylists-type-parameter-is-a-phantom"><code class="highlighter-rouge">MyList</code>‚Äôs type parameter is a phantom</h2>

<p>We saw earlier that variance has a strong influence on the usability
of pattern matching. <code class="highlighter-rouge">MyList</code> has something important¬†in common with
<code class="highlighter-rouge">Gimme</code>: the class definition does not use <code class="highlighter-rouge">A</code>, it only <em>defines</em>
it. So the scalac-enforced variance rules do not apply, and we can
make¬†<code class="highlighter-rouge">MyList</code>¬†contravariant instead.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">-A</span><span class="o">]</span>
<span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">BadCons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BadNil</span> <span class="k">extends</span> <span class="nc">BadList</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
</code></pre></div></div>

<p>Curiously, <code class="highlighter-rouge">drop1</code> still works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">baddrop1</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">BadNil</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">tl</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">tl</span>
    <span class="c1">// tl: BadList[U]  (U is a GADT skolem)
</span>    <span class="c1">// A &lt;: U, therefore
</span>    <span class="c1">// BadList[U] &lt;: BadList[A] by contravariance
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>Other obvious functions will not work for non-obvious reasons.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">badHeadOption</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">BadList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BadNil</span> <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="k">case</span> <span class="nc">BadCons</span><span class="o">(</span><span class="n">hd</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Some</span><span class="o">(</span><span class="n">hd</span><span class="o">)</span>
    <span class="c1">// [error] type mismatch;   ‚Üë
</span>    <span class="c1">//  found   : hd.type (with underlying type Any)
</span>    <span class="c1">//  required: A
</span>  <span class="o">}</span>
</code></pre></div></div>

<p>This fails because the skolem from a contravariant parameter is a
supertype instead of subtype. So</p>

<ol>
  <li><code class="highlighter-rouge">hd: U</code> (<code class="highlighter-rouge">U</code> is a GADT skolem),</li>
  <li><code class="highlighter-rouge">A &lt;: U</code>,</li>
  <li>we‚Äôre stuck; there is no <code class="highlighter-rouge">A</code> value.</li>
</ol>

<p>This is not to imply something as silly as ‚Äúcovariance¬†good,
contravariance¬†bad‚Äù; you can just as well get these errors by marking
a parameter covariant that can only meaningfully be marked
contravariant. If anything, contravariance is more important than
covariance. The problem you must face is that the compiler is less
helpful in determining what ‚Äúmeaningful‚Äù marking, if any, should be
applied.</p>

<p><code class="highlighter-rouge">MyModel</code>, from the beginning of this article, demonstrates three
situations in which each supported variance is natural. You may use it
as a guide, but its sanity is not compiler-checked. Your variances‚Äô
sanity, or lack thereof, only becomes apparent when implementing
practical functions over a datatype.</p>

<h2 id="extracting-the-phantom">Extracting the phantom</h2>

<p>Suppose the phantom variance was defined, and we revisit the
<code class="highlighter-rouge">String</code>-and-<code class="highlighter-rouge">Int</code> GADT one more time.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">üëªP</span><span class="o">]</span>
<span class="nc">case</span> <span class="k">object</span> <span class="nc">BooStr</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">BooInt</span> <span class="k">extends</span> <span class="nc">BooGimme</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</code></pre></div></div>

<p>The trouble with letting the compiler¬†infer¬†covariance or
contravariance is that, on the face of it, either is as good as the
other. With phantom, we choose both.</p>

<p>But this variance makes the GADT utterly useless. Consider how
<code class="highlighter-rouge">BooStr</code> becomes <code class="highlighter-rouge">BooGimme[P]</code>.</p>

<ol>
  <li><code class="highlighter-rouge">BooStr</code> widens to <code class="highlighter-rouge">BooGimme[String]</code>.</li>
  <li><code class="highlighter-rouge">BooGimme[String]</code> can widen to <code class="highlighter-rouge">BooGimme[P]</code> where <code class="highlighter-rouge">P</code> is‚Ä¶oops,
there are no conditions this time! <code class="highlighter-rouge">P</code> can be anything at all and
the widen will still work.</li>
</ol>

<p>The match tells us nothing about the type¬†parameter; all three of the
type relationship checks via <code class="highlighter-rouge">implicitly</code> from the examples above
fail. We maximize the flexibility of the type parameter at the cost of
making GADT pattern matching impossible.</p>

<p>Likewise, if you mark <code class="highlighter-rouge">MyList[A]</code>‚Äôs type parameter phantom, there are
no bounds on the GADT¬†skolem, so there‚Äôs little you can do with the
elements of the list.</p>

<h2 id="the-case-for-choosing-no-variance">The case for choosing no variance</h2>

<p>My <code class="highlighter-rouge">scalac</code> error message pet peeve is the one suggesting that you
should add a variance annotation. This message treats the addition of
variance like a mechanical change: ‚Äúif it compiles, it works‚Äù. On the
contrary, we have seen that</p>

<ol>
  <li>The flexibility of variance costs flexibility elsewhere;</li>
  <li>the compiler cannot predict how this might harm your APIs‚Äô
practicality;</li>
  <li>the semantics of pattern matching are more complex in the face of
variance.</li>
</ol>

<p>Even if variance is applicable to your datatype, these costs, and the
cost of the additional complexity burden, should give you pause. Yet,
I stand by the claim I made in ‚ÄúThe missing¬†diamond
of¬†Scala¬†variance‚Äù: subtyping is incomplete¬†without variance, so if
variance is too complicated, so is subtyping.</p>

<p>I don‚Äôt think subtyping‚Äîand its necessary component, variance‚Äîare too
complex for the working programmer to understand. Indeed, it can be a
fascinating exercise, with plenty of practical implications.</p>

<p>But, to me, the consequence of working out such exercises is that
neither variance nor subtyping ought to be used in the design of
practical programs, especially when higher-kinded type parameters and
members are available, offering far more flexibility at a better
price. There is no need to struggle in the face of all-too-often
missing features.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Sep 19, 2016</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
