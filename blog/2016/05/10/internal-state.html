<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Making internal state functional</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Making internal state functional</h2>

  <p><em>This is the ninth of a series of articles on “Type Parameters and
Type Members”.</em></p>

<p>Scala’s
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/generic/CanBuildFrom.html"><code class="highlighter-rouge">CanBuildFrom</code> API</a>
is relatively well-founded and flexible;
<a href="https://bitbucket.org/S11001001/record-map#markdown-header-using-gadts-to-find-fast-paths-safely">in combination with GADTs, it can provide that flexibility in a fully type-safe way</a>,
if users choose not to circumvent it with typecasting.</p>

<p>However, it is designed in a purely mutable way; you cannot write a
useful <code class="highlighter-rouge">CanBuildFrom</code> that does not rely on mutation, and you cannot
use the API externally in a functional way.</p>

<p>Let’s design an alternative to <code class="highlighter-rouge">CanBuildFrom</code> that makes sense in a
purely functional context, allowing both implementers and users to
avoid unsightly mutation.</p>

<p>Spoiler warning! Our first pass will have one glaring inelegance. We
will use concepts from previous articles in <em>Type Parameters and Type
Members</em> to “invert the abstraction”, which will greatly simplify the
design. Once you’re comfortable with the “inversion”, you can skip the
intermediate step and use this technique directly in your own designs.</p>

<h2 id="disallowing-functional-approaches">Disallowing functional approaches</h2>

<p>The pattern of use of <code class="highlighter-rouge">CanBuildFrom</code> is</p>

<ol>
  <li><code class="highlighter-rouge">apply</code> the CBF to produce a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/mutable/Builder.html"><code class="highlighter-rouge">Builder</code></a>.</li>
  <li>Call <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> methods to “fill up” the <code class="highlighter-rouge">Builder</code>.</li>
  <li>Call <code class="highlighter-rouge">result</code> to “finalize” or “commit” to the final structure.</li>
</ol>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="n">implicitly</span><span class="o">[</span><span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Nothing</span>, <span class="kt">Int</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]]</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">cbf</span><span class="o">()</span>
<span class="n">b</span> <span class="o">+=</span> <span class="mi">3</span>
<span class="n">b</span> <span class="o">++=</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">result</span><span class="o">()</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>Let’s set aside that this is only suited to eager collections, not
lazy ones like
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Stream.html"><code class="highlighter-rouge">Stream</code></a>. You
can tell the problem by types: <code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> have the return type
<code class="highlighter-rouge">this.type</code>. Effectively, this means that if their implementations are
purely functional, all they can do is return <code class="highlighter-rouge">this</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">def</span> <span class="o">++=(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span> <span class="k">=</span> <span class="k">this</span>
</code></pre></div></div>

<p>Aside from the informal contract of <code class="highlighter-rouge">Builder</code>, which suggests that
calls to these methods perform a side effect, the types enforce that
they <em>must</em> perform any useful work by means of side effects.</p>

<p>Returning <code class="highlighter-rouge">this.type</code> permits these methods to be called in a
superficially functional style:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span><span class="o">.+=(</span><span class="mi">3</span><span class="o">)</span>
 <span class="o">.++=(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>
 <span class="o">.</span><span class="n">result</span><span class="o">()</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
</code></pre></div></div>

<p>This retouch is only skin-deep, and can’t repair the defect making
<code class="highlighter-rouge">CanBuildFrom</code> unsuitable for functional programs, but it implies that
a functional alternative lurks nearby. Let’s go looking for it.</p>

<h2 id="step-1-explicit-builder-state">Step 1: explicit <code class="highlighter-rouge">Builder</code> state</h2>

<p>First, we need to take the essential mutation out of <code class="highlighter-rouge">Builder</code>. That
means it needs to provide an initial state, and the other methods must
use it as a parameter and return value.</p>

<ol>
  <li>We’ll add a new method to return the initial state.</li>
  <li><code class="highlighter-rouge">+=</code> and <code class="highlighter-rouge">++=</code> will take that state as an argument, returning the
new state instead of <code class="highlighter-rouge">this.type</code>.</li>
  <li><code class="highlighter-rouge">result</code> will take the final state as an argument, still producing
the result collection.</li>
</ol>

<p>While the intermediate state <em>might</em> be the same as the final state,
we don’t want to require that. So <code class="highlighter-rouge">Builder</code> also gains a type
parameter to represent the type of state, <code class="highlighter-rouge">S</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="cm">/** Produce the initial state. */</span>
  <span class="k">def</span> <span class="n">init</span><span class="k">:</span> <span class="kt">S</span>

  <span class="c1">// note everywhere 'S' was added
</span>  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">Elem</span><span class="o">])</span><span class="k">:</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">To</span>
<span class="o">}</span>
</code></pre></div></div>

<h2 id="a-sample-funbuilder">A sample <code class="highlighter-rouge">FunBuilder</code></h2>

<p>We can incrementally build a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/Vector.html"><code class="highlighter-rouge">Vector</code></a>,
but it may not be the most efficient way. Instead, let’s try to
accumulate a
<a href="http://www.scala-lang.org/api/2.11.8/scala/collection/immutable/List.html"><code class="highlighter-rouge">List</code></a>,
then construct the <code class="highlighter-rouge">Vector</code> once we’re done.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">toVector</span><span class="o">.</span><span class="n">reverse</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">vbl</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">vbl</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="n">vbl</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>(There’s a problem with <code class="highlighter-rouge">CanBuildFrom</code> now, but we’ll hold off fixing
it.)</p>

<h2 id="a-slightly-different-builder">A slightly different Builder</h2>

<p>Maybe it would be better to optimize for the <code class="highlighter-rouge">++=</code> “bulk add” method,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]],</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">vbll</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">vbll</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbll</span><span class="o">.++=(</span><span class="n">vbll</span><span class="o">.+=(</span><span class="n">vbll</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="hide-your-state">Hide your state</h2>

<p>The type of these builders are different, even though their usage is
the same. This design also exposes what was originally <em>internal</em>
state as part of the API. Luckily, <code class="highlighter-rouge">CanBuildFrom</code> makes a point of
this when we try to integrate <code class="highlighter-rouge">FunBuilder</code> into our own CBF version;
there’s nowhere to put the <code class="highlighter-rouge">S</code> type parameter.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
<span class="o">}</span>

<span class="err">…</span><span class="o">/</span><span class="nc">FCBF</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">42</span><span class="kt">:</span> <span class="kt">not</span> <span class="kt">found:</span> <span class="k">type</span> <span class="kt">S</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
                          <span class="o">^</span>
</code></pre></div></div>

<p>We can hide the state by forcing the caller to deal with the builder
in a state-generic context. One way to do this is with a generic
continuation.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">-To</span>, <span class="kt">+Z</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">builder</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
<span class="o">}</span>

<span class="c1">// in FunCanBuildFrom...
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span>, <span class="kt">Z</span><span class="o">])</span><span class="k">:</span> <span class="kt">Z</span>
</code></pre></div></div>

<p>Now we can implement a <code class="highlighter-rouge">FunCanBuildFrom</code> that can use either of the
<code class="highlighter-rouge">FunBuilder</code>s we’ve defined.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">Z</span><span class="o">](</span><span class="n">cont</span><span class="k">:</span> <span class="kt">BuilderCont</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Z</span><span class="o">])</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="n">cont</span> <span class="n">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderListList</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="n">cont</span> <span class="n">continue</span> <span class="o">(</span><span class="k">new</span> <span class="nc">VectorBuilderList</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Take a look at the type flow. The caller of <code class="highlighter-rouge">apply</code> is the one who
decides the <code class="highlighter-rouge">Z</code> type. But the <code class="highlighter-rouge">apply</code> implementation chooses the <code class="highlighter-rouge">S</code>
to pass to <code class="highlighter-rouge">continue</code>, which cannot know any more about what that
state type is. (It can even choose different types based on runtime
decisions.) Information hiding is restored.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="o">{</span><span class="k">new</span> <span class="nc">BuilderCont</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">continue</span><span class="o">[</span><span class="kt">S</span><span class="o">](</span><span class="n">vbl</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">Int</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
    <span class="n">vbl</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">vbl</span><span class="o">.++=(</span><span class="n">vbl</span><span class="o">.+=(</span><span class="n">vbl</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)))</span>
<span class="o">}}</span>

<span class="n">res1</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</code></pre></div></div>

<p>Now the code using the <code class="highlighter-rouge">FunBuilder</code> can’t fiddle with the
<code class="highlighter-rouge">FunBuilder</code>’s state values; it can only rewind to previously seen
states, a norm to be expected in functional programming with
persistent state values.</p>

<h2 id="existential-types-are-abstraction-inversion">Existential types are abstraction inversion</h2>

<p>This is rather a lot of inconvenient ceremony, though. Instead of
passing a continuation that receives the <code class="highlighter-rouge">S</code> type as an argument along
with the <code class="highlighter-rouge">FunBuilder</code>, let’s just have <code class="highlighter-rouge">apply</code> return the type along
with the <code class="highlighter-rouge">FunBuilder</code>. We have a tool for returning a pair of type and
value using that type.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="k">_</span>, <span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>
</code></pre></div></div>

<p>Remember that existential types are pairs.</p>

<p>Having collapsed callee-of-callee back to caller perspective, let’s
apply the rule of thumb from
<a href="/blog/2015/07/13/type-members-parameters.html">the first post in this series</a>.</p>

<blockquote>
  <p>A type parameter is usually more convenient and harder to screw up, but if you intend to use it existentially in most cases, changing it to a member is probably better.</p>
</blockquote>

<p>The usual case will be from the perspective of a CBF user, so the
usual use of the <code class="highlighter-rouge">S</code> parameter is existential. So let’s turn it into
the equivalent type member.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// rewrite the heading of FunBuilder as
</span><span class="k">trait</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span>
  
<span class="c1">// and FunCanBuildFrom#apply as
</span>  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">FunBuilder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>

<span class="c1">// and the parameter S moves to a member
// for all implementations so far;
// fix until compile or see appendix
</span></code></pre></div></div>

<p>And we can see the information stays hidden.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">cbf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="kc">true</span><span class="o">)</span>
<span class="n">cbf</span><span class="k">:</span> <span class="kt">fcbf.VectorCBF</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">fcbf</span><span class="o">.</span><span class="nc">VectorCBF</span><span class="k">@</span><span class="mi">4363</span><span class="n">e2ba</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">vb</span> <span class="k">=</span> <span class="n">cbf</span><span class="o">()</span>
<span class="n">vb</span><span class="k">:</span> <span class="kt">fcbf.FunBuilder</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="n">fcbf</span><span class="o">.</span><span class="nc">VectorBuilderListList</span><span class="k">@</span><span class="mi">527</span><span class="n">c222e</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">with1</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.+=(</span><span class="n">vb</span><span class="o">.</span><span class="n">init</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">with1</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">with2</span> <span class="k">=</span> <span class="n">vb</span><span class="o">.++=(</span><span class="n">with1</span><span class="o">,</span> <span class="nc">Seq</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>
<span class="n">with2</span><span class="k">:</span> <span class="kt">vb.S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vb</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">with2</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>As in
<a href="/blog/2015/07/30/values-never-change-types.html#naming-the-existential">“Values never change types”</a>,
<code class="highlighter-rouge">vb.S</code> is abstract, existential, irreducible.</p>

<h2 id="last-minute-adjustments">Last minute adjustments</h2>

<p><code class="highlighter-rouge">Builder</code> had to be separate from <code class="highlighter-rouge">CanBuildFrom</code> because the latter
had to be stateless, with <code class="highlighter-rouge">Builder</code> needing to be stateful. Now that
both are stateless, the <code class="highlighter-rouge">FunBuilder</code> API can probably be collapsed
into <code class="highlighter-rouge">FunCanBuildFrom</code>.</p>

<p>This leaves the question, what about the mutable-state <code class="highlighter-rouge">Builder</code>s?
They can mutate the <code class="highlighter-rouge">S</code>, returning the input state from <code class="highlighter-rouge">+=</code> and
<code class="highlighter-rouge">++=</code>. You can’t use <code class="highlighter-rouge">S</code> values to rewind such a <code class="highlighter-rouge">FunBuilder</code>, but you
couldn’t before, anyway.</p>

<p>In the next part, “Avoiding refinement with dependent method types”,
we’ll look at the meaning of Scala’s “dependent method types” feature,
using it to replace some more type parameters with type members in
non-existential use cases.</p>

<p><em>This article was tested with Scala 2.11.8.</em></p>

<h2 id="appendix-final-funbuilder-examples">Appendix: final <code class="highlighter-rouge">FunBuilder</code> examples</h2>

<p>The rewrite from <code class="highlighter-rouge">S</code> type parameter to member in the <code class="highlighter-rouge">FunBuilder</code>
implementations is a boring, mechanical transform, but I’ve included
it here for easy reference.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">VectorBuilderList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span> <span class="n">elem</span> <span class="o">::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toList</span> <span class="n">reverse_:::</span> <span class="n">s</span>
  
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">toVector</span><span class="o">.</span><span class="n">reverse</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorBuilderListList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
    <span class="nc">extends</span> <span class="nc">FunBuilder</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">S</span> <span class="o">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Traversable</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">init</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
  
  <span class="k">def</span> <span class="o">+=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Traversable</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="o">++=(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">elems</span><span class="k">:</span> <span class="kt">TraversableOnce</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=</span>
    <span class="n">elems</span><span class="o">.</span><span class="n">toTraversable</span> <span class="o">::</span> <span class="n">s</span>
    
  <span class="k">def</span> <span class="n">result</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span> <span class="k">=</span>
    <span class="n">s</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]()){(</span><span class="n">z</span><span class="o">,</span> <span class="n">as</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">as</span> <span class="o">++:</span> <span class="n">z</span><span class="o">}</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">VectorCBF</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">bulkOptimized</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">FunCanBuildFrom</span><span class="o">[</span><span class="kt">Any</span>, <span class="kt">A</span>, <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">bulkOptimized</span><span class="o">)</span>
      <span class="k">new</span> <span class="nc">VectorBuilderListList</span>
    <span class="k">else</span>
      <span class="k">new</span> <span class="nc">VectorBuilderList</span>
<span class="o">}</span>
</code></pre></div></div>



<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on May 10, 2016</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
