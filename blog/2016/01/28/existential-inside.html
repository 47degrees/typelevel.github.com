<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | It’s existential on the inside</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>It’s existential on the inside</h2>

  <p><em>This is the eighth of a series of articles on “Type Parameters and
Type Members”.  You may wish to
<a href="/blog/2015/07/13/type-members-parameters.html">check out the beginning</a>,
which introduces the <code class="highlighter-rouge">PList</code> type we refer to throughout this article
without further ado.</em></p>

<p>When you start working with type parameters, nothing makes it
immediately apparent that you are working with universal and
existential types at the same time. It is literally a matter of
perspective.</p>

<p>I will momentarily set aside a lengthy explanation of what this means,
in favor of some diagrams.</p>

<h2 id="universal-outside-existential-inside">Universal outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">fizzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">rec</span><span class="o">(</span><span class="n">pl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">tl</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">pl</span>
    <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">rec</span><span class="o">(</span><span class="nc">PCons</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">pl</span><span class="o">),</span> <span class="n">xs</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">xs</span> <span class="k">=&gt;</span> <span class="n">rec</span><span class="o">(</span><span class="nc">PNil</span><span class="o">(),</span> <span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-fizzle.png" alt="Universal outside existential inside" /></p>

<p>The caller can select any <code class="highlighter-rouge">A</code>, but the implementation must work with
whatever <code class="highlighter-rouge">A</code> the caller chooses. So <code class="highlighter-rouge">fizzle</code> is universal in <code class="highlighter-rouge">A</code> from
the outside, but existential in <code class="highlighter-rouge">A</code> from the inside.</p>

<p>So what happens when the caller and callee ‘trade places’?</p>

<h2 id="existential-outside-universal-inside">Existential outside, universal inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">wazzle</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">n</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">PCons</span><span class="o">(</span><span class="mi">42</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
       <span class="k">else</span> <span class="nc">PCons</span><span class="o">(</span><span class="s">"hi"</span><span class="o">,</span> <span class="nc">PNil</span><span class="o">())</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-wazzle.png" alt="Existential outside universal inside" /></p>

<p>Now the implementation gets to choose an <code class="highlighter-rouge">A</code>, and the caller must work
with whatever <code class="highlighter-rouge">A</code> the implementation chooses. So <code class="highlighter-rouge">wazzle</code> is universal
in <code class="highlighter-rouge">A</code> from the inside, but existential in <code class="highlighter-rouge">A</code> from the outside.</p>

<p>A good way to think about these two, <code class="highlighter-rouge">fizzle</code> and <code class="highlighter-rouge">wazzle</code>, is that
<code class="highlighter-rouge">fizzle</code> takes a type <em>argument</em> from the caller, but <code class="highlighter-rouge">wazzle</code>
<em>returns</em> a type (alongside the list) to the caller.</p>

<h2 id="universal--outside-existential-inside">Universal (!) outside, existential inside</h2>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">duzzle</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">duzzle</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">duzzle2</span><span class="k">:</span> <span class="kt">PList</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">PNil</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="mi">0</span>
  <span class="k">case</span> <span class="nc">PCons</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">xs</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">duzzle2</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p><img src="/img/media/ieoti-duzzle.png" alt="Universal outside existential inside" /></p>

<p><code class="highlighter-rouge">wazzle</code> “returns” a type, alongside the list, because the existential
appears as part of the return type. However, <code class="highlighter-rouge">duzzle2</code> places the
existential in argument position. So, as with all type-parameterized
cases, <code class="highlighter-rouge">duzzle</code> among them, this is one where the caller determines
the type.</p>

<p>We’ve <a href="/blog/2015/07/16/method-equiv.html">discussed</a> how you can
prove that <code class="highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="highlighter-rouge">duzzle2</code>, in a
previous post. Now, it’s time to see why.</p>

<h2 id="type-parameters-are-parameters">Type parameters are parameters</h2>

<p>The caller chooses the value of a type parameter. It also chooses the
value of normal parameters. So, it makes sense to treat them the same.</p>

<p>Let’s try to look at <code class="highlighter-rouge">fizzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<h2 id="existential-types-are-pairs">Existential types are pairs</h2>

<p>If <code class="highlighter-rouge">wazzle</code> returns a type and a value, it makes sense to treat them
as a returned pair.</p>

<p>Let’s look at <code class="highlighter-rouge">wazzle</code>’s type this way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</code></pre></div></div>

<p>This corresponds exactly to the <code class="highlighter-rouge">forSome</code> scope
<a href="/blog/2015/07/27/nested-existentials.html">we have explored previously</a>.
So we can interpret <code class="highlighter-rouge">PList[PList[_]]</code> as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">PList</span><span class="o">[</span><span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span><span class="k">type</span> <span class="kt">A</span><span class="o">}]</span>  <span class="c1">// explicitly scoped
</span><span class="nc">PList</span><span class="o">[([</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">PList</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span>            <span class="c1">// “paired”
</span></code></pre></div></div>

<h2 id="the-duzzles-are-currying">The <code class="highlighter-rouge">duzzle</code>s are currying</h2>

<p>With these two models, we can finally get to the bottom of
<code class="highlighter-rouge">duzzle</code> ≡<em><sub><small>m</small></sub></em> <code class="highlighter-rouge">duzzle2</code>. Here are their
types, rewritten in the forms we’ve just seen.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
<span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="nc">Int</span>
</code></pre></div></div>

<p>Recognize that? They’re just the curried and uncurried forms of the
same function type.</p>

<p>You can also see why the same type change will not work for <code class="highlighter-rouge">wazzle</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Int</span> <span class="k">=&gt;</span> <span class="o">([</span><span class="kt">A</span><span class="o">],</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
<span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>We’ve moved part of the return type into an argument, which is…not the
same.</p>

<h2 id="the-future-of-types">The future of types?</h2>

<p>This formulation of universal and existential types is due to
dependently-typed systems, in which they are “dependent functions” and
“dependent pairs”, respectively, though with significantly more
expressive power than we’re working with here. They come by way of the
description of the Quest programming language in
<a href="http://www.lucacardelli.name/Papers/TypefulProg.pdf">“Typeful Programming” by Luca Cardelli</a>,
which shows in a clear, syntactic way that the dependent view of
universal and existential types is perfectly cromulent to
non-dependent type systems like Scala’s.</p>

<p>It is also the root of my frustration that Scala doesn’t support a
<code class="highlighter-rouge">forAll</code>, like <code class="highlighter-rouge">forSome</code> but for universally-quantified types. After
all, you can’t work with one without the other.</p>

<p>Now we have enough groundwork for
<a href="/blog/2016/05/10/internal-state.html">“Making internal state functional”</a>,
the next part of this series. I suspect it will be a little prosaic at
this point, though.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Jan 28, 2016</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
