<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Information hiding, enforced</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Information hiding, enforced</h2>

  <p>Code should be reusable. An expression traversing a data structure
shouldn’t be written multiple times, it should be pulled out into a
generic traversal function. At a larger scale, a random number generator
shouldn’t be written multiple times, but rather pulled out into a
module that can be used by others.</p>

<p>It is important that such abstractions must be done carefully.
Often times a type is visible to the caller, and if the type
is not handled carefully the abstraction can leak.</p>

<p>For example, a set with fast random indexing (useful for random
walks on a graph) can be implemented with a sorted <code class="highlighter-rouge">Vector</code>.
However, if the <code class="highlighter-rouge">Vector</code> type is
leaked, the user can use this knowledge to violate the invariant.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.annotation.tailrec</span>

<span class="cm">/** (i in repr, position of i in repr) */</span>
<span class="k">def</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">Boolean</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="cm">/* elided */</span>

<span class="k">object</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="n">repr</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="n">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">IntSet._</span>
<span class="c1">// import IntSet._
</span>
<span class="k">val</span> <span class="n">good</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
<span class="c1">// good: IntSet.Repr = Vector(1, 5, 10)
</span>
<span class="k">val</span> <span class="n">goodResult</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">good</span><span class="o">)</span>
<span class="c1">// goodResult: Boolean = true
</span>
<span class="k">val</span> <span class="n">bad</span> <span class="k">=</span> <span class="n">good</span><span class="o">.</span><span class="n">reverse</span> <span class="c1">// We know it's a Vector!
// bad: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="n">badResult</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad</span><span class="o">)</span>
<span class="c1">// badResult: Boolean = false
</span>
<span class="k">val</span> <span class="n">bad2</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="c1">// Alternatively..
// bad2: scala.collection.immutable.Vector[Int] = Vector(10, 5, 1)
</span>
<span class="k">val</span> <span class="n">badResult2</span> <span class="k">=</span> <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">bad2</span><span class="o">)</span>
<span class="c1">// badResult2: Boolean = false
</span></code></pre></div></div>

<p>The issue here is the user knows more about the representation than they
should. The function <code class="highlighter-rouge">add</code> enforces the sorted invariant on each insert,
and the function <code class="highlighter-rouge">contains</code> leverages this to do an efficient look-up.
Because the <code class="highlighter-rouge">Vector</code> definition of <code class="highlighter-rouge">Repr</code> is exposed, the user is
free to create any <code class="highlighter-rouge">Vector</code> they wish which may violate the invariant,
thus breaking <code class="highlighter-rouge">contains</code>.</p>

<p>In general, the <strong>name</strong> of the representation type is needed but the
<strong>definition</strong> is not. If the definition is hidden, the user is only able to
work with the type to the extent the module allows. This is precisely
the notion of information hiding. If this can be enforced by the type
system, modules can be swapped in and out without worrying about breaking
client code.</p>

<h1 id="quantification">Quantification</h1>
<p>It turns out there is a <a href="http://dl.acm.org/citation.cfm?id=6042" title="On understanding types, data abstraction, and polymorphism - Luca Cardelli, Peter Wegner">well understood principle</a>
behind this idea called <em>existential quantification</em>. Contrast with
universal quantification which says “for all”, existential quantification
says “there is a.”</p>

<p>Below is an encoding of universal quantification via parametric polymorphism.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Universal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here <code class="highlighter-rouge">Universal#apply</code> says <em>for all</em> choices of <code class="highlighter-rouge">A</code>, a function <code class="highlighter-rouge">A =&gt; A</code> can be
written. In the <a href="http://homepages.inf.ed.ac.uk/wadler/topics/history.html#propositions-as-types" title="Propositions as Types - Philip Wadler">Curry-Howard Isomorphism</a>, a profound
relationship between logic and computation, this translates to “for all propositions
<code class="highlighter-rouge">A</code>, <code class="highlighter-rouge">A</code> implies <code class="highlighter-rouge">A</code>.” It is therefore acceptable to write the following, which picks
<code class="highlighter-rouge">A</code> to be <code class="highlighter-rouge">Int</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intInstantiatedU</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Universal</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">u</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// intInstantiatedU: (u: Universal)Int =&gt; Int
</span></code></pre></div></div>

<p>Existential quantification can also be written in Scala.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Existential</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">A</span>

  <span class="k">def</span> <span class="n">apply</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that this is just one way of encoding existentials - for a deeper
discussion, refer to the excellent <a href="/blog/2015/07/13/type-members-parameters.html" title="Type members are [almost] type parameters">Type Parameters and Type Members</a>
blog series.</p>

<p>The type parameter on <code class="highlighter-rouge">apply</code> has been moved up to a type member of the trait.
Practically, this means every instance of <code class="highlighter-rouge">Existential</code> must pick <strong>one</strong> choice of
<code class="highlighter-rouge">A</code>, whereas in <code class="highlighter-rouge">Universal</code> the <code class="highlighter-rouge">A</code> was parameterized and therefore free. In the
language of logic, <code class="highlighter-rouge">Existential#apply</code> says “there is a” or “there exists some <code class="highlighter-rouge">A</code> such that
<code class="highlighter-rouge">A</code> implies <code class="highlighter-rouge">A</code>.” This “there is a” is the crux of the error when trying
to write a corresponding <code class="highlighter-rouge">intExistential</code> function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">intInstantiatedE</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Existential</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">e</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
<span class="c1">// &lt;console&gt;:19: error: type mismatch;
//  found   : i.type (with underlying type Int)
//  required: e.A
//          (i: Int) =&gt; e.apply(i)
//                              ^
</span></code></pre></div></div>

<p>In code, the type in <code class="highlighter-rouge">Existential</code> is chosen per-instance, so there is no way
of knowing what the actual type chosen is. In logical terms, the only guarantee is
that there exists some proposition that satisfies the implication, but it is not
necessarily the case (and often is not) it holds for all propositions.</p>

<h1 id="abstract-types">Abstract types</h1>
<p>In the ML family of languages (e.g. Standard ML, OCaml), existential quantification
and thus information hiding, is achieved through <a href="http://dl.acm.org/citation.cfm?id=45065" title="Abstract types have existential type">type members</a>.
Programs are organized into <a href="https://realworldocaml.org/v1/en/html/files-modules-and-programs.html" title="Real World OCaml: Files, Modules, and Programs">modules</a> which are what contain these
types.</p>

<p>In Scala, this translates to organizing code with the object system, using the same
type member feature to hide representation. The earlier example of <code class="highlighter-rouge">IntSet</code> can then
be written:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/** Abstract signature */</span>
<span class="k">trait</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span>
  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="o">}</span>

<span class="cm">/** Concrete implementation */</span>
<span class="k">object</span> <span class="nc">VectorIntSet</span> <span class="k">extends</span> <span class="nc">IntSet</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>

  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">isMember</span><span class="o">,</span> <span class="n">indexOf</span><span class="o">)</span> <span class="k">=</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">isMember</span><span class="o">)</span> <span class="n">repr</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">prefix</span><span class="o">,</span> <span class="n">suffix</span><span class="o">)</span> <span class="k">=</span> <span class="n">repr</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="n">indexOf</span><span class="o">)</span>
      <span class="n">prefix</span> <span class="o">++</span> <span class="nc">Vector</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">contains</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">repr</span><span class="k">:</span> <span class="kt">Repr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
    <span class="n">binarySearch</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">repr</span><span class="o">).</span><span class="n">_1</span>
<span class="o">}</span>
</code></pre></div></div>

<p>As long as client code is written against the signature, the
representation cannot be leaked.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">goodUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">empty</span><span class="o">)))</span>
  <span class="n">contains</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="n">s</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// goodUsage: (set: IntSet)Boolean
</span></code></pre></div></div>

<p>If the user tries to assert the representation type, the type
checker prevents it <strong>at compile time</strong>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">badUsage</span><span class="o">(</span><span class="n">set</span><span class="k">:</span> <span class="kt">IntSet</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">set._</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">add</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">empty</span><span class="o">))</span>

  <span class="c1">// Maybe it's a Vector
</span>  <span class="n">s</span><span class="o">.</span><span class="n">reverse</span>
  <span class="n">contains</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="o">}</span>
<span class="c1">// &lt;console&gt;:23: error: value reverse is not a member of set.Repr
//          s.reverse
//            ^
// &lt;console&gt;:24: error: type mismatch;
//  found   : scala.collection.immutable.Vector[Int]
//  required: set.Repr
//          contains(10, Vector(10, 5, 1))
//                             ^
</span></code></pre></div></div>

<h1 id="parametricity">Parametricity</h1>
<p>Abstract types enforce information hiding at the definition site (the definition
of <code class="highlighter-rouge">IntSet</code> is what hides <code class="highlighter-rouge">Repr</code>). There is another mechanism that enforces information
hiding, which pushes the constraint to the use site.</p>

<p>Consider implementing the following function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given nothing is known about <code class="highlighter-rouge">a</code>, the only possible thing <code class="highlighter-rouge">foo</code> can do is return <code class="highlighter-rouge">a</code>. If
instead of a type parameter the function was given more information..</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">bar</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"not even going to use `a`"</span>
</code></pre></div></div>

<p>..that information can be leveraged to do unexpected things. This is similar to
the first <code class="highlighter-rouge">IntSet</code> example when knowledge of the underlying <code class="highlighter-rouge">Vector</code> allowed unintended
behavior to occur.</p>

<p>From the outside looking in, <code class="highlighter-rouge">foo</code> is universally quantified - the caller gets to
pick any <code class="highlighter-rouge">A</code> they want. From the inside looking out, it is
<a href="/blog/2016/01/28/existential-inside.html" title="It’s existential on the inside">existentially quantified</a> - the implementation knows only as much
about <code class="highlighter-rouge">A</code> as there are constraints on <code class="highlighter-rouge">A</code> (in this case, nothing).</p>

<p>Consider another function <code class="highlighter-rouge">listReplace</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">???</span>
</code></pre></div></div>

<p>Given the type parameters, <code class="highlighter-rouge">listReplace</code> looks fairly constrained. The name and signature
suggests it takes each element of <code class="highlighter-rouge">as</code> and replaces it with <code class="highlighter-rouge">b</code>, returning a new list.
However, even knowledge of <code class="highlighter-rouge">List</code> can lead to type checking implementations with strange behavior.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Completely ignores the input parameters
</span><span class="k">def</span> <span class="n">listReplace</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</code></pre></div></div>

<p>Here, knowledge of <code class="highlighter-rouge">List</code> allows the implementation
to create a list out of thin air and use that in the implementation. If instead <code class="highlighter-rouge">listReplace</code>
only knew about some <code class="highlighter-rouge">F[_]</code> where <code class="highlighter-rouge">F</code> is a <code class="highlighter-rouge">Functor</code>, the implementation becomes much more
constrained.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">listFunctor</span><span class="k">:</span> <span class="kt">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">List</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">replace</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">implicitly</span><span class="o">[</span><span class="kt">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]].</span><span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">replace</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="s">"typelevel"</span><span class="o">)</span>
<span class="c1">// res8: List[String] = List(typelevel, typelevel, typelevel)
</span></code></pre></div></div>

<p>Absent any knowledge of <code class="highlighter-rouge">F</code> other than the ability to <code class="highlighter-rouge">map</code> over it, <code class="highlighter-rouge">replace</code> is
forced to do the correct thing. Put differently, irrelevant information about <code class="highlighter-rouge">F</code> is hidden.</p>

<p>The fundamental idea behind this is known as parametricity, made popular by Philip Wadler’s
seminal <a href="http://dl.acm.org/citation.cfm?id=99404" title="Theorems for free!">Theorems for free!</a> paper. The technique is best summarized by the
following excerpt from the paper:</p>

<blockquote>
  <p>Write down the definition of a polymorphic function on a piece of paper. Tell me its type,
but be careful not to let me see the function’s definition. I will tell you a theorem that
the function satisfies.</p>
</blockquote>

<h1 id="why-types-matter">Why types matter</h1>
<p>Information hiding is a core tenet of good program design, and it is important to make
sure it is enforced. Underlying information hiding is existential quantification,
which can manifest itself in computation through abstract types and
parametricity. Few languages support defining abstract type members, and fewer
yet support higher-kinded types used in the <code class="highlighter-rouge">replace</code> example. It is therefore
to the extent that a language’s type system is expressive that
<a href="https://www.cis.upenn.edu/~bcpierce/tapl/" title="Types and Programming Languages - Benjamin C. Pierce">abstraction can be enforced</a>.</p>

<p><em>This blog post was tested with Scala 2.11.7 using <a href="https://github.com/tpolecat/tut" title="tut: doc/tutorial generator for scala">tut</a>.</em></p>



<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/adelbertchang.jpeg" />
      
      <p>by Adelbert Chang
    
    on Mar 13, 2016</p>

    
  <a href="https://twitter.com/adelbertchang" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @adelbertchang</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/adelbertc" aria-label="Follow @adelbertc on GitHub">Follow @adelbertc</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
