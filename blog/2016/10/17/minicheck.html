<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Let's build ourselves a small ScalaCheck</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Let's build ourselves a small ScalaCheck</h2>

  <p><em><a href="http://scalacheck.org/">ScalaCheck</a> is a well-known property-based testing library, based on ideas from Haskell’s <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>.
It is also a <a href="/projects">Typelevel project</a>.
In this post, I’d like to show some of the underlying mechanisms, stripped down to the bare minimum.</em></p>

<p>Testing with properties is well-understood in academia and widely used in parts of the industry – namely the parts which embrace functional programming.
However, the design space of property-testing libraries is rather large.
I think it is high time to talk about various tradeoffs done in libraries.
Here, I’d like to contribute by implementing a ScalaCheck clone from scratch using a very similar design and explaining the design choices along the way.</p>

<p>This is not an introduction to property testing.
However, it can be read as a guide to implementation ideas.
QuickCheck, ScalaCheck and the like are nice examples of functional library design, but their internals are often obscured by technicalities.
I hope that by clearing up some of the concepts it will become easier to read their code and perhaps designing your own property-testing library.</p>

<h2 id="the-first-design-decision">The first design decision</h2>

<p>The basic point of a property testing library is providing an interface looking roughly like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">check</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">forAll</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, you can use that in your test code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Prop</span><span class="o">.</span><span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This expresses that you have a property which is parameterized on a single integer number.
Hence, the library must somehow provide these integer numbers.
The original Haskell QuickCheck, ScalaCheck and many other libraries use a <em>random generator</em> for this.
This comes with a number of advantages:</p>

<ul>
  <li>It is relatively simple and efficient to implement.</li>
  <li>Random number generators compose exceedingly well.</li>
  <li>The confidence in the tests can be increased by just generating more inputs.</li>
  <li>Depending on the random distributions of the generators used, you have chances that both “exotic” and “common” inputs are covered.</li>
  <li>In practice, it turns out that random generators are decent at finding edge cases.</li>
</ul>

<p>But it is also not without problems:</p>

<ul>
  <li>For more complex inputs, the default generators are basically useless, because they will produce invalid input most of the time.</li>
  <li>Filtering random values before feeding them into the property can dramatically slow down the whole process.</li>
  <li>By default, it is non-deterministic (but there are remedies available).</li>
  <li>Generation of <em>random functions</em> to be used as inputs for higher-order properties is quite round-about.</li>
</ul>

<p>Of course, there are other possible design choices:</p>

<ul>
  <li><a href="https://hackage.haskell.org/package/smallcheck">SmallCheck</a> instead enumerates <em>all</em> values up to a certain size.
For example, you can specify that you want to test some function over integer lists with all lists up to size 5, containing all integers between -5 and +5.
In some situations, namely when your input is finite, you can even <em>exhaustively</em> check all inputs, which is equivalent to a <em>proof</em> that your program is correct.
The disadvantage is that even for small sizes, the input space may explode exponentially or worse (e.g. when generating lists of lists).</li>
  <li><a href="https://isabelle.in.tum.de">Isabelle</a> Quickcheck supports multiple modes, including <em>narrowing</em>, which is a form of symbolically exploring the search space.
This is based on Haskell’s <a href="https://hackage.haskell.org/package/lazysmallcheck">Lazy SmallCheck</a> (see also the <a href="https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf">paper by Runciman et.al.</a>).
The basic idea is that we can try to evaluate properties with <em>partially-defined inputs</em> and refine them on demand.</li>
</ul>

<p><strong>For this post, we’re assuming that random generation is a given.</strong></p>

<h2 id="the-second-design-decision">The second design decision</h2>

<blockquote>
  <p>Do we want to do this purely or poorly?</p>
</blockquote>

<p>Of course, this motto is tongue-in-cheek.
Just because something isn’t <em>pure</em> doesn’t mean that it is <em>poor.</em></p>

<p>To understand the design space here, let’s focus on the smallest building block: A primitive random generator.
There are two possible ways to model this.
The <em>mutable</em> way is what Java, Scala and many other languages offer in their libraries:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">nextFloat</span><span class="o">()</span><span class="k">:</span> <span class="kt">Float</span>
  <span class="k">def</span> <span class="n">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By looking at the types alone, we can already see that two subsequent calls of <code class="highlighter-rouge">nextInt</code> will produce different results; the interface is thus <em>impure.</em></p>

<p>The <em>pure</em> way is to make the internal state (also known as “seed” in the context of random generators) explicit:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">nextFloat</span><span class="k">:</span> <span class="o">(</span><span class="kt">Float</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">nextItem</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">pool</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">Seed</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Seed</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">init</span><span class="o">()</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=</span> <span class="o">???</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Because this is difficult to actually use (don’t mix up the <code class="highlighter-rouge">Seed</code> instances and use them twice!), one would wrap this into a state monad:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="n">op</span><span class="k">:</span> <span class="kt">Seed</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="nc">Seed</span><span class="o">))</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">()</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">op</span><span class="o">(</span><span class="nc">Seed</span><span class="o">.</span><span class="n">init</span><span class="o">()).</span><span class="n">_1</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">),</span> <span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Random</span><span class="o">[</span><span class="kt">B</span><span class="o">]({</span> <span class="n">seed0</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">seed1</span><span class="o">)</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">op</span><span class="o">(</span><span class="n">seed0</span><span class="o">)</span>
      <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">op</span><span class="o">(</span><span class="n">seed1</span><span class="o">)</span>
    <span class="o">})</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;random&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Random</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">int</span><span class="o">(</span><span class="n">min</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">max</span><span class="o">))</span>
  <span class="k">val</span> <span class="n">float</span><span class="k">:</span> <span class="kt">Random</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nextFloat</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can use Scala’s <code class="highlighter-rouge">for</code> comprehensions:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">{</span>
  <span class="n">x</span> <span class="k">&lt;-</span> <span class="nc">Random</span><span class="o">.</span><span class="n">int</span><span class="o">(-</span><span class="mi">5</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
  <span class="n">y</span> <span class="k">&lt;-</span> <span class="nc">Random</span><span class="o">.</span><span class="n">int</span><span class="o">(-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
<span class="c1">// res2: Random[(Int, Int)] = &lt;random&gt;
</span></code></pre></div></div>

<p>The tradeoffs here are the usual when we’re talking about functional programming in Scala: Reasoning ability, convenience, performance, … 
In the pure case, there are also multiple other possible encodings, including free monads.
Luckily, this blog covers that topic in another <a href="/blog/2016/09/21/edsls-part-1.html">post</a>.</p>

<p>How do other libraries fare here?</p>

<ul>
  <li>ScalaCheck up to 1.12.x uses a mutable random number generator; namely, <code class="highlighter-rouge">scala.util.Random</code>.</li>
  <li>ScalaCheck 1.13.x+ uses its own, immutable implementation.</li>
  <li>Another Scala library for property testing, <a href="https://github.com/scalaprops/scalaprops">scalaprops</a>, does not.
I’m not familiar with it, but as far as I can tell from the <a href="https://github.com/scalaprops/scalaprops/blob/v0.3.4/gen/src/main/scala/scalaprops/Rand.scala">sources</a>, it’s similar to the <code class="highlighter-rouge">Seed</code> trait from above, and there is also an additional state-monadic layer on top of it.</li>
  <li>In QuickCheck, the encoding seems strange at first.
They use a primitive generator which looks a lot like <code class="highlighter-rouge">Seed</code>, but they don’t use the updated seed.
Instead, their approach is via an additional primitive <code class="highlighter-rouge">split</code> of type <code class="highlighter-rouge">Seed =&gt; (Seed, Seed)</code>, which gets used to “distribute” randomness during composition (see the <a href="http://publications.lib.chalmers.se/records/fulltext/183348/local_183348.pdf">paper by Claessen &amp; Pałka</a> about the theory behind that).
It is worth noting that Java 8 introduced a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/SplittableRandom.html"><code class="highlighter-rouge">SplittableRandom</code></a> class.</li>
</ul>

<p><strong>For this post, we’re assuming that mutable state is a given.</strong>
We’ll use <code class="highlighter-rouge">scala.util.Random</code> (because it’s readily available) in a similar fashion to ScalaCheck 1.12.x.</p>

<h2 id="the-third-design-decision">The third design decision</h2>

<p>Asynchronous programming is all the rage these days.
This means that many functions will not return plain values of type <code class="highlighter-rouge">A</code>, but rather <code class="highlighter-rouge">Future[A]</code>, <code class="highlighter-rouge">Task[A]</code> or some other similar type.
For our testing framework, this poses a challenge:
If our properties call such asynchronous functions, the framework needs to know how to deal with a lot of <code class="highlighter-rouge">Future[Boolean]</code> values.
On the JVM, although not ideal, we could fall back to blocking on the result and proceed as usual.
On <a href="http://www.scala-js.org/">Scala.js</a>, this won’t fly, because you just can’t block in JavaScript.</p>

<p>Most general-purpose testing frameworks, like Specs2, have a <a href="https://etorreborre.github.io/specs2/guide/SPECS2-3.8.5/org.specs2.guide.Matchers.html">story about this</a>, enabling asynchronous checking of assertions.</p>

<p>In theory, it’s not a problem to support this in a property testing library.
But in practice, there are some complications:</p>

<ul>
  <li>Has the library been designed that way? If not, can we change it to support it?
This is a real problem: It took quite some time and some significant refactorings to support <code class="highlighter-rouge">Future</code>s in <a href="http://www.scalatest.org/user_guide/async_testing">ScalaTest</a>.</li>
  <li>Should random generators also return <code class="highlighter-rouge">Future</code> values?
We can easily imagine wanting to draw from a pool of inputs stemming from a database, or possibly to get better randomness from <a href="https://www.random.org/">random.org</a>.
(The latter is a joke.)</li>
  <li>What async type constructor should we support?
<a href="http://www.scala-lang.org/files/archive/api/2.11.8/#scala.concurrent.Future">The built-in one</a>?
<a href="https://monix.io/docs/2x/eval/task.html">Monix’ <code class="highlighter-rouge">Task</code></a>?
<a href="https://github.com/functional-streams-for-scala/fs2/blob/v0.9.1/core/shared/src/main/scala/fs2/Task.scala">fs2’s <code class="highlighter-rouge">Task</code></a>?
All of them?</li>
</ul>

<p>If in the first design decisions we had chosen exhaustive generators, this problem would be even tougher, because designing a correct effectful stream type (of all possible inputs) is not trivial.</p>

<p><strong>For this post, we’re assuming that we’re only interested in synchronous properties, or can always block.</strong>
However, I’d like to add, I’d probably try to incorporate async properties right from the start if I were to implement a testing library from scratch.</p>

<p>What about the existing libraries?</p>

<ul>
  <li>ScalaCheck itself does not support asynchronous properties.</li>
  <li>In SmallCheck, both <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck-Series.html#t:Serial">generators</a> and <a href="https://hackage.haskell.org/package/smallcheck-1.1.1/docs/Test-SmallCheck.html#t:Property">properties</a> may be monadic.</li>
  <li>QuickCheck supports arbitrary I/O actions in a property via a function called <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Property.html#v:morallyDubiousIOProperty"><code class="highlighter-rouge">morallyDubiosIOProperty</code></a> (nowadays just <code class="highlighter-rouge">ioProperty</code>).
But there is also <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Monadic.html">more advanced support</a> for monadic testing.</li>
</ul>

<h2 id="the-fourth-design-decision">The fourth design decision</h2>

<p>Let’s summarize what we have so far:</p>

<ol>
  <li>randomly generated inputs</li>
  <li>… using a stateful primitive generator</li>
  <li>synchronous properties</li>
</ol>

<p>Now, I’d like to talk about how to “package” random generators.
Earlier, we’ve only seen random integer and floating-point numbers, but of course, we want something more complex, including custom data structures.
It is convenient to abstract over this and specify the concept of a <em>generator</em> for type <code class="highlighter-rouge">A</code>.
The idea is to make a generator for a type as “general” as possible and then provide combinators to compose them.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>An obvious combinator is a generator for tuples:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">zip</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">genU</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[(</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">)]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">),</span> <span class="n">genU</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>But we still have a problem:
There is currently no way to talk about the <em>size</em> of the generated inputs.
Let’s say we want to check an expensive algorithm over lists, for example with a complexity of $\mathcal O(n^3)$ over lists.
A naive implemenation of a list generator would take a a random size, and then give you some generator for lists.
The problem arises at the use site: Whenver you want to change the size of the generated inputs, you need to change the expression constructing the generator.</p>

<p>But we’d like to do better here:</p>

<p><strong>For this post, there should be a way to specify a maximum size of generated values, together with a way to influence that size in the tests without having to modify the generators.</strong></p>

<p>Here’s how we can do that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="n">genA</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>We can now check this (note that for the purpose of this post we’ll be using fixed seeds):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">printSample</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">count</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">size</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="mi">2</span>
<span class="mi">6</span>
<span class="o">-</span><span class="mi">6</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">1</span>
<span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>
<span class="mi">5</span>
<span class="o">-</span><span class="mi">4</span>
<span class="o">-</span><span class="mi">8</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">list</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="o">-</span><span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="o">-</span><span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">8</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="o">-</span><span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="o">-</span><span class="mi">10</span><span class="o">)</span>
<span class="nc">List</span><span class="o">()</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">printSample</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">list</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>
<span class="nc">List</span><span class="o">(-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</code></pre></div></div>

<p>That’s already pretty cool.
But there’s another hidden design decision here:
We’re using the same size on all sub-elements in the generated thing.
For example, in <code class="highlighter-rouge">Gen.list</code>, we’re just passing the size through to the child generator.</p>

<p>SmallCheck does that differently: The “size” is defined to be the total number of constructors in the generated value.
For integer numbers, the “number of constructors” is basically the number itself.
For example, the value <code class="highlighter-rouge">List(1, 2)</code> has size $2$ in our framework (length of the list), but size $1 + 2 + 2 = 5$ in SmallCheck (roughly: size of all elements plus length of list).</p>

<p>Of course, our design decision might mean that stuff grows too fast.
The explicit size parameter can be used to alleviate that, especially for writing recursive generators:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">recList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
  <span class="c1">// extremely stupid implementation, don't use it
</span>  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
      <span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="o">::</span> <span class="n">recList</span><span class="o">(</span><span class="n">genT</span><span class="o">).</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">Nil</span>
<span class="o">}</span>
<span class="c1">// recList: [T](genT: Gen[T])Gen[List[T]]
</span>
<span class="n">printSample</span><span class="o">(</span><span class="n">recList</span><span class="o">(</span><span class="nc">Gen</span><span class="o">.</span><span class="n">int</span><span class="o">),</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// List()
// List(-6, 1, -6)
// List(-8, 8, 4, 7, 0, 5, -4)
// List(-8)
// List(9, -3, 4)
// List(1, 3, -7, -2, -3, 0, -3, 3)
// List()
// List(10, 5, -8, -4, -5, 4, -1)
// List(-5, 9, 7)
// List(-8)
</span></code></pre></div></div>

<p>We can also provide a combinator for this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">resize</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">genT</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">newSize</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
    <span class="n">genT</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">newSize</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That one is useful because in reality ScalaCheck’s <code class="highlighter-rouge">generate</code> method takes some more parameters than just the size.
Some readers might be reminded that this is just the reader monad and its <code class="highlighter-rouge">local</code> combinator in disguise.</p>

<h2 id="some-sugar">Some sugar</h2>

<p>In order to make these generators nicely composable, we can leverage <code class="highlighter-rouge">for</code> comprehensions.
We just need to implement <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code> and <code class="highlighter-rouge">withFilter</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.util.Random</span>

<span class="k">trait</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span> <span class="n">self</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>

  <span class="c1">// Generate a value and then apply a function to it
</span>  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="n">f</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="c1">// Generate a value and then use it to produce a new generator
</span>  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">U</span> <span class="o">=</span>
      <span class="n">f</span><span class="o">(</span><span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)).</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// Repeatedly generate values until one passes the check
</span>  <span class="c1">// (We would usually call this `filter`, but Scala requires us to
</span>  <span class="c1">// call it `withFilter` in order to be used in `for` comprehensions)
</span>  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">candidate</span> <span class="k">=</span> <span class="n">self</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">candidate</span><span class="o">))</span>
        <span class="n">candidate</span>
      <span class="k">else</span> <span class="c1">// try again
</span>        <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;gen&gt;"</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Gen</span> <span class="o">{</span>

  <span class="c1">// unchanged from above
</span>
  <span class="k">val</span> <span class="n">int</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">range</span> <span class="k">=</span> <span class="n">size</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">range</span><span class="o">)</span> <span class="o">-</span> <span class="n">size</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">list</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">genA</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">rnd</span><span class="o">.</span><span class="n">nextInt</span><span class="o">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="n">length</span><span class="o">)(</span><span class="n">genA</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Look how simple composition is now:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">numerator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">denominator</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="c1">// defined class Frac
</span>
<span class="k">val</span> <span class="n">fracGen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">Frac</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">num</span> <span class="k">&lt;-</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
    <span class="n">den</span> <span class="k">&lt;-</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
    <span class="k">if</span> <span class="n">den</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="nc">Frac</span><span class="o">(</span><span class="n">num</span><span class="o">,</span> <span class="n">den</span><span class="o">)</span>
<span class="c1">// fracGen: Gen[Frac] = &lt;gen&gt;
</span>
<span class="n">printSample</span><span class="o">(</span><span class="n">fracGen</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
<span class="c1">// Frac(2,6)
// Frac(-6,-8)
// Frac(1,4)
// Frac(-8,5)
// Frac(-4,-8)
// Frac(-2,-8)
// Frac(4,6)
// Frac(1,4)
// Frac(0,-10)
// Frac(10,4)
</span></code></pre></div></div>

<p>And we can even read the construction nicely: “First draw a numerator, then draw a denominator, then check that the denominator is not zero, then construct a fraction.”
However, we need to be cautious with the filtering.
If you look closely at the implementation of <code class="highlighter-rouge">withFilter</code>, you can see that there is potential for an infinite loop.
For example, when you pass in the filter <code class="highlighter-rouge">_ =&gt; false</code>.
It will just keep generating values and then discard them.
How do existing frameworks alleviate this?</p>

<ul>
  <li>QuickCheck has two filter combinators: one that returns <code class="highlighter-rouge">Gen[A]</code> as above, and one that return <code class="highlighter-rouge">Gen[Option[A]]</code>.
The latter uses a number of tries and if they all fail, terminates and returns <code class="highlighter-rouge">None</code>.
The former uses the latter, but keeps increasing the size parameter.
Of course, this might not terminate.</li>
  <li>ScalaCheck’s <code class="highlighter-rouge">filter</code> method returns <code class="highlighter-rouge">Gen[A]</code>, but the possibility of failure is encoded in the return type of its equivalent of the <code class="highlighter-rouge">generate</code> method, which always returns <code class="highlighter-rouge">Option[T]</code>.
But there is also a combinator which retries until it finds a valid input, called <code class="highlighter-rouge">retryUntil</code>.</li>
</ul>

<p>As a side note: <code class="highlighter-rouge">Gen</code> as it is right now is <em>definitely not</em> a valid monad, because it internally relies on mutable state.
But in my opinion, it is still justified to offer the <code class="highlighter-rouge">map</code> and <code class="highlighter-rouge">flatMap</code> methods, but don’t give a <code class="highlighter-rouge">Monad</code> instance.
This prevents you from shoving <code class="highlighter-rouge">Gen</code> into functions which expect lawful monads.</p>

<p>It’s still tedious to having to construct these generators by hand.
Both QuickCheck and ScalaCheck introduce a thin layer atop generators, called <code class="highlighter-rouge">Arbitrary</code>.
This is just a type class which contains a generator, nothing more.
Here’s how it would look like in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">gen</span><span class="k">:</span> <span class="kt">Gen</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// in practice we would put that into the companion object
//object Arbitrary {
</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">arbitraryInt</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Arbitrary</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">gen</span> <span class="k">=</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">int</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Based on this definition, ScalaCheck provides a lot of pre-defined instances for all sorts of types.
For your custom types, the idea is that you define a low-level generator and wrap it into an implicit <code class="highlighter-rouge">Arbitrary</code>.
Then, in your tests, you just use the implicitly provided generator, and avoid to drop down to constructing them manually.</p>

<p>The purpose of the additional layer is explained easily: It is common to have multiple <code class="highlighter-rouge">Gen[T]</code> for the same <code class="highlighter-rouge">T</code> depending on which context it is needed in.
But there should only be one <code class="highlighter-rouge">Arbitrary[T]</code> for each <code class="highlighter-rouge">T</code>.
For example, you might have <code class="highlighter-rouge">Gen[Int]</code> for positive and negative integers, but you only have a single <code class="highlighter-rouge">Arbitrary[Int]</code> which covers all integers.
You use the latter when you actually need to supply an integer to your property, and the former to construct more complex generators, like for <code class="highlighter-rouge">Frac</code> above.</p>

<h2 id="the-fifth-design-decision">The fifth design decision</h2>

<p>This is where everything really comes together.
We’re now looking at how to use <code class="highlighter-rouge">Gen</code> to implement the desired <code class="highlighter-rouge">forAll</code> function we’ve seen early in the introduction of the post, and how that is related to the <code class="highlighter-rouge">Prop</code> type I didn’t define.
I’ll readily admit that the following isn’t really a design decision per se, because we’ll be guided by the presence of type classes in Scala.
Still, one could reasonably structure this differently, and in fact, the design of the <code class="highlighter-rouge">Prop</code> type in e.g. QuickCheck is much more complex than what you’ll see.</p>

<p>The rest of this post will now depart from the way it’s done in ScalaCheck, although the ideas are still similar.
Instead, I’ll try to show a simplified version without introducing complications required to make it work nicely.</p>

<p>Let’s start with the concept of a <em>property.</em>
A property is something that we can <em>run</em> and which returns a <em>result</em>.
The result should ideally be something like a boolean: Either the property holds or it doesn’t.
But one of the main features of any property testing library is that it will return a counterexample for the inputs where the property doesn’t hold.
Hence, we need to store this counterexample in the failure case.
In practice, the result type would be much richer, with attached labels, reasons, expectations, counters, … and more diagnostic fields.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">Result</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">Success</span> <span class="k">extends</span> <span class="nc">Result</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">Result</span>

<span class="k">object</span> <span class="nc">Result</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">fromBoolean</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">)</span>
      <span class="nc">Success</span>
    <span class="k">else</span>
      <span class="c1">// if it's false, it's false; no input has been produced,
</span>      <span class="c1">// so the counterexample is empty
</span>      <span class="nc">Failure</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>You’ll note that I’ve used <code class="highlighter-rouge">List[String]</code> here, because in the end we only want to print the counterexample on the console.
ScalaCheck has a dedicated <code class="highlighter-rouge">Pretty</code> type for that.
We could do even more fancy things here if we wanted to, but let’s keep it simple.</p>

<p>Now we define the <code class="highlighter-rouge">Prop</code> type:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Prop</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"&lt;prop&gt;"</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What’s missing is a way to construct properties.
Sure, we could implement the trait manually in our tests, but that would be tedious.
Type classes to the rescue!
We call something <em>testable</em> if it can be converted to a <code class="highlighter-rouge">Prop</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span>
<span class="o">}</span>

<span class="c1">// in practice we would put these into the companion object
//object Testable {
</span>
  <span class="c1">// Booleans can be trivially converted to a property:
</span>  <span class="c1">// They are already basically a `Result`, so no need
</span>  <span class="c1">// to run anything!
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">booleanIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
        <span class="nc">Result</span><span class="o">.</span><span class="n">fromBoolean</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// Props are already `Prop`s.
</span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">propIsTestable</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">Prop</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Prop</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="n">t</span>
  <span class="o">}</span>

<span class="c1">//}
</span></code></pre></div></div>

<p>Now we’re all set:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">forAll</span><span class="o">[</span><span class="kt">I</span>, <span class="kt">O</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">arbI</span><span class="k">:</span> <span class="kt">Arbitrary</span><span class="o">[</span><span class="kt">I</span><span class="o">],</span> <span class="n">testO</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">O</span><span class="o">])</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">Prop</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">rnd</span><span class="k">:</span> <span class="kt">Random</span><span class="o">)</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">input</span> <span class="k">=</span> <span class="n">arbI</span><span class="o">.</span><span class="n">gen</span><span class="o">.</span><span class="n">generate</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">subprop</span> <span class="k">=</span> <span class="n">testO</span><span class="o">.</span><span class="n">asProp</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="n">input</span><span class="o">))</span>
      <span class="n">subprop</span><span class="o">.</span><span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
          <span class="nc">Success</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
          <span class="nc">Failure</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="n">toString</span> <span class="o">::</span> <span class="n">counterexample</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Let’s unpack this step by step.</p>

<ol>
  <li>We’re taking a function from <code class="highlighter-rouge">I =&gt; O</code>.
This is supposed to be our parameterized property, for example <code class="highlighter-rouge">{ (x: Int) =&gt; x == x }</code>.
Because we abstracted over values that can be generated (<code class="highlighter-rouge">Arbitrary</code>) and things that can be tested (<code class="highlighter-rouge">Testable</code>), the input and output types are completely generic.
In the <code class="highlighter-rouge">implicit</code> block, we’re taking the instructions of how to fit everything together.</li>
  <li>We’re constructing a <code class="highlighter-rouge">Prop</code>; that is, a thing that we can run and that produces a boolean-ish <code class="highlighter-rouge">Result</code>.</li>
  <li>To run the property, we need to construct a random input.
We can use the <code class="highlighter-rouge">Gen[I]</code> which we get from the <code class="highlighter-rouge">Arbitrary[I]</code>.</li>
  <li>We pass that <code class="highlighter-rouge">I</code> into the parameterized property.
To stick with the example, we evaluate the anonymous function <code class="highlighter-rouge">{ (x: Int) =&gt; x == x }</code> at input <code class="highlighter-rouge">5</code>, and obtain <code class="highlighter-rouge">true</code>.</li>
  <li>We convert the result to a <code class="highlighter-rouge">Prop</code> again.
This allows us to recursively nest <code class="highlighter-rouge">forAll</code>s, for example when we need two inputs.</li>
  <li>We run the resulting property and check if it fails.
If it does, we prepend the generated input to the counterexample.
In the nested scenario, this allows us to see all generated inputs and the order in which we sticked them into the property.</li>
</ol>

<p>At this point we should look at an example.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">propReflexivity</span> <span class="k">=</span>
  <span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="c1">// propReflexivity: Prop = &lt;prop&gt;
</span></code></pre></div></div>

<p>Cool, but how do we run this?</p>

<p>Remember that our tool is supposed to evaluate a property on multiple inputs.
All these evaluations will produce a <code class="highlighter-rouge">Result</code>.
Hence, we need to merge those together into a single result.
We’ll also define a convenient function that runs a property multiple times on different sizes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Result</span><span class="o">])</span><span class="k">:</span> <span class="kt">Result</span> <span class="o">=</span>
  <span class="n">rs</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Success</span><span class="k">:</span> <span class="kt">Result</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Success</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Success</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">Success</span><span class="o">,</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">cs</span><span class="o">)</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">check</span><span class="o">[</span><span class="kt">P</span><span class="o">](</span><span class="n">prop</span><span class="k">:</span> <span class="kt">P</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">testP</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">P</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">rnd</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Random</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">rs</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">size</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">to</span> <span class="mi">100</span><span class="o">)</span>
    <span class="k">yield</span> <span class="n">testP</span><span class="o">.</span><span class="n">asProp</span><span class="o">(</span><span class="n">prop</span><span class="o">).</span><span class="n">run</span><span class="o">(</span><span class="n">size</span><span class="o">,</span> <span class="n">rnd</span><span class="o">)</span>
  <span class="n">merge</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Success</span> <span class="k">=&gt;</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"✓ Property successfully checked"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">counterexample</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">pretty</span> <span class="k">=</span> <span class="n">counterexample</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">"("</span><span class="o">,</span> <span class="s">", "</span><span class="o">,</span> <span class="s">")"</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">"✗ Property failed with counterexample: $pretty"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>What is happening here?</p>

<ol>
  <li>The <code class="highlighter-rouge">merge</code> function takes a list of <code class="highlighter-rouge">Result</code>s and returns the first <code class="highlighter-rouge">Failure</code>, if it exists.
Otherwise it returns <code class="highlighter-rouge">Success</code>.
In case there are multiple <code class="highlighter-rouge">Failure</code>s, it doesn’t care and just discards the later ones.</li>
  <li>The <code class="highlighter-rouge">check</code> function initializes a fresh random generator.</li>
  <li>We have fixed the maximum size to 100 and will run the passed property with each size from 0 to 100.
This ensures that we get a nice coverage of various input sizes.
An obvious optimisation here would be to stop after the first failure, instead of merging the results in a subsequent step.</li>
  <li>In case there’s a failure, we just print the counterexample.</li>
</ol>

<p>Let’s check our property!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span><span class="o">(</span><span class="n">propReflexivity</span><span class="o">)</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>
</code></pre></div></div>

<p>… and how about something wrong?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span><span class="o">(</span><span class="n">forAll</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">})</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="some-more-sugar">Some more sugar</h2>

<p>Okay, we’re almost done.
The only tedious thing that remains is that we have to use the <code class="highlighter-rouge">forAll</code> combinator, especially in the nested case.
It would be great if we could just use <code class="highlighter-rouge">check</code> and pass it a function.
But since we’ve used type classes for everything, we’re in luck!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">funTestable</span><span class="o">[</span><span class="kt">I</span> <span class="kt">:</span> <span class="kt">Arbitrary</span>, <span class="kt">O</span> <span class="kt">:</span> <span class="kt">Testable</span><span class="o">]</span><span class="k">:</span> <span class="kt">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Testable</span><span class="o">[</span><span class="kt">I</span> <span class="k">=&gt;</span> <span class="kt">O</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">asProp</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">I</span> <span class="o">=&gt;</span> <span class="n">O</span><span class="o">)</span><span class="k">:</span> <span class="kt">Prop</span> <span class="o">=</span>
    <span class="c1">// wait for it ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// ...
</span>    <span class="c1">// it's really simple ...
</span>    <span class="n">forAll</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now we can check our functions even easier!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">==</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">&gt;</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">)</span>

<span class="kt">scala&gt;</span> <span class="kt">check</span> <span class="o">{</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="o">(</span><span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✓</span> <span class="nc">Property</span> <span class="n">successfully</span> <span class="n">checked</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">check</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span>
     <span class="o">|</span>   <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
     <span class="o">|</span> <span class="o">}</span>
<span class="o">✗</span> <span class="nc">Property</span> <span class="n">failed</span> <span class="k">with</span> <span class="n">counterexample</span><span class="k">:</span> <span class="o">(</span><span class="err">0</span><span class="o">,</span> <span class="err">1</span><span class="o">)</span>
</code></pre></div></div>

<p>Now, if you look closely, you can basically get rid of the <code class="highlighter-rouge">Prop</code> class and define it as</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Prop</span> <span class="o">=</span> <span class="nc">Gen</span><span class="o">[</span><span class="kt">Result</span><span class="o">]</span>
</code></pre></div></div>

<p>If you think about this for a moment, it makes sense: A “property” is really just a thing which feeds on randomness and produces a result.
The only thing left is to define a driver which runs a couple of iterations and gathers the results; in our implementation, that’s the <code class="highlighter-rouge">check</code> function.
I encourage you to spell out the other functions (e.g. <code class="highlighter-rouge">forAll</code>), and you will notice that our <code class="highlighter-rouge">Prop</code> trait is indeed isomorphic to <code class="highlighter-rouge">Gen[Result]</code>.
In practice, QuickCheck uses such a representation (although with some more contraptions).</p>

<h2 id="summary">Summary</h2>

<p>It turns out that it’s not that hard to write a small property-testing library.
I’m going to stop here with the implementation, although there are still some things to explore:</p>

<ul>
  <li>How to <a href="https://github.com/alexarchambault/scalacheck-shapeless">get rid of the boilerplate</a> to generate “boring” data structures?</li>
  <li>How to <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck-Arbitrary.html#t:CoArbitrary">generate functions</a>?</li>
  <li>How to improve usability?</li>
  <li>How to <a href="https://github.com/typelevel/discipline">bundle up a bunch of properties</a>?</li>
  <li>How to <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#test-case-minimisation">show useful counterexamples</a>?</li>
  <li>How to test <a href="https://github.com/rickynils/scalacheck/blob/1.13.2/doc/UserGuide.md#properties">conditional properties</a>?</li>
  <li>How to test the library itself?</li>
  <li>How to make sure that your generators produce reasonable values?</li>
  <li>How to make sure that your generators <a href="https://hackage.haskell.org/package/QuickCheck-2.9.2/docs/Test-QuickCheck.html#v:label">cover a wide range of values</a>?</li>
  <li>How to test <a href="https://github.com/larsrh/polycheck">polymorphic properties</a>?</li>
  <li>…</li>
</ul>

<p>Finally, I’d like to note that there are many more libraries out there than I’ve mentioned here, some of which depart more, some less, from the original Haskell implementation.
They even exist for not-functional languages, e.g. <a href="http://www.javaslang.io/javaslang-docs/#_property_checking">Javaslang</a> for Java or <a href="http://hypothesis.works/">Hypothesis</a> for Python.</p>

<p><em>Correction: In a previous version of this post, I incorrectly stated that ScalaCheck uses a mutable random generator. This is only true up to ScalaCheck 1.12.x. I have updated that section in the post.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Lars Hupel
    
    on Oct 17, 2016</p>

    
  <a href="https://twitter.com/larsr_h" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @larsr_h</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/larsrh" aria-label="Follow @larsrh on GitHub">Follow @larsrh</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
