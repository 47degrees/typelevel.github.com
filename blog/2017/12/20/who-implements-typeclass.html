<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Who implements the typeclass instance?</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Who implements the typeclass instance?</h2>

  <p>The typeclass pattern in Scala invites you to place
implementation-specific knowledge directly in the typeclass instances,
with the interface defined as the typeclass’s abstract interface.</p>

<p>However, GADTs permit a different organization of code. It is even
possible to define a typeclass that seems to do nothing at all, yet
still permits full type-safe typeclass usage.</p>

<p>The possibilities between these two extremes form a design space. If
you wish to practice ad-hoc polymorphism in Scala, this space is well
worth exploring.</p>

<h2 id="a-glorified-overloader">A glorified overloader</h2>

<p>Refactoring a set of overloads into a typeclass is a fine way to get
some free flexibility and dynamism, because expressing overloads as a
typeclass gives you free fixes for common overload problems.</p>

<ol>
  <li>Methods calling the overloaded method do not themselves need to be
overloaded just to avoid suppressing the flexibility of the
overload beneath.  (See <code class="highlighter-rouge">addThree</code> and <code class="highlighter-rouge">zipAdd</code> below for
examples.)</li>
  <li>Return-type overloading works, even in Scala, where it does not
when attempting to write overloads in the Java style, i.e. multiple
methods with the same name.</li>
  <li>Overloads may be defined as recursive type rules, admitting a
combinatorial explosion or even infinite “effective overloads”.</li>
</ol>

<p>Let’s make a quick example of something like a typical overload.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">OverAdd</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
  
  <span class="k">def</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="s">"$x$y"</span>
  
  <span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">l</span> <span class="o">++</span> <span class="n">r</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This mechanically translates to a newly introduced type, some implicit
instances of that type, and a function to let us call <code class="highlighter-rouge">add</code> the same
way we used to.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// typeclasses are often defined with trait, but this is not required
</span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">)</span>

<span class="c1">// easier if all implicits are in this block
</span><span class="k">object</span> <span class="nc">Adder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">addInts</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span>
  
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">addStrings</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span><span class="o">)</span>
    
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Adder</span><span class="o">((</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">++</span> <span class="n">r</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// and to tie it back together
</span><span class="k">def</span> <span class="n">add</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">adder</span><span class="o">.</span><span class="n">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<h2 id="overloaded-wrapping-without-overloading">Overloaded wrapping without overloading</h2>

<p>While a bit more ceremonious, this allows us to write some nice
functions more easily. Here’s a function to add three values.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">addThree</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">m</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">add</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">add</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">addThree</code> supports all three “overloads” of <code class="highlighter-rouge">add</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"ba"</span><span class="o">,</span> <span class="s">"cus"</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abacus</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">addThree</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Vector</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
</code></pre></div></div>

<p>With the overload style, we need three variants of this function, too,
each with the exact same body. The typeclass version need only be
written once, and automatically supports new overloads, that is, new
instances of <code class="highlighter-rouge">Adder</code>.</p>

<p>Same with this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">zipAdd</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">r</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">l</span> <span class="n">zip</span> <span class="n">r</span> <span class="n">map</span> <span class="o">{</span><span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">add</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)}</span>
</code></pre></div></div>

<p>Functions like <code class="highlighter-rouge">addThree</code> and <code class="highlighter-rouge">zipAdd</code> are called <em>derived
combinators</em>. The more that you can do in derived combinators, the
more abstract and orthogonal your program will be.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   +=============+            |   +=============+
   |   derived   |  (open     |   |  primitive  |  (closed
   | combinators |    set)    |   | combinators |      set)
   +=============+            |   +=============+
                              |
   +----------+               |    +----------+
   | addThree |---→---→---→---→---→| Adder    |
   +----------+       calls   |    | -addImpl |    +===========+
    ↑                       |→---→ +----------+    | Instances |
    | +--------+            | |                    +===========+
    | | zipAdd |---→---→---→- |
    | +--------+    calls     |  +------+ +---------+ +-------+
    ↑        ↑                |  | Ints | | Strings | | Vects |
    |   calls|                |  +------+ +---------+ +-------+
    |      +-----+            |      |
    |      | ??? |            |      |
    ↑      +-----+            |      |
    |  (derived combinators          ↓
    |   can derive from each other)  ---→---→---→
    |                                           |
    ↑          -------------------------------  |
    |          To evaluate `addThree(1, 2, 3)`  |
    |          -------------------------------  ↓
    |          1. Fetch `Adder` implicitly      |
    |-←---←---←---←---←---←---←---←---←---←---←-|
               2. Pass to `addThree`
               3. `addThree` uses the abstract interface to
                  invoke the primitive `add` combinator on what,
                  to it, is an abstract type, `A`.
</code></pre></div></div>

<h2 id="infinite-overloads-via-recursion">Infinite overloads via recursion</h2>

<p>Making derived combinators easier to write is very useful, but
typeclasses go further by letting you describe overloading rules that
would be impossible with normal overloading.</p>

<p>Given that I can add <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Int</code> together, I should be able to add
<code class="highlighter-rouge">(Int, Int)</code> and <code class="highlighter-rouge">(Int, Int)</code> to get <code class="highlighter-rouge">(Int, Int)</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">addIntPairs</span><span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="k">case</span> <span class="o">((</span><span class="n">x1</span><span class="o">,</span> <span class="n">x2</span><span class="o">),</span> <span class="o">(</span><span class="n">y1</span><span class="o">,</span> <span class="n">y2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">y1</span><span class="o">,</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">y2</span><span class="o">)}</span>
    
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">add</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">))</span>
<span class="n">res3</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">15</span><span class="o">)</span>
</code></pre></div></div>

<p>But I should also be able to add pairs of <code class="highlighter-rouge">String</code>. And <code class="highlighter-rouge">(Int,
String)</code> pairs. And <code class="highlighter-rouge">(String, Vector[Boolean])</code> pairs. And pairs of
pairs of pairs.</p>

<p>Typeclasses let you declare newly supported types recursively, with an
implicit argument list to the <code class="highlighter-rouge">implicit def</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">addPairs</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Adder</span>, <span class="kt">B:</span> <span class="kt">Adder</span><span class="o">]</span>
    <span class="k">:</span> <span class="kt">Adder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span>
  <span class="nc">Adder</span><span class="o">{</span><span class="k">case</span> <span class="o">((</span><span class="n">a1</span><span class="o">,</span> <span class="n">b1</span><span class="o">),</span> <span class="o">(</span><span class="n">a2</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="o">(</span><span class="n">add</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">),</span> <span class="n">add</span><span class="o">(</span><span class="n">b1</span><span class="o">,</span> <span class="n">b2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="surely-this-must-be-going-somewhere-new">Surely this must be going somewhere new</h2>

<p>If you’re familiar with type classes, all this must be old hat. But
this time, we’re going to expand the boundaries of the typeclass
design space, by exploiting <em>GADT pattern matching</em>.</p>

<p>We could have designed the <code class="highlighter-rouge">Adder</code> type class to include <code class="highlighter-rouge">addThree</code> as
a primitive combinator, and implemented it afresh for each of the four
instances we’ve defined so far, as well as any future instances
someone might define. Thinking orthogonally, however, shows us that
there’s a more primitive concept which strictly generalizes it: if we
primitively define a two-value adder, we can use it to add three
items, simply by using it twice.</p>

<p>This has a direct impact on how we structure the functions related to
<code class="highlighter-rouge">Adder</code>. The primitives must be split up, their separate
implementations appearing directly in the implicit instances. Derived
combinators may occur anywhere that is convenient to us: outside the
typeclass for full flexibility of location, or within the typeclass
for possible overrides for performance.</p>

<p>But how much of the primitive implementations must occur in the
instances, really?</p>

<h2 id="empty-tags-as-instances">Empty tags as instances</h2>

<p>There is a progression of design refinements here.</p>

<ol>
  <li>Ad hoc overloads, Java-style, impossible to abstract over.</li>
  <li>Flip into a typeclass.</li>
  <li>Refine the primitive/derived distinction to minimize code in
instances.</li>
</ol>

<p>For some typeclasses, <em>no</em> code needs to be put in the instances. For
example, if we want to support only <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">String</code>, and <code class="highlighter-rouge">Vector</code>,
here is a perfectly sensible typeclass definition.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">object</span> <span class="nc">ISAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">AddVects</span><span class="o">()</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If the instances cannot add values of the types indicated by the type
parameters, surely that code must exist somewhere! And it has a place,
in the definition of <code class="highlighter-rouge">add</code>.</p>

<p>If you recall, this method merely called <code class="highlighter-rouge">addImpl</code> on the typeclass
instance before. Now there is no such thing; the instances are empty.</p>

<p>Well, they are not quite empty; they contain a type.  So we can define
<code class="highlighter-rouge">add</code>, with complete type safety, as follows.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">isadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddStrings</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
    <span class="k">case</span> <span class="nc">ISAdder</span><span class="o">.</span><span class="nc">AddVects</span><span class="o">()</span> <span class="k">=&gt;</span>
      <span class="n">x</span> <span class="o">++</span> <span class="n">y</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>More specifically, they contain a runtime tag, which allows
information about the type of <code class="highlighter-rouge">A</code> to be extracted with a pattern
match. For example, determining that <code class="highlighter-rouge">adder</code> is <code class="highlighter-rouge">AddInts</code> reveals that
<code class="highlighter-rouge">A = Int</code>, because that’s what the <code class="highlighter-rouge">extends</code> clause says.  This is
<em>GADT pattern matching</em>.</p>

<p>The <code class="highlighter-rouge">Vector</code> case is a little tricky here, because we can only
determine that <code class="highlighter-rouge">A</code> is <code class="highlighter-rouge">Vector[e]</code> <em>for some unknown e</em>, but that’s
enough information to invoke <code class="highlighter-rouge">++</code> and get a result also of <code class="highlighter-rouge">Vector[e]</code>
for the same <code class="highlighter-rouge">e</code>.</p>

<p>You can see this in action by using a <a href="https://groups.google.com/d/msg/scala-user/JlCsy48poIU/DjsQDnzeZboJ">variable type
pattern</a>
to assign the name <code class="highlighter-rouge">e</code> (a lowercase type parameter is required for
this usage), so you can refer to it in types.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">case</span> <span class="k">_:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
      <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
</code></pre></div></div>

<h2 id="the-lowercase-e-names-a-gadt-skolem">The lowercase <code class="highlighter-rouge">e</code> names a GADT skolem</h2>

<p>In the <code class="highlighter-rouge">AddVects[e]</code> pattern immediately above, <code class="highlighter-rouge">e</code> is a <em>variable
type pattern</em>. This is a type that exists only in the scope of the
<code class="highlighter-rouge">case</code>.</p>

<p>It’s <em>existential</em> because we don’t know what it is, only that it is
<em>some type</em> and we don’t get to pick here what that is. In this way,
it is no different from a type parameter’s treatment by the
implementation, which is
<a href="/blog/2016/01/28/existential-inside.html">existential on the inside</a>.</p>

<p>It’s a <em>GADT skolem</em> because it was bound by the pattern matching
mechanism to a “fresh” type, unequal to any other. Recall the way
<code class="highlighter-rouge">AddVects</code> was defined:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">AddVects</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">E</span><span class="o">]]</span>
</code></pre></div></div>

<p>Matching <code class="highlighter-rouge">ISAdder</code> with <code class="highlighter-rouge">AddVects</code> doesn’t tell us anything about
bounds on the type passed to <code class="highlighter-rouge">AddVects</code> at construction time. This
isn’t true of all
<a href="/blog/2016/09/19/variance-phantom.html#a-gadt-skolem">GADT skolems</a>,
but is only natural for this one.</p>

<p><code class="highlighter-rouge">scalac</code> will create this GADT skolem <em>regardless of whether we give
it a name</em>. In the pattern <code class="highlighter-rouge">case AddVects()</code>, it’s still known that
<code class="highlighter-rouge">A = Vector[e]</code> for some <code class="highlighter-rouge">e</code>; the only difference is that you haven’t
bound the <code class="highlighter-rouge">e</code> name, so you can’t actually refer to this <em>unspeakable</em>
type.</p>

<p>Usually, you do not need to assign names such as <code class="highlighter-rouge">e</code> to such types;
<code class="highlighter-rouge">_</code> is sufficient.  However, if you have problems getting <code class="highlighter-rouge">scalac</code> to
apply all the type equalities it ought to know about, a good first
step is to assign names to any skolems and try type
ascriptions. You’ll need a variable type pattern in other situations
that don’t infer, too. By contrast, with the <code class="highlighter-rouge">e</code> name bound, we can
confirm that <code class="highlighter-rouge">x: Vector[e]</code> in the above example, and <code class="highlighter-rouge">y</code> is
sufficiently well-typed for the whole expression to type-check.</p>

<h2 id="porting-addpairs-and-other-recursive-cases">Porting <code class="highlighter-rouge">addPairs</code> and other recursive cases</h2>

<p>Suppose we add support for pairs to <code class="highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AddPairs</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span>
    <span class="k">val</span> <span class="n">fst</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span>
    <span class="k">val</span> <span class="n">snd</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">ISAdder</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
</code></pre></div></div>

<p>This <em>should</em> permit us to pattern-match in <code class="highlighter-rouge">isadd</code> to make complex
determinations about the <code class="highlighter-rouge">A</code> type given to <code class="highlighter-rouge">isadd</code>. This <em>ought to be</em>
a big win for GADT-style typeclasses, allowing “short-circuiting”
patterns that work in an obvious way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// this pattern means A=(Int, String)
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>

<span class="c1">// this pattern means A=(ea, Vector[eb])
// where ea and eb are GADT skolems
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>

<span class="c1">// here, A=(ea, eb) (again, GADT skolems)
// calling `isadd` recursively is the most
// straightforward implementation
</span><span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">y</span>
  <span class="o">(</span><span class="n">isadd</span><span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">f2</span><span class="o">)(</span><span class="n">fst</span><span class="o">),</span> <span class="n">isadd</span><span class="o">(</span><span class="n">s1</span><span class="o">,</span> <span class="n">s2</span><span class="o">)(</span><span class="n">snd</span><span class="o">))</span>
</code></pre></div></div>

<p>The final <code class="highlighter-rouge">case</code>’s body is fine. <code class="highlighter-rouge">scalac</code> effectively introduces
skolems <code class="highlighter-rouge">ea</code> and <code class="highlighter-rouge">eb</code> so that <code class="highlighter-rouge">A = (ea, eb)</code>, <code class="highlighter-rouge">fst: Adder[ea]</code>, and so
on, and everything lines up nicely. We are not so lucky with the other
cases.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddInts.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                    <span class="o">^</span>
<span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">76</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>

 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddStrs.type</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
                             <span class="o">^</span>
<span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">79</span><span class="kt">:</span> <span class="kt">pattern</span> <span class="k">type</span> <span class="kt">is</span> <span class="kt">incompatible</span> <span class="kt">with</span> <span class="kt">expected</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">ISAdder.AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span>
      <span class="k">case</span> <span class="nc">AddPairs</span><span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
                            <span class="o">^</span>
</code></pre></div></div>

<p>This is nonsensical; the underlying code is sound, we just have to go
the long way around so that <code class="highlighter-rouge">scalac</code> doesn’t get confused. Instead of
the above form, you must assign names to the <code class="highlighter-rouge">AddPairs</code> skolems as we
described above, and do a sub-pattern-match.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f1</span><span class="o">,</span> <span class="n">s1</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">f2</span><span class="o">,</span> <span class="n">s2</span><span class="o">)</span> <span class="k">=</span> <span class="n">y</span>
  <span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="n">fst</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="n">snd</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="nc">AddInts</span><span class="o">,</span> <span class="nc">AddStrs</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">eb</span><span class="o">])</span> <span class="k">=&gt;</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">fst</span><span class="o">,</span> <span class="n">snd</span><span class="o">)</span> <span class="k">=&gt;</span>
</code></pre></div></div>

<p>Note that we had to give up on the <code class="highlighter-rouge">AddPairs</code> pattern entirely,
because</p>

<ol>
  <li>More complex situations require type ascription.</li>
  <li>You cannot ascribe with skolems unless you’ve bound the skolems to
names with variable type patterns.</li>
  <li>You can’t use variable type patterns with the structural
“ADT-style” patterns; you must instead use inelegant and
inconvenient [non-variable] type patterns. (This may be
<a href="https://github.com/typelevel/scala/blob/typelevel-readme/notes/typelevel-4.md#type-arguments-on-patterns-pull5774-paulp">improved in Typelevel Scala 4</a>.)</li>
</ol>

<p>Yet this remains entirely up to shortcomings in the current pattern
matcher implementation. An improved pattern matcher could make the
nice version work, safely and soundly.</p>

<p>As such, I don’t want these shortcomings to discourage you from trying
out the pure type-tagging, “GADT-style” typeclasses. It is simply
nicer for many applications, and you aren’t going to code yourself
into a hole with them, because should you wind up in the buggy
territory we’ve been exploring, there’s still a way out.</p>

<h2 id="same-typeclass-new-primitive-combinators">Same typeclass, new “primitive” combinators</h2>

<p>“Empty” typeclasses like <code class="highlighter-rouge">ISAdder</code> contain no implementations of
primitive combinators, only “tags”. As such, they are in a sense the
purest form of “typeclass”; <em>to classify types</em> is the beginning and
end of what they do!</p>

<p>Every type that is a member of the “class of types” <code class="highlighter-rouge">ISAdder</code> is
either</p>

<ol>
  <li>the type <code class="highlighter-rouge">Int</code>,</li>
  <li>the type <code class="highlighter-rouge">String</code>,</li>
  <li>a type <code class="highlighter-rouge">Vector[e]</code>, where <code class="highlighter-rouge">e</code> is any type, or</li>
  <li>a type <code class="highlighter-rouge">(x, y)</code> where <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> are types that are <em>also</em> in the
<code class="highlighter-rouge">ISAdder</code> class.</li>
</ol>

<p>This is the end of <code class="highlighter-rouge">ISAdder</code>’s definition; in particular, there is
nothing here about “adding two values to get a value”. All that
is said is what types are in the class!</p>

<p>Given this ‘undefinedness’, if we have another function we want to
write over the exact same class-of-types, we can just write it without
making any changes to <code class="highlighter-rouge">ISAdder</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">backwards</span><span class="o">[</span><span class="kt">X</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">X</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISAdder</span><span class="o">[</span><span class="kt">X</span><span class="o">])</span><span class="k">:</span> <span class="kt">X</span> <span class="o">=</span> <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="n">x</span>
  <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
  <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
  <span class="k">case</span> <span class="n">p</span><span class="k">:</span> <span class="kt">AddPairs</span><span class="o">[</span><span class="kt">ea</span>, <span class="kt">eb</span><span class="o">]</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">ea</span><span class="o">,</span> <span class="kt">eb</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
    <span class="o">(</span><span class="n">backwards</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="n">p</span><span class="o">.</span><span class="n">fst</span><span class="o">),</span> <span class="n">backwards</span><span class="o">(</span><span class="n">b</span><span class="o">)(</span><span class="n">p</span><span class="o">.</span><span class="n">snd</span><span class="o">))</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Set aside the question of whether the class of “backwards-able” types
ought to remain in lockstep with the class of “addable”
types. Supposing that it <em>should</em>, the class need be defined only
once.</p>

<p>More practically speaking, if you expose the subclasses of a typeclass
to users of your library, they can define primitives “in lockstep”,
too.  The line between primitive and derived combinators is also
blurred: a would-be derived combinator can pattern-match on the
typeclass to supply special cases for improved performance, becoming
“semi-primitive” in the process.  You decide whether these are good
things or not.</p>

<h2 id="hybrid-clopen-typeclasses">Hybrid “clopen” typeclasses</h2>

<p>Pattern-matching typeclass GADTs is subject to the same exhaustiveness
concerns and compiler warnings as pattern-matching ordinary ADTs. If
you eliminate a <code class="highlighter-rouge">case</code> from <code class="highlighter-rouge">def isadd</code>, you’ll see something like</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">....</span><span class="n">scala</span><span class="k">:</span><span class="err">57</span><span class="kt">:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
<span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">AddInts</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
    <span class="o">^</span>
</code></pre></div></div>

<p>We could unseal <code class="highlighter-rouge">ISAdder</code>, which would eliminate the warning, but
wouldn’t really solve anything. The function would still crash upon
encountering the missing case.</p>

<p>Pattern matches of unsealed hierarchies typically include a “fallback”
case, code used when none of the “special” cases match. However, for
pure typeclasses like <code class="highlighter-rouge">ISAdder</code>, this strategy is a dead end
too. Consider a hypothetical fallback case.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">???</span>
</code></pre></div></div>

<p>Each of the other patterns in <code class="highlighter-rouge">isadd</code>, by their success, taught us
something useful about the <code class="highlighter-rouge">A</code> type parameter. For example, <code class="highlighter-rouge">case
AddInts</code> tells us that <code class="highlighter-rouge">A = Int</code>, and accordingly <code class="highlighter-rouge">x: Int</code> and <code class="highlighter-rouge">y:
Int</code>. It also meant that the expected result type of that block is
also <code class="highlighter-rouge">Int</code>. That’s plenty of information to actually implement
“adding”.</p>

<p>By contrast, <code class="highlighter-rouge">case _</code> tells us <em>nothing</em> about the <code class="highlighter-rouge">A</code> type. We don’t
know anything new about <code class="highlighter-rouge">x</code>, <code class="highlighter-rouge">y</code>, or the type of value we ought to
return. All we can do is return either <code class="highlighter-rouge">x</code> or <code class="highlighter-rouge">y</code> without further
combination; while this is a sort of “adding” <a href="https://hackage.haskell.org/package/base-4.10.1.0/docs/Data-Monoid.html#t:First">in abstract
algebra</a>,
there’s a good chance it’s not really what the caller was expecting.</p>

<p>Instead, we can reformulate a closed typeclass like <code class="highlighter-rouge">ISAdder</code> with one
extension point, where the typeclass is specially encoded in the usual
“embedded implementation” style. It’s closed and open, so
<a href="https://mail.haskell.org/pipermail/haskell-cafe/2014-April/113373.html">“clopen”</a>.</p>

<h2 id="sealed-doesnt-seal-subclasses"><code class="highlighter-rouge">sealed</code> doesn’t seal subclasses</h2>

<p>Our GADT typeclass instances work by embedding type information within
the instances, to be rediscovered at runtime. To support open
extension, we need a data case that contains <em>functions</em> instead of
types. We know how to encode that, because that is how standard,
non-GADT typeclasses work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

<span class="nc">trait</span> <span class="nc">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">addImpl</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">ISOAdder</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddInts</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">implicit</span> <span class="k">object</span> <span class="nc">AddStrs</span> <span class="k">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  
  <span class="k">final</span> <span class="k">class</span> <span class="nc">AddVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">addVects</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddVects</span>
    
  <span class="k">def</span> <span class="n">isoadd</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">adder</span><span class="k">:</span> <span class="kt">ISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">adder</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">AddInts</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">case</span> <span class="nc">AddStrs</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="s">"$x$y"</span>
      <span class="k">case</span> <span class="k">_:</span> <span class="kt">AddVects</span><span class="o">[</span><span class="kt">e</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">e</span><span class="o">])</span> <span class="o">++</span> <span class="n">y</span>
      <span class="c1">// NB: no unchecked warning here, which makes sense
</span>      <span class="k">case</span> <span class="n">e</span><span class="k">:</span> <span class="kt">ExtISOAdder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span>
        <span class="n">e</span><span class="o">.</span><span class="n">addImpl</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>By sealing <code class="highlighter-rouge">ISOAdder</code>, we ensure that the pattern match in <code class="highlighter-rouge">isoadd</code>
remains exhaustive. However, one of those cases, <code class="highlighter-rouge">ExtISOAdder</code>, admits
new subclasses, itself! This is fine because no matter how many
subclasses of <code class="highlighter-rouge">ExtISOAdder</code> we make, they’ll still match the last
pattern of <code class="highlighter-rouge">isoadd</code>.</p>

<p>We could also define <code class="highlighter-rouge">ExtISOAdder</code> as a <code class="highlighter-rouge">final case class</code>. The point
is that you can make this “extension point” in your otherwise-closed
typeclass using whatever style you like.</p>

<p>One caveat, though: “clopen” typeclasses cannot have arbitrary new
primitive combinators added to them. They are like ordinary open
typeclasses in that regard. Consider a version of <code class="highlighter-rouge">backwards</code> for
<code class="highlighter-rouge">ISOAdder</code>: what you could do in the <code class="highlighter-rouge">ExtISOAdder</code> case?</p>

<h2 id="whoever-you-like">Whoever you like</h2>

<p>With type parameters vs. members, you can get pretty far with
<a href="/blog/2015/07/13/type-members-parameters.html#when-is-existential-ok">the “rule of thumb”</a>.
Beyond that, even bugs in <code class="highlighter-rouge">scalac</code> typechecking can guide you to the
“right” choice.</p>

<p>There is no similar rule for this design space. It might seem that
typeclass newcomers might have an easier time with the OO-style
“unimplemented method” signposts in the open style, but I have also
seen them lament the loss of flexibility that would be provided by the
GADT style.</p>

<p>Likewise, as an advanced practitioner, your heart will be rent by the
tug-of-war between the boilerplate of the open style and the
pattern-matcher’s finickiness with the GADT style. You may then be
tempted to adopt the hybrid ‘clopen’ style, but this, too, is too
often a form of design excess.</p>

<p>Given all that, the only help I can offer, aside from describing the
design space above, is “pick whichever you like”. You know your
program; if you are not sure which will be nicer, try both!</p>

<p><em>This article was tested with Scala 2.12.4.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Dec 20, 2017</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
