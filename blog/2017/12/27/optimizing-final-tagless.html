<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Optimizing Tagless Final – Saying farewell to Free</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Optimizing Tagless Final – Saying farewell to Free</h2>

  <p>The Tagless Final encoding has gained some steam recently, with some people hailing 2017 as the year of Tagless Final.
Being conceptually similar to the Free Monad, different comparisons have been brought up and the one trade-off that always comes up is the lack or the difficulty of inspection of tagless final programs and in fact, I couldn’t find a single example on the web.
This seems to make sense, as programs in the tagless final encoding aren’t values, like programs expressed in terms of free structures. 
However, in this blog post, I’d like to dispell the myth that inspecting and optimizing tagless final programs is more difficult than using <code class="highlighter-rouge">Free</code>.</p>

<p>Without further ado, let’s get into it, starting with our example algebra, a very simple key-value store:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>To get the easiest example out of the way, here’s how to achieve parallelism in a tagless final program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats._</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>

<span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">FlatMap</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">K</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">M</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">P</span><span class="k">:</span> <span class="kt">Parallel</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">F</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">K</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"A"</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">x</span> <span class="k">&lt;-</span> <span class="o">(</span><span class="n">K</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"B"</span><span class="o">),</span> <span class="n">K</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"C"</span><span class="o">)).</span><span class="n">parMapN</span><span class="o">(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
    <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">K</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"X"</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"-"</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">x</span>
</code></pre></div></div>

<p>This programs makes use of the <code class="highlighter-rouge">cats.Parallel</code> type class, that allows us to make use of the <code class="highlighter-rouge">parMapN</code> combinator to use independent computations with a related <code class="highlighter-rouge">Applicative</code> type. This is already much simpler than doing the same thing with <code class="highlighter-rouge">Free</code> and <code class="highlighter-rouge">FreeApplicative</code>. For more info on <code class="highlighter-rouge">Parallel</code> check out the cats docs <a href="https://typelevel.org/cats/typeclasses/parallel.html">here</a>.</p>

<p>However this is kind of like cheating, we’re not really inspecting the structure of our program at all, so let’s look at an example where we actually have access to the structure to do optimizations with.</p>

<p>Let’s say we have the following program:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="s">"42"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
      <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>
</code></pre></div></div>

<p>Not a very exciting program, but it has some definite optimization potential.
Right now, if our KVStore implementation is an asynchronous one with a network boundary, our program will make 4 network requests sequentially if interpreted with the standard <code class="highlighter-rouge">Apply</code> instance of something like <code class="highlighter-rouge">cats.effect.IO</code>.
We also have a duplicate request with the <code class="highlighter-rouge">"Cats"</code>-key.</p>

<p>So let’s look at what we could potentially do about this.
The first thing we should do, is extract the static information.
The easiest way to do so, is to interpret it into something we can use using a <code class="highlighter-rouge">Monoid</code>.
This is essentially equivalent to the <code class="highlighter-rouge">analyze</code> function commonly found on <code class="highlighter-rouge">FreeApplicative</code>.</p>

<p>Getting this done, is actually quite simple, as we can use <code class="highlighter-rouge">cats.Const</code> as our <code class="highlighter-rouge">Applicative</code> data type, whenever the lefthand side of <code class="highlighter-rouge">Const</code> is a <code class="highlighter-rouge">Monoid</code>. 
I.e. if <code class="highlighter-rouge">M</code> has a <code class="highlighter-rouge">Monoid</code> instance, <code class="highlighter-rouge">Const[M, A]</code> has an <code class="highlighter-rouge">Applicative</code> instance.
You can read more about <code class="highlighter-rouge">Const</code> <a href="https://typelevel.org/cats/datatypes/const.html">here</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">analysisInterpreter</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[(</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">])</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">),</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">((</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="nc">Map</span><span class="o">(</span><span class="n">key</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">)))</span>
  <span class="o">}</span>

<span class="n">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>
<span class="c1">// res0: (Set[String], Map[String,String]) = (Set(Cats, Dogs),Map(Mice -&gt; 42))
</span>
</code></pre></div></div>

<p>By using a Tuple of <code class="highlighter-rouge">Set</code> and <code class="highlighter-rouge">Map</code> as our <code class="highlighter-rouge">Monoid</code>, we now get all the unique keys for our <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">put</code> operations.
Next, we can use this information to recreate our program in an optimized way.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>

  <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And we got our first very simple optimization.
It’s not much, but we can imagine the power of this technique.
For example, if we were using something like <code class="highlighter-rouge">GraphQL</code>, we could sum all of our <code class="highlighter-rouge">get</code> requests into one large request, so only one network roundtrip is made.
We could imagine similar things for other use cases, e.g. if we’re querying a bunch of team members that all belong to the same team, it might make sense to just make one request to all the team’s members instead of requesting them all individually.</p>

<p>Other more complex optimizations could involve writing a new interpreter with the information we gained from our static analysis.
One could also precompute some of the computations and then create a new interpreter with those computations in mind.</p>

<p>Embedding our Applicative program inside a larger monadic program is also trivial:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">analysisInterpreter</span><span class="o">).</span><span class="n">getConst</span>

  <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> 
    <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">flatten</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="n">optimizedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">))(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Here we refactor our <code class="highlighter-rouge">optimizedProgram</code> to take an extra parameter <code class="highlighter-rouge">mouse</code>. Then in our larger <code class="highlighter-rouge">monadicProgram</code>, we perform a <code class="highlighter-rouge">get</code> operation and then apply its result to <code class="highlighter-rouge">optimizedProgram</code>.</p>

<p>So now we have a way to optimize our one specific program, next we should see if we can introduce some abstraction.
Sadly Scala lacks Rank-N types, which makes this a bit difficult as we’ll see.</p>

<p>First we’ll have to look at the shape of a generic program, they usually are functions from an interpreter <code class="highlighter-rouge">Algebra[F]</code> to an expression inside the type constructor <code class="highlighter-rouge">F</code>, such as <code class="highlighter-rouge">F[A]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</code></pre></div></div>

<p>The problem of Rank-N types becomes apparent when we want to write a function where we interpret our program with two different interpreters, as we did before when interpreting into <code class="highlighter-rouge">Const</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>

    <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span> <span class="c1">// error: type mismatch;
</span>    <span class="c1">// found   : extract.type (with underlying type Alg[[β$0$]cats.data.Const[M,β$0$]])
</span>    <span class="c1">// required: Alg[F]
</span>
    <span class="n">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>
<p>So, because of the lack of Rank-N types, this simple definition for our program is not enough to say that our program works for ALL type constructors <code class="highlighter-rouge">F[_]: Applicative</code>.</p>

<p>Fortunately there is a workaround, albeit requiring a bit more boilerplate:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span> <span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">M:</span> <span class="kt">Monoid</span><span class="o">]</span>
  <span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span>
  <span class="o">(</span><span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]])</span>
  <span class="o">(</span><span class="n">restructure</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interp</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span>

    <span class="n">restructure</span><span class="o">(</span><span class="n">m</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>And now it should compile without a problem.
Now we should be able to express our original optimization with this new generic approach:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">program</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Dogs"</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">,</span> <span class="n">mouse</span><span class="o">),</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Cats"</span><span class="o">))</span>
    <span class="o">.</span><span class="n">mapN</span><span class="o">((</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">t</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">f</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">).</span><span class="n">flatten</span><span class="o">)</span>

<span class="k">def</span> <span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Program</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">alg</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="n">program</span><span class="o">(</span><span class="n">mouse</span><span class="o">)(</span><span class="n">alg</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">optimizedProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span><span class="o">](</span><span class="n">mouse</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> 
  <span class="n">optimize</span><span class="o">(</span><span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">))(</span><span class="n">analysisInterpreter</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">gets</span><span class="o">,</span> <span class="n">puts</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">puts</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span> <span class="o">*&gt;</span> <span class="n">gets</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">)</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>So far so good, we’ve managed to write a function to generically optimize tagless final programs.
However, one of the main advantages of tagless final is that implementation and logic should be separate concerns.
With what we have right now, we’re violating the separation, by mixing the optimization part with the program logic part.
Our optimization should be handled by the interpreter, just as the sequencing of individual steps of a monadic program is the job of the target <code class="highlighter-rouge">Monad</code> instance.</p>

<p>One way to go forward, is to create a typeclass that requires certain algebras to be optimizable.
This typeclass could be written using the generic function we wrote before, so let’s see what we can come up with:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span>

  <span class="k">def</span> <span class="n">monoidM</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">monadF</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">extract</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">M</span>, <span class="kt">?</span><span class="o">]]</span>
  <span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">M</span><span class="o">,</span> <span class="n">interpreter</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]]</span>

  <span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">interpreter</span> <span class="k">=&gt;</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">M</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">M</span><span class="o">]</span> <span class="k">=</span> <span class="n">monoidM</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">F</span><span class="k">:</span> <span class="kt">Monad</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="n">monadF</span>

    <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">M</span> <span class="o">=</span> <span class="n">p</span><span class="o">(</span><span class="n">extract</span><span class="o">).</span><span class="n">getConst</span>

    <span class="n">rebuild</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">interpreter</span><span class="o">).</span><span class="n">flatMap</span><span class="o">(</span><span class="n">interp</span> <span class="k">=&gt;</span> <span class="n">p</span><span class="o">(</span><span class="n">interp</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This might look a bit daunting at first, but we’ll go through it bit by bit.
First we define our type class <code class="highlighter-rouge">Optimizer</code> parameterized by an algebra <code class="highlighter-rouge">Alg[_[_]]</code> and a type constructor <code class="highlighter-rouge">F[_]</code>.
This means we can define different optimizations for different algebras and different target types.
For example, we might want a different optimization for a production <code class="highlighter-rouge">Optimizer[KVStore, EitherT[Task, E, ?]]</code> and a testing <code class="highlighter-rouge">Optimizer[KVStore, Id]</code>.
Next, for our interpreter we need a <code class="highlighter-rouge">Monoid M</code> for our static analysis, however we don’t to parameterize our <code class="highlighter-rouge">Optimizer</code> with an extra type parameter, since the actual type of <code class="highlighter-rouge">M</code> isn’t necessary for the API, so we use an abstract type member instead.</p>

<p>Next we need actual <code class="highlighter-rouge">Monoid</code> and <code class="highlighter-rouge">Monad</code> instances for <code class="highlighter-rouge">F[_]</code> and <code class="highlighter-rouge">M</code> respectively.
The other two functions should seem familiar, the <code class="highlighter-rouge">extract</code> function defines an interpreter to get an <code class="highlighter-rouge">M</code> out of our program.
The <code class="highlighter-rouge">rebuild</code> function takes that value of <code class="highlighter-rouge">M</code> and the interpreter and produces an <code class="highlighter-rouge">F[Alg[F]]</code>, which can be understood as an <code class="highlighter-rouge">F</code> of an interpreter.
This means that we can statically analyze a program and then use the result of that to create a new optimized interpreter and this is exactly what the <code class="highlighter-rouge">optimize</code> function does.
This is also why we needed the <code class="highlighter-rouge">Monad</code> constraint on <code class="highlighter-rouge">F</code>, we could also get away with returning just a new interpreter <code class="highlighter-rouge">Alg[F]</code> from the <code class="highlighter-rouge">rebuild</code> method and get away with an <code class="highlighter-rouge">Applicative</code> constraint, but we can do more different things this way.</p>

<p>We’ll also define some quick syntax sugar for this type class to make using it a tiny bit more ergonomic.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">class</span> <span class="nc">OptimizerOps</span><span class="o">[</span><span class="kt">Alg</span><span class="o">[</span><span class="k">_</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>, <span class="kt">A</span><span class="o">](</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Program</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">optimize</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">interp</span><span class="k">:</span> <span class="kt">Alg</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">Alg</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="n">O</span><span class="o">.</span><span class="n">optimize</span><span class="o">(</span><span class="n">value</span><span class="o">)(</span><span class="n">interp</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Let’s see what our program would look like with this new functionality:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">monadicProgram</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span><span class="n">F</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">F</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">O</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">F</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">mouse</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="s">"Mice"</span><span class="o">)</span>
  <span class="n">list</span> <span class="k">&lt;-</span> <span class="n">wrappedProgram</span><span class="o">(</span><span class="n">mouse</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"64"</span><span class="o">)).</span><span class="n">optimize</span><span class="o">(</span><span class="n">F</span><span class="o">)</span>
  <span class="k">_</span> <span class="k">&lt;-</span> <span class="n">F</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="s">"Birds"</span><span class="o">,</span> <span class="n">list</span><span class="o">.</span><span class="n">headOption</span><span class="o">.</span><span class="n">getOrElse</span><span class="o">(</span><span class="s">"128"</span><span class="o">))</span>
<span class="o">}</span> <span class="k">yield</span> <span class="o">()</span>
</code></pre></div></div>

<p>Looking good so far, now all we need to run this is an actual instance of <code class="highlighter-rouge">Optimizer</code>.
We’ll use a Monix <code class="highlighter-rouge">Task</code> for this and for simplicity our new optimization will only look at the <code class="highlighter-rouge">get</code> operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">kvStoreTaskOptimizer</span><span class="k">:</span> <span class="kt">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Optimizer</span><span class="o">[</span><span class="kt">KVStore</span>, <span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">M</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">monoidM</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="n">monadF</span> <span class="k">=</span> <span class="n">implicitly</span>

  <span class="k">def</span> <span class="n">extract</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">?</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Set</span><span class="o">(</span><span class="n">key</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Const</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Const</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">rebuild</span><span class="o">(</span><span class="n">gs</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">interp</span><span class="k">:</span> <span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">])</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]]</span> <span class="k">=</span>
    <span class="n">gs</span><span class="o">.</span><span class="n">toList</span>
      <span class="o">.</span><span class="n">parTraverse</span><span class="o">(</span><span class="n">key</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">s</span><span class="o">))))</span>
      <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">collect</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">v</span> <span class="o">}.</span><span class="n">toMap</span><span class="o">)</span>
      <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
        <span class="k">new</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
          <span class="k">override</span> <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="n">a</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span>
            <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">interp</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span>
          <span class="o">}</span>

          <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
        <span class="o">}</span>
      <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>Our <code class="highlighter-rouge">Monoid</code> type is just a simple <code class="highlighter-rouge">Set[String]</code> here, as the <code class="highlighter-rouge">extract</code> function will only extract the <code class="highlighter-rouge">get</code> operations inside the <code class="highlighter-rouge">Set</code>.
Then with the <code class="highlighter-rouge">rebuild</code> we build up our new interpreter.
First we want to precompute all the values of the program.
To do so, we just run all the operations in parallel and put them into a <code class="highlighter-rouge">Map</code>, while discarding values where the <code class="highlighter-rouge">get</code> operation returned <code class="highlighter-rouge">None</code>.
Now when we have that precomputed <code class="highlighter-rouge">Map</code>, we’ll create a new interpreter with it, that will check if the key given to <code class="highlighter-rouge">get</code> operation is in the precomputed <code class="highlighter-rouge">Map</code> instead of performing an actual request.
We can then lift the value into a <code class="highlighter-rouge">Task[Option[String]]</code>.
For all the <code class="highlighter-rouge">put</code> operations, we’ll simply run the interpreter.</p>

<p>Now we should have a great optimizer for <code class="highlighter-rouge">KVStore</code> programs interpreted into a <code class="highlighter-rouge">Task</code>.
Let’s see how we did by interpreting into a silly implementation that only prints whenever you use one of the operations:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">TestInterpreter</span> <span class="k">extends</span> <span class="nc">KVStore</span><span class="o">[</span><span class="kt">Task</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>

    <span class="n">println</span><span class="o">(</span><span class="s">"Hit network for "</span> <span class="o">+</span> <span class="n">key</span><span class="o">)</span>

    <span class="nc">Option</span><span class="o">(</span><span class="n">key</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">put</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Task</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Task</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Put something: "</span> <span class="o">+</span> <span class="n">a</span><span class="o">)</span>

    <span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now let’s run our program with this interpreter and the optimizations!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">monadicProgram</span><span class="o">(</span><span class="nc">TestInterpreter</span><span class="o">).</span><span class="n">runAsync</span>
<span class="c1">// Hit network for Mice
// Hit network for Cats
// Hit network for Dogs
// Put something: Mice!
// Put something: Cats!
</span></code></pre></div></div>

<p>And it works, we’ve now got a principled way to write programs that can then be potentially optimized.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Designing a way to completely separate the problem description from the actual problem solution is fairly difficult. The tagless final encoding allows us one such fairly simple way.
Using the technique described in this blog post, we should be able to have even more control over the problem solution by inspecting the structure of our program statically.
We’ve seen a few roadblocks along the way, such as the lack of Rank-N types in Scala, but we might be able to come up with a macro for that in the future, making it even more ergonomic.
Another thing we haven’t covered here, are programs with multiple algebras, which is quite a bit more complex as you can surely imagine, maybe that will be the topic of a follow up blog post.</p>

<p>The code is published <a href="https://github.com/LukaJCB/sphynx">right here</a>, but might still change after getting a feeling for which API feels best.</p>

<p>What kind of problems and techniques would you like to see with regards to tagless final?
Would love to hear from you in the comments!</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/lukajacobowitz.jpg" />
      
      <p>by Luka Jacobowitz
    
    on Dec 27, 2017</p>

    
  <a href="https://twitter.com/LukaJacobowitz" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @LukaJacobowitz</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/LukaJCB" aria-label="Follow @LukaJCB on GitHub">Follow @LukaJCB</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
