<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Law Enforcement using Discipline</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Law Enforcement using Discipline</h2>

  <p>Some nine or ten months ago, <a href="http://github.com/non/spire">Spire</a>’s project structure underwent a major reorganization.
Simultaneously, the <a href="http://www.scalacheck.org/">Scalacheck</a> bindings were refactored, completely overhauling the law-checking infrastructure.</p>

<h2 id="requirements">Requirements</h2>

<p>The main goal was to make it easy to check that instances of Spire’s type classes adhere to the set of algebraic laws of the respective type classes.
<a href="https://github.com/scalaz/scalaz">Scalaz</a> also has such an infrastructure, so why not take that one?
The problem is that in Spire, the hierarchy of type classes is a little bit more complex:</p>

<p>On the one hand, there is a “generic” tower of type classes including <code class="highlighter-rouge">Semigroup</code>, <code class="highlighter-rouge">Monoid</code> and the like, where each successive type extends its predecessor.
On the other hand, this tower is replicated <em>twice</em> for their “additive” and “multiplicative” counterparts.
These classes are isomorphic, up to the semantics, and hence naming of their operations.</p>

<p>This distinction is quite useful, because now one can write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semiring</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">with</span> <span class="nc">MultiplicativeSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="c1">// ...
</span><span class="o">}</span>
</code></pre></div></div>

<p>without clashes between the additive and multiplicative binary operations.
Also, a semiring can now be quite naturally treated as an additive monoid and a multiplicative semigroup (but not as a generic semigroup, which would be ambiguous).
(One could consider this the <em>third</em> hierarchy of algebraic type classes in spire.)</p>

<p>When checking laws, we do not want to repeat the same laws over and over again.
Hence, we need some way to express that certain type classes share laws with others which are not necessarily in the same type hierarchy.</p>

<h2 id="interface">Interface</h2>

<p>The implementation fundamentally depends on Scalacheck.
To be more specific, it uses <code class="highlighter-rouge">Prop</code> as the elementary unit of testing.</p>

<p>Now, a set of named <code class="highlighter-rouge">Prop</code>s do not quite suffice as the “law” of a type class.
First, to avoid ambiguous naming, let us call the complete law of a type class (including dependencies), a “rule set”.</p>

<p>To satisfy our requirement of having dependencies from (potentially) different hierarchies, we will distinguish <em>parents</em> and <em>bases</em>.
A <em>parent</em> is a rule set of a type class in the same hierachy, whereas a <em>base</em> can come from everywhere.
This distinction is expressed with the use of path-dependent types:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Laws</span> <span class="o">{</span>

  <span class="k">trait</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span>
    <span class="k">def</span> <span class="n">bases</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Laws</span><span class="k">#</span><span class="kt">RuleSet</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="n">parents</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">RuleSet</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>
    <span class="k">def</span> <span class="n">props</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Prop</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">()</span>

    <span class="c1">// ...
</span>  <span class="o">}</span>

<span class="o">}</span>
</code></pre></div></div>

<p>As we can see, <code class="highlighter-rouge">parents</code> uses type <code class="highlighter-rouge">RuleSet</code>, which constrains parents to the same outer <code class="highlighter-rouge">Laws</code> instance.
In contrast, <code class="highlighter-rouge">bases</code> uses the type <code class="highlighter-rouge">Laws#RuleSet</code> which means that bases can come from other instances of <code class="highlighter-rouge">Laws</code>.</p>

<p>When you define type classes, the general idea is to define one instance of <code class="highlighter-rouge">Laws</code> for each <em>hierarchy</em> of type classes.
Coming back to the Spire example, that could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"semigroup"</span>
    <span class="k">def</span> <span class="n">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>

  <span class="k">def</span> <span class="n">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"monoid"</span>
    <span class="k">def</span> <span class="n">parents</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">props</span> <span class="k">=</span> <span class="c1">// ...
</span>  <span class="o">}</span>
<span class="o">}</span>

<span class="k">trait</span> <span class="nc">AdditiveLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">groupLaws</span><span class="k">:</span> <span class="kt">GroupLaws</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">semigroup</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveSemigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"additive semigroup"</span>

    <span class="c1">// `.additive` converts an additive X to a generic X
</span>    <span class="k">def</span> <span class="n">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="n">groupLaws</span><span class="o">.</span><span class="n">semigroup</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">additive</span><span class="o">))</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">monoid</span><span class="o">(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AdditiveMonoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">RuleSet</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">RuleSet</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">name</span> <span class="k">=</span> <span class="s">"additive monoid"</span>

    <span class="k">def</span> <span class="n">bases</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="s">"additive"</span> <span class="o">→</span> <span class="n">groupLaws</span><span class="o">.</span><span class="n">monoid</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">additive</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">parent</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">(</span><span class="n">semigroup</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This now clearly expresses the intention:</p>

<ul>
  <li>A monoid is a semigroup.</li>
  <li>An additive semigroup should satisfy the laws of a semigroup.</li>
  <li>An additive monoid is an additive semigroup and should satisfy the laws of a monoid.</li>
</ul>

<p>Note that in the definitions inside <code class="highlighter-rouge">AdditiveLaws</code>, no properties have been restated.
The system will automatically take care that all the properties of the parents and the bases are being checked.</p>

<p>Obviously, this is not very interesting yet, because so far it could have been achieved by other means.
If you are interested in more complex examples, check the sources of Spire:
There are a couple of examples where the additive and multiplicative versions have extra checks which are not covered by the generic version.</p>

<h2 id="implementation">Implementation</h2>

<p>Now, the question is how to compute the set of all properties which need to be checked.
A naïve algorithm would just recursively traverse all bases and parents, and check the union of all the property sets.</p>

<p>However, this leads to unnecessary work.
Consider the rule set of an additive monoid.
There, the properties of semigroup would be included twice:
once via the semigroup base of the additive semigroup parent, and once via the semigroup parent of the monoid base.</p>

<p>While checking properties twice certainly does no damage, we still do not want to pay for that overhead.
Hence, a slightly smarter algorithm is used.
We compute the set of all properties of a certain class by taking the union of these sets:</p>

<ul>
  <li>the properties of the class itself</li>
  <li>recursively, the properties of all its parents (ignoring their bases)</li>
  <li>recursively, the set of all properties of its bases</li>
</ul>

<p>In order to present the user a more transparent output, the names of the properties are hierarchical.
When a base is pulled in as dependency, their properties are additionally prefixed with the name of the base.
This should make it very easy to see where exactly a property came from.</p>

<p>There is a slight complication, though.
Recall the definition of a semiring in spire, which is given above.
A semiring actually consists of two different semigroups of which we must check the laws separately.
At this point, it is not immediately clear what would happen with the presented algorithm.
With just a minor clarification it turns out that this is not actually a problem:
The rule set of a semiring specifies two bases (one for the additive component and one for the multiplicative component), and we only need to make sure that they have different names.
Laws pulled in via different bases are considered different, and are hence not conflated.</p>

<h2 id="usage">Usage</h2>

<p>Previously, this new law checking infrastructure was tailored to be used just in Spire.
Since it is useful outside of Spire, too, it has recently been generalized and pulled out into a separate project: <a href="https://github.com/typelevel/discipline">Discipline</a>.</p>

<p>In there, you can find a stripped-down example of the Spire use case.</p>

<p>Furthermore, there is integration with Specs2 and ScalaTest.
You just have to extend the <code class="highlighter-rouge">specs2.Discipline</code> (or <code class="highlighter-rouge">scalatest.Discipline</code>, respectively) trait, and write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">checkAll</span><span class="o">(</span><span class="s">"Int"</span><span class="o">,</span> <span class="nc">RingLaws</span><span class="o">[</span><span class="kt">Int</span><span class="o">].</span><span class="n">ring</span> <span class="cm">/* put your own `RuleSet` here */</span><span class="o">)</span>
</code></pre></div></div>

<p>and rule sets are expanded and turned into individual tests automatically.
For a Specs2-based tests, this will result in the following output (similar for ScalaTest):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[info] ring laws must hold for Int
[info]
[info]  + ring.additive:group.base:group.associative
[info]  + ring.additive:group.base:group.identity
[info]  + ring.additive:group.base:group.inverse
[info]  + ring.multiplicative:monoid.base:monoid.associative
[info]  + ring.multiplicative:monoid.base:monoid.identity
[info]  + ring.distributive
</code></pre></div></div>

<p>Observe that the associativity law for semigroups shows up twice (additive and multiplicative), but not four times (as would have happened with the naïve algorithm).</p>

<p>In the future, we will investigate whether Scalaz can also be migrated towards Discipline, for a more unified approach to law checking.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Lars Hupel
    
    on Nov 17, 2013</p>

    
  <a href="https://twitter.com/larsr_h" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @larsr_h</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/larsrh" aria-label="Follow @larsrh on GitHub">Follow @larsrh</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
