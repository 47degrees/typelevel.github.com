<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Towards Scalaz (Part 1)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Towards Scalaz (Part 1)</h2>

  <p>A lot of people see Scalaz as a hard fringe, ivory tower,
not suited for real-world applications library, which is
unfortunate. The goal of this blog post series is to introduce
various components of Scalaz, and hopefully through this
allow folks to gain an understanding towards the power of
Scalaz.</p>

<p>As a prerequisite, I assume knowledge of type classes as they
are implemented and used in Scala.</p>

<h2 id="part-1-learning-to-add">Part 1: Learning to Add</h2>

<p>Our motivation for the inaugural post of the series will be
summing a <code class="highlighter-rouge">List</code> of something. Lets start out with <code class="highlighter-rouge">Int</code>,
which is simple enough.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>And this works (kind of, it fails on empty <code class="highlighter-rouge">List</code>s but we’ll get to that).
But what if we want to sum a <code class="highlighter-rouge">List[Double]</code>?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumDoubles</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Double</span><span class="o">])</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>The code is the same, modulo the type parameter. In fact, the
code would be the same whether it is <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, or <code class="highlighter-rouge">BigInt</code>.
Being the good programmers that we are, let’s make this generic
in that respect with the help of <code class="highlighter-rouge">scala.math.Numeric</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumNumeric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<h3 id="problem">Problem</h3>
<p>Awesome. We can now sum <code class="highlighter-rouge">List[Int]</code>, <code class="highlighter-rouge">List[Double]</code>, <code class="highlighter-rouge">List[BigInt]</code>,
and many more.</p>

<p>But let’s give this a bit more thought - what if we wanted to
“sum” a <code class="highlighter-rouge">List[String]</code> - that is, we concatenate all the <code class="highlighter-rouge">String</code>s
together to create one large <code class="highlighter-rouge">String</code> ?</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumStrings</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>This looks exactly like summing <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Double</code>s! This however
does not work with our <code class="highlighter-rouge">sumNumeric</code> - there is no (sane) way to define
a <code class="highlighter-rouge">Numeric[String]</code>.</p>

<p>Another way to look at this is that we only use the <code class="highlighter-rouge">plus</code> method
on <code class="highlighter-rouge">Numeric</code>, never any of the other methods that also make sense
for numeric types. So while our function works for summing a List
of numeric types, it does not work for anything else that is not
numeric but can still be “added” (<code class="highlighter-rouge">String</code> and string concatenation,
<code class="highlighter-rouge">List[A]</code> and <code class="highlighter-rouge">List#++</code>).</p>

<h3 id="making-it-generic">Making it generic</h3>
<p>So what do we want? We want a type class that only requires instances
to be able to “add” two <code class="highlighter-rouge">A</code>s to get another <code class="highlighter-rouge">A</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And let’s define an instance of <code class="highlighter-rouge">Addable</code> for all <code class="highlighter-rouge">Numeric</code> types and <code class="highlighter-rouge">String</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Addable</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericIsAddable</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">stringIsAddable</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And here’s our shiny new generic summer function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>And now this works for <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Double</code>, <code class="highlighter-rouge">String</code>, and many more.</p>

<p>A good exercise at this point is to define an <code class="highlighter-rouge">Addable</code> instance for <code class="highlighter-rouge">List[A]</code>.</p>

<h3 id="making-an-exception">Making an Exception</h3>
<p>What happens when we pass in an empty <code class="highlighter-rouge">List</code> to our summer function though?
We get an exception! How do we prevent this? A common answer I get is
“Oh I know it won’t happen” – this is not ideal, we want to guarantee safety
as much as possible without having to rely on human judgement.</p>

<p>How then do we write a safer summer function? Lets turn to an alternative
way of implementing sum on <code class="highlighter-rouge">List[Int]</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Old, bad version
</span><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">reduce</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// Shiny, new version
</span><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</code></pre></div></div>

<p>What happens now when we pass an empty <code class="highlighter-rouge">List</code> into the sum function? We get 0,
not an exception! Note that before all we gave the program was a binary
operation (what <code class="highlighter-rouge">Addable</code> defines), where now we give a binary option <em>and</em> a
“zero” or starting value (the 0). As it stands, we cannot write this with
<code class="highlighter-rouge">Addable</code> since it has no “zero”.</p>

<p>It may be tempting to just add a <code class="highlighter-rouge">zero</code> method to <code class="highlighter-rouge">Addable</code>, but then we may run
into the same issues we had with <code class="highlighter-rouge">Numeric</code> later on – we don’t <em>always</em> need
a “zero”, sometimes a binary operation is good enough. So instead, let’s create
an <code class="highlighter-rouge">AddableWithZero</code> type class.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Addable</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Note that while you dont see the <code class="highlighter-rouge">plus</code> method in here, the fact
it <code class="highlighter-rouge">extends Addable</code> without implementing the <code class="highlighter-rouge">plus</code> method propagates the need to
implement that method, so programmers who want to create an <code class="highlighter-rouge">AddableWithZero[A]</code> instance
need to implement both.</p>

<p>Programmers can now write functions that depend only on <code class="highlighter-rouge">Addable</code>, or perhaps if they
need a bit more power use <code class="highlighter-rouge">AddableWithZero</code>. Types that have <code class="highlighter-rouge">AddableWithZero</code> instances
also have <code class="highlighter-rouge">Addable</code> instances automatically due to subtyping.</p>

<p>Lets move our <code class="highlighter-rouge">Addable</code> instances to the <code class="highlighter-rouge">AddableWithZero</code> object.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">AddableWithZero</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericIsAddableZero</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">zero</span>
    <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="n">stringIsAddableZero</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">AddableWithZero</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">""</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>And finally, our shiny new generic sum function!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">AddableWithZero</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">)(</span><span class="n">A</span><span class="o">.</span><span class="n">plus</span><span class="o">)</span>
</code></pre></div></div>

<p>Hurrah!</p>

<h3 id="plot-twist">Plot Twist</h3>
<p>It turns out that our <code class="highlighter-rouge">Addable</code> and <code class="highlighter-rouge">AddableWithZero</code> type classes is not just us being
sly and clever, but an actual thing! They are called <code class="highlighter-rouge">Semigroup</code> and
<code class="highlighter-rouge">Monoid</code> (respectively), taken from the wonderful field of abstract algebra. Abstract
algebra is a field dedicated to studying algebraic structures as opposed
to just numbers as we may be used to. The field looks into what properties
and operations various structures have in common, such as integers and
matrices. For instance, we can add two integers, as well as two matrices of the same size.
This is analogous to how we noticed the <code class="highlighter-rouge">plus</code> worked on not only <code class="highlighter-rouge">Numeric</code>
but <code class="highlighter-rouge">String</code> and <code class="highlighter-rouge">List[A]</code> as well! This is the kind of generecity we’re looking for.</p>

<p>Here’s what <code class="highlighter-rouge">sumGeneric</code> looks like in Scalaz land.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Monoid</span>

<span class="k">def</span> <span class="n">sumGeneric</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">l</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">l</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">A</span><span class="o">.</span><span class="n">zero</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">A</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span>
</code></pre></div></div>

<p>Thankfully we dont have to create our own versions of <code class="highlighter-rouge">Semigroup</code> and <code class="highlighter-rouge">Monoid</code> –
Scalaz has one for us! In fact, the developers of Scalaz have been kind enough to define
several <code class="highlighter-rouge">Monoid</code> instances for common types such as <code class="highlighter-rouge">Numeric</code>, <code class="highlighter-rouge">String</code>, <code class="highlighter-rouge">List[A]</code>, etc.
There are also instances for tuples – if we have a tuple, say of type <code class="highlighter-rouge">(A, B, C)</code>,
and all three types have <code class="highlighter-rouge">Monoid</code> instances themselves, then the whole tuple has an
instance where the <code class="highlighter-rouge">zero</code> is the tuple <code class="highlighter-rouge">(A.zero, B.zero, C.zero)</code> and the <code class="highlighter-rouge">plus</code> is
appending corresponding pairs between the two tuples. Look for instances that may already
be defined before defining your own on existing types.</p>

<div class="side-note">
  If you are interested in learning more about numeric programming, check out
  the <a href="https://github.com/non/spire">spire</a> library, as well as the
  accompanying post about <a href="/blog/2013/07/07/generic-numeric-programming.html">
  generic numeric programming</a>.
</div>

<h3 id="law-abiding-citizen">Law-Abiding Citizen</h3>
<p>To close this post off, I confess one thing: defining a <code class="highlighter-rouge">Monoid</code> (and <code class="highlighter-rouge">Semigroup</code>) instance
should not be done without some thought. It is not enough that you simply have a zero and
a binary operation – to truly have a <code class="highlighter-rouge">Monoid</code> or <code class="highlighter-rouge">Semigroup</code> certain laws must be obeyed.
These laws are as follows:</p>

<p>Call the <code class="highlighter-rouge">plus</code> operation $+$ and the <code class="highlighter-rouge">zero</code> value $0$. Arbitrary values of type <code class="highlighter-rouge">A</code> will be
referred to as $a$, $b$, etc.</p>

<p>The <code class="highlighter-rouge">Semigroup</code> law requires $+$ to be associative. That is:</p>

<div style="text-align:center;">
	$(a + b) + c = a + (b + c)$
</div>

<p>In addition to the <code class="highlighter-rouge">Semigroup</code> law for the binary operation, the <code class="highlighter-rouge">Monoid</code> law relates
$+$ and $0$:</p>

<div style="text-align:center;">
  $(a + 0) = (0 + a) = a$
</div>

<p>To check these laws, Scalaz provides <a href="https://github.com/scalaz/scalaz/tree/v7.0.4/scalacheck-binding">ScalaCheck</a>
bindings to help you, but that is a topic for another day.</p>

<p>Note that a particular type can have several <code class="highlighter-rouge">Semigroup</code> or <code class="highlighter-rouge">Monoid</code>s that make sense.
For instance, <code class="highlighter-rouge">Int</code> has a <code class="highlighter-rouge">Monoid</code> on $(+, 0)$ as well as on $(*, 1)$. Convince yourself
(using the above laws) that this makes sense.</p>

<p>This raises the question of how we get both $+$ and $*$ <code class="highlighter-rouge">Monoid</code>s for <code class="highlighter-rouge">Int</code> without
making <code class="highlighter-rouge">scalac</code> freak out about ambiguous implicit values. The answer is “tagged types”,
again a topic for another day.</p>

<h2 id="getting-help">Getting Help</h2>

<p>If you have any questions/comments/concerns, feel free to hop onto the IRC channel on
Freenode at <code class="highlighter-rouge">#scalaz</code>.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/adelbertchang.jpeg" />
      
      <p>by Adelbert Chang
    
    on Oct 13, 2013</p>

    
  <a href="https://twitter.com/adelbertchang" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @adelbertchang</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/adelbertc" aria-label="Follow @adelbertc on GitHub">Follow @adelbertc</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
