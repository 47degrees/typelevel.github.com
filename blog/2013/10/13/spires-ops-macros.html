<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | How to use Spire's Ops macros in your own project</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>How to use Spire's Ops macros in your own project</h2>

  <h2 id="what-are-spires-ops-macros">What are Spire’s Ops macros?</h2>

<p>Spire’s type classes abstract over very basic operators like <code class="highlighter-rouge">+</code> and
<code class="highlighter-rouge">*</code>.  These operations are normally very fast. This means that any
extra work that happens on a per-operation basis (like boxing or
object allocation) will cause generic code to be slower than its
direct equivalent.</p>

<p>Efficient, generic numeric programming is Spire’s raison d’être. We
have developed a set of Ops macros to avoid unnecessary object
instantiations at compile-time. This post explains how, and
illustrates how you can use these macros in your code!</p>

<h2 id="how-implicit-operators-on-type-classes-usually-work">How implicit operators on type classes usually work</h2>

<p>When using type classes in Scala, we rely on implicit conversions to
“add” operators to an otherwise generic type.</p>

<p>In this example, <code class="highlighter-rouge">A</code> is the generic type, <code class="highlighter-rouge">Ordering</code> is the type
class, and <code class="highlighter-rouge">&gt;</code> is the implicit operator. <code class="highlighter-rouge">foo1</code> is the code that the
programmer writes, and <code class="highlighter-rouge">foo4</code> is a translation of that code after
implicits are resolved, and syntactic sugar is expanded.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.math.Ordering</span>
<span class="k">import</span> <span class="nn">Ordering.Implicits._</span>

<span class="k">def</span> <span class="n">foo1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ordering</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo3</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">infixOrderingOps</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="n">foo4</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="n">ev</span><span class="o">.</span><span class="nc">Ops</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">y</span>
</code></pre></div></div>

<p>(This is actually slightly wrong. The expansion to <code class="highlighter-rouge">foo4</code> won’t happen
until runtime, when <code class="highlighter-rouge">infixOrderingOps</code> is called. But it helps
illustrate the point.)</p>

<p>Notice that we instantiate an <code class="highlighter-rouge">ev.Ops</code> instance for every call to
<code class="highlighter-rouge">&gt;</code>. This is not a big deal in many cases, but for a call that is
normally quite fast it will add up when done many (e.g. millions) of
times.</p>

<p>It is possible to work around this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">bar</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ordering</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">ev</code> parameter contains the method we actually want (<code class="highlighter-rouge">gt</code>), so
instead of instantiating <code class="highlighter-rouge">ev.Ops</code> this code calls <code class="highlighter-rouge">ev.gt</code> directly.
But this approach is ugly. Compare these two methods:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">qux1</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Field</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">((</span><span class="n">x</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="n">y</span> <span class="n">pow</span> <span class="mi">2</span><span class="o">)).</span><span class="n">sqrt</span>

<span class="k">def</span> <span class="n">qux2</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Field</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">sqrt</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="n">ev</span><span class="o">.</span><span class="n">pow</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="mi">2</span><span class="o">)))</span>
</code></pre></div></div>

<p>If you have trouble reading <code class="highlighter-rouge">qux2</code>, you are not alone.</p>

<p>At this point, it looks like we can either write clean, readable code
(<code class="highlighter-rouge">qux1</code>), or code defensively to avoid object allocations (<code class="highlighter-rouge">qux2</code>).
Most programmers will just choose one or the other (probably the
former) and go on with their lives.</p>

<p>However, since this issue affects Spire deeply, we spent a bit more
time looking at this problem to see what could be done.</p>

<h2 id="having-our-cake-and-eating-it-too">Having our cake and eating it too</h2>

<p>Let’s look at another example, to compare how the “nice” and “fast”
code snippets look after implicits are resolved:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">niceBefore</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Ring</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span> <span class="o">*</span> <span class="n">z</span>

<span class="k">def</span> <span class="n">niceAfter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="k">new</span> <span class="nc">RingOps</span><span class="o">(</span><span class="n">x</span><span class="o">)(</span><span class="n">ev</span><span class="o">).+(</span><span class="n">y</span><span class="o">))(</span><span class="n">ev</span><span class="o">).*(</span><span class="n">z</span><span class="o">)</span>

<span class="k">def</span> <span class="n">fast</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">ev</span><span class="k">:</span> <span class="kt">Ring</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">ev</span><span class="o">.</span><span class="n">times</span><span class="o">(</span><span class="n">ev</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">),</span> <span class="n">z</span><span class="o">)</span>
</code></pre></div></div>

<p>As we can see, <code class="highlighter-rouge">niceAfter</code> and <code class="highlighter-rouge">fast</code> are actually quite similar. If
we wanted to transform <code class="highlighter-rouge">niceAfter</code> into <code class="highlighter-rouge">fast</code>, we’d just have to:</p>

<ol>
  <li>
    <p>Figure out the appropriate name for symbolic operators. In this
example, <code class="highlighter-rouge">+</code> becomes <code class="highlighter-rouge">plus</code> and <code class="highlighter-rouge">*</code> becomes <code class="highlighter-rouge">times</code>.</p>
  </li>
  <li>
    <p>Rewrite the object instantiation and method call, calling the
method on <code class="highlighter-rouge">ev</code> instead and passing <code class="highlighter-rouge">x</code> and <code class="highlighter-rouge">y</code> as arguments. In
this example, <code class="highlighter-rouge">new Ops(x)(ev).foo(y)</code> becomes <code class="highlighter-rouge">ev.foo(x, y)</code>.</p>
  </li>
</ol>

<p>In a nutshell, this transformation is what Spire’s Ops macros do.</p>

<h2 id="using-the-ops-macros">Using the Ops macros</h2>

<p>Your project must use Scala 2.10+ to be able to use macros.</p>

<p>To use Spire’s Ops macros, you’ll need to depend on the <code class="highlighter-rouge">spire-macros</code>
package. If you use SBT, you can do this by adding the following line
to <code class="highlighter-rouge">build.sbt</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">"org.spire-math"</span> <span class="o">%%</span> <span class="s">"spire-macros"</span> <span class="o">%</span> <span class="s">"0.6.1"</span>
</code></pre></div></div>

<p>You will also need to enable macros at the declaration site of your
ops classes:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>
</code></pre></div></div>

<h2 id="lets-see-an-example">Let’s see an example</h2>

<p>Consider <code class="highlighter-rouge">Sized</code>, a type class that abstracts over the notion of
having a size. Type class instances for <code class="highlighter-rouge">Char</code>, <code class="highlighter-rouge">Map</code>, and <code class="highlighter-rouge">List</code> are
provided in the companion object. Of course, users can also provide
their own instances.</p>

<p>Here’s the code:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span>
  <span class="k">def</span> <span class="n">nonEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">size</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="n">compare</span> <span class="n">size</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Sized</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">val</span> <span class="n">charSized</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Char</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">toInt</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">mapSized</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">listSized</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Sized</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">length</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">isEmpty</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">y</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">0</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="mi">1</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span> <span class="o">::</span> <span class="n">xt</span><span class="o">,</span> <span class="k">_</span> <span class="o">::</span> <span class="n">yt</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">xt</span><span class="o">,</span> <span class="n">yt</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>(Notice that <code class="highlighter-rouge">Sized[List[A]]</code> overrides some of the “default”
implementations to be more efficient, since taking the full length of
a list is an O(n) operation.)</p>

<p>We’d like to be able to call these methods directly on a generic type
<code class="highlighter-rouge">A</code> when we have an implicit instance of <code class="highlighter-rouge">Sized[A]</code> available. So
let’s define a <code class="highlighter-rouge">SizedOps</code> class, using Spire’s Ops macros:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">spire.macrosk.Ops</span>
<span class="k">import</span> <span class="nn">scala.language.experimental.macros</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">SizedOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">size</span><span class="o">()</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">isEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">nonEmpty</span><span class="o">()</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">unop</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">sizeCompare</span><span class="o">(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">Int</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That’s it!</p>

<p>Here’s what it would look like to use this type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Implicits._</span>

<span class="k">def</span> <span class="n">findSmallest</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">reduceLeft</span> <span class="o">{</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">if</span> <span class="o">((</span><span class="n">x</span> <span class="n">sizeCompare</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="k">else</span> <span class="n">y</span>
  <span class="o">}</span>

<span class="k">def</span> <span class="n">compact</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">nonEmpty</span><span class="o">)</span>

<span class="k">def</span> <span class="n">totalSize</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Sized</span><span class="o">](</span><span class="n">as</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="n">as</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
</code></pre></div></div>

<p>Not bad, eh?</p>

<h2 id="the-fine-print">The fine print</h2>

<p>Of course, there’s always some fine-print.</p>

<p>In this case, the implicit class <strong>must</strong> use the same parameter names
as above. The constructor parameter to <code class="highlighter-rouge">SizedOps</code> <strong>must</strong> be called
<code class="highlighter-rouge">lhs</code> and the method parameter (if any) <strong>must</strong> be called
<code class="highlighter-rouge">rhs</code>. Also, unary operators (methods that take no parameters, like
<code class="highlighter-rouge">size</code>) <strong>must</strong> have parenthesis.</p>

<p>How the macros handle classes with multiple constructor parameters, or
multiple method parameters? They don’t. We haven’t needed to support
these kinds of exotic classes, but it would probably be easy to extend
Spire’s Ops macros to support other shapes as well.</p>

<p>If you fail to follow these rules, or if your class has the wrong
shape, your code will fail to compile. So don’t worry. If your code
compiles, it means you got it right!</p>

<h2 id="symbolic-names">Symbolic names</h2>

<p>The previous example illustrates rewriting method calls to avoid
allocations, but what about mapping symbolic operators to method
names?</p>

<p>Here’s an example showing the mapping from <code class="highlighter-rouge">*</code> to <code class="highlighter-rouge">times</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">CanMultiply</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Implicits</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">MultiplyOps</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">lhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">*(</span><span class="n">rhs</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">macro</span> <span class="nc">Ops</span><span class="o">.</span><span class="n">binop</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Example</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">Implicits._</span>

  <span class="k">def</span> <span class="n">gak</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">CanMultiply</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">as</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span>
    <span class="n">as</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">a</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Currently, the Ops macros have a large (but Spire-specific)
<a href="https://github.com/non/spire/blob/9eaa5c34549b7fe85c223f207f0790873075c048/macros/src/main/scala/spire/macros/Ops.scala#L143">mapping</a>
from symbols to names. However, your project may want to use different names
(or different symbols). What then?</p>

<p>For now, you are out of luck. In Spire 0.7.0, we plan to make it
possible to use your own mapping. This should make it easier for other
libraries that make heavy use of implicit symbolic operators
(e.g. Scalaz) to use these macros as well.</p>

<h2 id="other-considerations">Other considerations</h2>

<p>You might wonder how the Ops macros interact with
specialization. Fortunately, macros are expanded before the
specialization phase. This means you don’t need to worry about it! If
your type class is specialized, and you invoke the implicit from a
specialized (or non-generic) context, the result will be a specialized
call.</p>

<p>(Of course, using Scala’s specialization is tricky, and deserves its
own blog post. The good news is that type classes are some of the
easiest structures to specialize correctly in Scala.)</p>

<p>Evaluating the macros at compile-time also means that if there are
problems with the macro, you’ll find out about those at compile-time
as well. While we expect that many projects will benefit from the Ops
macros, they were designed specifically for Spire so it’s possible
that your project will discover problems, or need new features.</p>

<p>If you do end up using these macros,
<a href="https://groups.google.com/forum/#!forum/spire-math">let us know how</a>
they work for you. If you have problems, please open an
<a href="https://github.com/non/spire/issues">issue</a>, and if you have bug
fixes (or new features) feel free to open a
<a href="https://github.com/non/spire/pulls">pull request</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>We are used to thinking about abstractions having a cost. So we often
end up doing mental accounting: “Is it worth making this generic? Can
I afford this syntactic sugar? What will the runtime impact of this
code be?” These condition us to expect that code can either be
beautiful or fast, but not both.</p>

<p>By removing the cost of implicit object instantiation, Spire’s Ops
macros raise the abstraction ceiling. They allow us to make free use
of type classes without compromising performance. Our goal is to close
the gap between direct and generic performance, and to encourage the
widest possible use of generic types and type classes in Scala.</p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
        <img class="portrait" src="/img/media/speakers/erikosheim.jpg" />
      
      <p>by Erik Osheim
    
    on Oct 13, 2013</p>

    
  <a href="https://twitter.com/d6" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @d6</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/non" aria-label="Follow @non on GitHub">Follow @non</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
