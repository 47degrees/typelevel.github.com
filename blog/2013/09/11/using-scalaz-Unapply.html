<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Using scalaz.Unapply</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Using scalaz.Unapply</h2>

  <p>Once you’ve started really taking advantage of Scalaz’s typeclasses
for generic programming, you might have noticed a need to write
typelambdas to use some of your neat abstractions, or use syntax like
<code class="highlighter-rouge">traverse</code> or <code class="highlighter-rouge">kleisli</code> with a strangely-shaped type as an argument.
Here’s a simple generalization, a <code class="highlighter-rouge">List</code>-based <code class="highlighter-rouge">traverse</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">scalaz.Applicative</span><span class="o">,</span> <span class="n">scalaz</span><span class="o">.</span><span class="n">syntax</span><span class="o">.</span><span class="n">applicative</span><span class="o">.</span><span class="k">_</span>

<span class="k">def</span> <span class="n">sequenceList</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">xs</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">].</span><span class="n">point</span><span class="o">[</span><span class="kt">F</span><span class="o">])((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">^(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)(</span><span class="k">_</span> <span class="o">::</span> <span class="k">_</span><span class="o">))</span>
</code></pre></div></div>

<p>This works fine for a while.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.std.option._</span>
<span class="k">import</span> <span class="nn">scalaz.std.option._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">some</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="n">some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="n">none</span><span class="o">))</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">None</span>
</code></pre></div></div>

<h2 id="the-problem">The problem</h2>

<p>The type of the input in the above example, <code class="highlighter-rouge">List[Option[Int]]</code>, can be
neatly destructured into the <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">A</code> type params needed by
<code class="highlighter-rouge">sequenceList</code>.  It has the “shape” <code class="highlighter-rouge">F[x]</code>, so <code class="highlighter-rouge">F</code> can be picked out by
Scala easily.</p>

<p>Consider something else with a convenient <code class="highlighter-rouge">Applicative</code> instance,
though.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.</span><span class="o">\/</span>
<span class="k">import</span> <span class="nn">scalaz.$bslash$div</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">no</span> <span class="k">type</span> <span class="kt">parameters</span> <span class="kt">for</span> <span class="kt">method</span> 
  <span class="n">sequenceList</span><span class="k">:</span> <span class="o">(</span><span class="kt">xs:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])(</span><span class="k">implicit</span> <span class="n">evidence$1</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">])</span><span class="n">F</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
  <span class="n">exist</span> <span class="n">so</span> <span class="n">that</span> <span class="n">it</span> <span class="n">can</span> <span class="n">be</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">arguments</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]])</span>
 <span class="o">---</span> <span class="n">because</span> <span class="o">---</span>
<span class="n">argument</span> <span class="n">expression</span><span class="ss">'s </span><span class="k">type</span> <span class="kt">is</span> <span class="kt">not</span> <span class="kt">compatible</span> <span class="kt">with</span> <span class="kt">formal</span> <span class="kt">parameter</span> <span class="k">type</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">?F</span><span class="o">]</span>

              <span class="n">sequenceList</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
              <span class="o">^</span>
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">?F</code> meaning it couldn’t figure out that you meant <code class="highlighter-rouge">({type λ[α]
= NonEmptyList[String] \/ α})#λ</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="kt">\/</span> <span class="kt">α</span><span class="o">})</span><span class="k">#</span><span class="kt">λ</span>, <span class="kt">Int</span>
                  <span class="o">](</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The problem is that <code class="highlighter-rouge">NonEmptyList[String] \/ Int</code> has the shape
<code class="highlighter-rouge">F[A, B]</code>, with <code class="highlighter-rouge">F</code> of kind <code class="highlighter-rouge">* -&gt; * -&gt; *</code> after a fashion, whereas the
<code class="highlighter-rouge">F</code> it wants must have kind <code class="highlighter-rouge">* -&gt; *</code>, and Scala kinds aren’t curried
at all.</p>

<h2 id="finding-an-unapply-instance">Finding an <code class="highlighter-rouge">Unapply</code> instance</h2>

<p><code class="highlighter-rouge">Unapply</code>, though, <em>does</em> have implicit instances matching the
<code class="highlighter-rouge">F[A, B]</code> shape, <code class="highlighter-rouge">unapplyMAB1</code> and <code class="highlighter-rouge">unapplyMAB2</code>, in its companion so
effectively always visible.  What’s special about them is that their
type parameters match the “shape” you’re working with, <code class="highlighter-rouge">F[A, B]</code>.</p>

<p>You should
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Unapply.scala#L210">look at their source</a>
to follow along.</p>

<p>Let’s see if one of them works.  For implicit resolution to finish,
it’s important that <em>exactly</em> one of them works.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scalaz.Unapply</span>
<span class="k">import</span> <span class="nn">scalaz.Unapply</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">could</span> <span class="kt">not</span> <span class="kt">find</span> <span class="kt">implicit</span> <span class="kt">value</span> <span class="kt">for</span> <span class="kt">parameter</span>
<span class="nc">TC0</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">α</span>,<span class="kt">Int</span><span class="o">]]</span>
              <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB1</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
                                 <span class="o">^</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Unapply</span><span class="o">.</span><span class="n">unapplyMAB2</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">\/</span>, <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Applicative</span>,
                     <span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]]{</span>
        <span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.\/[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">X</span><span class="o">];</span>
        <span class="k">type</span> <span class="kt">A</span> <span class="o">=</span> <span class="nc">Int</span>
      <span class="o">}</span> <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Unapply_0$$anon$13</span><span class="k">@</span><span class="mi">5402</span><span class="n">af61</span>
</code></pre></div></div>

<p>Here, the type <code class="highlighter-rouge">res7.M</code> represents the typelambda being passed to
<code class="highlighter-rouge">sequenceList</code>.  You can see that work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceList</span><span class="o">[</span><span class="kt">res7.M</span>, <span class="kt">res7.A</span><span class="o">](</span>
                   <span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">res7.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">res7.A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">res8</span> <span class="k">:</span> <span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">\/</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
        <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">res8</code> conformance test shows that Scala can still reduce the
path-dependent <code class="highlighter-rouge">res7.M</code> and <code class="highlighter-rouge">res7.A</code> types at this level, outside
<code class="highlighter-rouge">sequenceList</code>.</p>

<h2 id="searching-for-the-right-shape">Searching for the right shape</h2>

<p>Implicit resolution can pick the call to <code class="highlighter-rouge">unapplyMAB2</code> partly because
it can pick all of its type parameters without weird typelambda
structures.  But in Scalaz, we use typeclasses to guide its choice.</p>

<p>Why didn’t <code class="highlighter-rouge">unapplyMAB1</code> work?  In this case, you can trust <code class="highlighter-rouge">scalac</code>
to say exactly the right thing: it looked for
<code class="highlighter-rouge">Applicative[[α]scalaz.\/[α,Int]]</code>, and didn’t find one.  Sure enough,
<code class="highlighter-rouge">\/</code> being right-biased means we don’t offer that instance.</p>

<p>Incidentally, if you were to introduce that instance, you’d break code
relying on right-biased <code class="highlighter-rouge">Unapply</code> resolution to work.</p>

<p><code class="highlighter-rouge">unapplyMAB2</code> needs evidence of <code class="highlighter-rouge">TC[({type λ[α] = M0[A0, α]})#λ]</code>.
But that’s okay, because we have that, where <code class="highlighter-rouge">TC=Applicative</code>,
<code class="highlighter-rouge">M0=\/</code>, and <code class="highlighter-rouge">A0=NonEmptyList[String]</code>!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Applicative</span><span class="o">[({</span><span class="k">type</span> <span class="kt">λ</span><span class="o">[</span><span class="kt">α</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">\/</span><span class="o">[</span><span class="kt">NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>, <span class="kt">α</span><span class="o">]})</span><span class="k">#</span><span class="kt">λ</span><span class="o">]</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">scalaz.Applicative</span><span class="o">[[</span><span class="kt">α</span><span class="o">]</span><span class="kt">scalaz.\/</span><span class="o">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>,<span class="kt">α</span><span class="o">]]</span>
         <span class="k">=</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">DisjunctionInstances2$$anon$1</span><span class="k">@</span><span class="mf">2f</span><span class="mi">658816</span>
</code></pre></div></div>

<p>Scala doesn’t need to figure out any typelambda itself for this to
work; we did everything by putting the typelambda right into
<code class="highlighter-rouge">unapplyMAB2</code>’s evidence requirement, so it just has to find the
conforming implicit value.</p>

<h2 id="using-unapply-generically">Using <code class="highlighter-rouge">Unapply</code> generically</h2>

<p>Now you can write a <code class="highlighter-rouge">sequenceList</code> wrapper that works for <code class="highlighter-rouge">\/</code> and
many other shapes, including user-provided shapes in the form of new
<code class="highlighter-rouge">Unapply</code> implicit instances.  If you’re using Scala 2.9 (still?!) you
need to add <code class="highlighter-rouge">-Ydependent-method-types</code> to <code class="highlighter-rouge">scalacOptions</code> to write
this function.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">sequenceListU</span><span class="o">[</span><span class="kt">FA</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">FA</span><span class="o">])</span>
                     <span class="o">(</span><span class="k">implicit</span> <span class="n">U</span><span class="k">:</span> <span class="kt">Unapply</span><span class="o">[</span><span class="kt">Applicative</span>, <span class="kt">FA</span><span class="o">]</span>
                     <span class="o">)</span><span class="k">:</span> <span class="kt">U.M</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">U.A</span><span class="o">]]</span> <span class="k">=</span>
  <span class="n">sequenceList</span><span class="o">(</span><span class="n">U</span><span class="o">.</span><span class="n">leibniz</span><span class="o">.</span><span class="n">subst</span><span class="o">(</span><span class="n">xs</span><span class="o">))(</span><span class="n">U</span><span class="o">.</span><span class="nc">TC</span><span class="o">)</span>
</code></pre></div></div>

<p>Instead of <code class="highlighter-rouge">xs</code> being <code class="highlighter-rouge">List[F[A]]</code>, it’s <code class="highlighter-rouge">List[FA]</code>, and that’s
destructured into <code class="highlighter-rouge">U.M</code> and <code class="highlighter-rouge">U.A</code>.  The latter are path-dependent
types on <code class="highlighter-rouge">U</code>, the conventional name of the <code class="highlighter-rouge">Unapply</code> parameter.  We
have also followed the convention of naming the <code class="highlighter-rouge">Unapply</code>-taking
variant function ending with a <code class="highlighter-rouge">U</code>.</p>

<p>And that works great!</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="n">sequenceListU</span><span class="o">(</span><span class="nc">List</span><span class="o">(\/.</span><span class="n">right</span><span class="o">(</span><span class="mi">42</span><span class="o">),</span> <span class="o">\/.</span><span class="n">left</span><span class="o">(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="s">"oops"</span><span class="o">))))</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">scalaz.\/</span><span class="err">[</span><span class="kt">scalaz.NonEmptyList</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span><span class="err">]</span> <span class="k">=</span>
   <span class="o">-\/(</span><span class="nc">NonEmptyList</span><span class="o">(</span><span class="n">oops</span><span class="o">))</span>
</code></pre></div></div>

<p>Of course, there’s that strange-looking function body to consider,
still.</p>

<h2 id="using-the-u-evidence">Using the <code class="highlighter-rouge">U</code> evidence</h2>

<p>The type equalities of the original <code class="highlighter-rouge">U.M</code> and <code class="highlighter-rouge">U.A</code> to the original
types can be seen where <code class="highlighter-rouge">res8</code> is refined to <code class="highlighter-rouge">res9</code> above.  But only
the <em>caller</em> of the function knows those equalities, because it
produced and supplied the <code class="highlighter-rouge">unapplyMAB2</code> call, which has a structural
type containing those equalities.</p>

<p>The body of <code class="highlighter-rouge">sequenceListU</code> doesn’t know those things.  In particular,
it <em>still</em> can’t pick type parameters to pass to <code class="highlighter-rouge">sequenceList</code>
without a little help.</p>

<p>The <code class="highlighter-rouge">leibniz</code> member is a reified type equality of <code class="highlighter-rouge">FA === U.M[U.A]</code>,
meaning those are the same at the type level, even though Scala can’t
see it in this context.  It represents genuine evidence that those two
types are equal, and is much more powerful than scala-library’s own
<code class="highlighter-rouge">=:=</code>.  We’re using the core Leibniz operator, <code class="highlighter-rouge">subst</code>, directly to
prove that, <em>as a consequence of that type equality</em>, <code class="highlighter-rouge">List[FA] ===
List[U.M[U.A]]</code> is <em>also</em> a type equality, and that therefore this
[constant-time] coercion is valid.  This lifting is applicable in all
contexts, not just covariant ones like <code class="highlighter-rouge">List</code>’s.  Take a look at
<a href="https://github.com/scalaz/scalaz/blob/v7.0.3/core/src/main/scala/scalaz/Leibniz.scala">the full API</a>
for more, though you’ll typically just need to come up with the right
type parameter for <code class="highlighter-rouge">subst</code>.</p>

<p>You can’t ask for an <code class="highlighter-rouge">Unapply</code> and <em>also</em> ask for an
<code class="highlighter-rouge">Applicative[U.M]</code>; Scala won’t allow it.  So, because we needed to
resolve the typeclass anyway to find the <code class="highlighter-rouge">Unapply</code> implicit to use, we
just cart it along with the <code class="highlighter-rouge">U</code> and give it to the function, which
almost always needs to use it anyway.  Because it’s not implicitly
available, you usually need to grab it, <code class="highlighter-rouge">U.TC</code>, and use it directly.</p>

<h2 id="using-in-scalazsyntax">Using in <code class="highlighter-rouge">scalaz.syntax</code></h2>

<p><code class="highlighter-rouge">map</code> comes from functor syntax; it’s not a method on <code class="highlighter-rouge">Function1</code>.  So
how come this works?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; import scalaz.std.function._
import scalaz.std.function._

scala&gt; ((_:Int) + 42) map (_ * 33)
res13: Int =&gt; Int = &lt;function1&gt;

scala&gt; res13(1)
res14: Int = 1419
</code></pre></div></div>

<p>When you import syntax, as <code class="highlighter-rouge">Functor</code> syntax was imported with
<code class="highlighter-rouge">scalaz.syntax.applicative._</code> above, you get at least two conversions:
the plain one, like <code class="highlighter-rouge">ToFunctorOps[F[_],A]</code>, which works if you have
the right shape, and the fancy one, <code class="highlighter-rouge">ToFunctorOpsUnapply[FA]</code>, which
uses an <code class="highlighter-rouge">Unapply</code> to effectively invoke <code class="highlighter-rouge">ToFunctorOps</code> as in the
above.  The latter is lower-priority, so Scala will pick the former if
the value has the <code class="highlighter-rouge">F[A]</code> shape.</p>

<p>That gives access to all the methods in <code class="highlighter-rouge">FunctorOps</code>, and other ops
classes, with only one special <code class="highlighter-rouge">U</code>-taking method.  If you have several
functions operating on the same value type, or you can make that type
similar with Leibnizian equality as implicit arguments to your
methods, I suggest grouping them in this way, too, to cut down on
boilerplate.</p>

<h2 id="provide-both-anyway">Provide both anyway</h2>

<p>We sometimes get asked “why not just provide the <code class="highlighter-rouge">Unapply</code> version of
the function or ops?”</p>

<p>We do it, and suggest it for your own code, despite the confusion,
because it’s easier to work with real type equalities than with
Leibnizian equality, which you can do in your “real” function
implementation, and as seen in <code class="highlighter-rouge">res8</code> above, the path-dependent type
resolution can leave funny artifacts in the inferred result.  Here’s
an extreme example from
<a href="https://groups.google.com/d/msg/scalaz/9zAIGETrePI/o1rBsOcWJWAJ">an earlier demonstration</a>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">itt</span> <span class="k">=</span> <span class="nc">IdentityT</span> <span class="n">lift</span> <span class="n">it</span>
<span class="n">itt</span><span class="k">:</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                                       <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                                     <span class="kt">Int</span><span class="o">]]</span>
                 <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">IdentityT</span><span class="o">[</span><span class="kt">scalaz.Unapply</span><span class="o">[</span><span class="kt">scalaz.Monad</span>,<span class="kt">Identity</span><span class="o">[</span><span class="kt">Int</span><span class="o">]]</span>
                                          <span class="o">{</span><span class="k">type</span> <span class="kt">M</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">Identity</span><span class="o">[</span><span class="kt">X</span><span class="o">]</span><span class="err">;</span> <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
                                        <span class="kt">X</span><span class="o">]</span><span class="err">;</span>
                  <span class="k">type</span> <span class="kt">A</span> <span class="kt">=</span> <span class="kt">Int</span><span class="o">}</span><span class="k">#</span><span class="kt">M</span>,
               <span class="kt">Int</span><span class="o">]</span>
  <span class="k">=</span> <span class="nc">IdentityT</span><span class="o">(</span><span class="nc">IdentityT</span><span class="o">(</span><span class="nc">Identity</span><span class="o">(</span><span class="mi">42</span><span class="o">)))</span>
</code></pre></div></div>

<h2 id="credits">Credits</h2>

<p><a href="https://twitter.com/retronym">Jason Zaugg</a> implemented Scalaz
<code class="highlighter-rouge">Unapply</code>, based on
<a href="https://issues.scala-lang.org/browse/SI-2712?focusedCommentId=55239&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-55239">ideas</a>
from <a href="https://twitter.com/milessabin">Miles Sabin</a> and
<a href="https://github.com/pchiusano">Paul Chiusano</a>.</p>

<p>Leibnizian equality was implemented for Scalaz by
<a href="https://github.com/ekmett">Edward Kmett</a>.</p>

<p><a href="https://twitter.com/larsr_h">Lars Hupel</a>’s talk
(<a href="https://speakerdeck.com/larsrh/seven-at-one-blow-new-and-polished-features-in-scalaz-7">slides</a>,
<a href="https://www.youtube.com/watch?feature=player_embedded&amp;v=KzoqOVD7mvE">video</a>)
on the features in the then-upcoming Scalaz 7 at nescala 2013,
including <code class="highlighter-rouge">Unapply</code>, gave me the missing “guided by typeclasses”
detail, inspiring me to tell more people about the whole thing at the
conference, and then, much later, write it down here.</p>

<p><em>This article was tested with Scala 2.10.2 &amp; Scalaz 7.0.3.</em></p>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Stephen Compall
    
    on Sep 11, 2013</p>

    
  <a href="https://twitter.com/S11001001" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @S11001001</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/S11001001" aria-label="Follow @S11001001 on GitHub">Follow @S11001001</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>



    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
