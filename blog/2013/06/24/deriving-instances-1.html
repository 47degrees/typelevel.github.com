<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Typelevel.scala | Deriving Type Class Instances</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Let the Scala compiler work for you. We provide type classes, instances, conversions, testing, supplements to the standard library, and much more.">


    <link rel="mask-icon" href="/img/favicon-safari.svg" color="#F51C2B">
    <link href="/img/favicon.png" rel="icon" type="image/x-icon">
    <link rel="alternate" href="/blog/feed.rss" title="RSS feed" type="application/rss+xml">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Droid+Serif:400,400italic,700' rel='stylesheet' type='text/css'>

    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script type="text/javascript" src="/js/app.js"></script>
  </head>
  <body class="no-js ">
    <div class="header">
      <div class="wrapper">
        <a href="/">
          <div class="header__logo">
            Typelevel.scala
          </div>
        </a>
        <a href="#" class="header__menu">
          Menu
        </a>
        <ul class="navigation" role="navigation">
          <li >
            <a href="/projects/">Projects</a>
          </li>
          <li >
            <a href="/events/">Events</a>
          </li>
          <li  class="active" >
            <a href="/blog/">Blog</a>
          </li>
          <li >
            <a href="/about.html">About</a>
          </li>
        </ul>
      </div>
    </div>
    
    <div class="wrapper">
      <div class="content post js-fade-in">
  <h2>Deriving Type Class Instances</h2>

  <h2 id="motivating-example">Motivating example</h2>

<p>Assume that you have a <code class="highlighter-rouge">case class</code> representing vectors in three-dimensional space:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>Now you want to implement addition on this class.
Currently, you have to do that manually:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="o">+(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector3D</span> <span class="o">=</span>
  <span class="nc">Vector3D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">z</span><span class="o">)</span>
</code></pre></div></div>

<p>If you are writing some code involving three-dimensional vectors, chances are that you also have to deal with two-dimensional ones:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector2D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Vector2D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Vector2D</span> <span class="o">=</span>
    <span class="nc">Vector2D</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Observe that the hand-written implementation of <code class="highlighter-rouge">+</code> is quite repetitive.
We want to avoid that sort of boilerplate code as much as possible.</p>

<p>In this post, we will introduce an abstraction over the <em>addition</em> operation, namely <em>semigroups</em>,
and introduce a macro-based facility which allows you to get the implementation of <code class="highlighter-rouge">+</code> for free.
In the end, the only thing you will have to write is this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">vector2DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector2D</span><span class="o">]</span>
<span class="k">implicit</span> <span class="k">val</span> <span class="n">vector3DSemigroup</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>That is still a little bit of boilerplate, right? How about:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div></div>

<p>This will give you <code class="highlighter-rouge">Semigroup</code> instances for <em>all</em> of your data types – with zero boilerplate!</p>

<p>But first, let us introduce all the related concepts properly.</p>

<h2 id="abstracting-all-the-things">Abstracting all the things</h2>

<div class="side-note">
  If you are already familiar with type classes in general and algebraic structures in particular, you can safely skip this and the next section.
  Keep in mind though that we are dealing with classes for types of kind $*$ only. Type classes for $* \rightarrow *$ are different and not supported.
</div>

<p>Type classes are an incredibly useful abstraction mechanism, originally introduced in Haskell.
If you have been using some of the typelevel.scala libraries already, you probably know how type classes and their instances are represented in Scala: as traits and implicits.
In the following section, we will get started with an example type class from abstract algebra, which is implemented in <em>spire</em>.</p>

<h2 id="group-theory">Group theory</h2>

<p>Group theory is a very important field of research in mathematics and has a very broad range of applications, especially in computer science.
One of the most fundamental structures is a <em>semigroup</em>, which consists of a set of elements equipped with one operation (often called <em>append</em>, <em>mplus</em>, or similarly; in textbooks you will often find $\circ$ or $\oplus$).
Additionally, the operation has to obey the <em>law of associativity</em>, meaning that for any three values $s_1, s_2,$ and $s_3$, it does not matter if you append $s_1$ and $s_2$ first and then append $s_3$, or append $s_2$ and $s_3$ first and then append $s_1$ and the result of that.
In other words, the precise order in which the steps of a larger operation are executed does not matter.
A good analogy here is when flattening a list:
On the surface, you just do not care if it proceeds by splitting the list recursively or if the concatenation is done sequentially by folding.</p>

<div class="side-note">
  In fact, some list operations actually require associativity. From the Scaladoc of the <code>fold</code> method on <code>Seq</code>:
  <blockquote>
    Folds the elements of this collection or iterator using the specified associative binary operator.
    The order in which operations are performed on elements is unspecified and may be nondeterministic. 
  </blockquote>
  This allows a particular collection implementation to use whichever order is most efficient.
</div>

<p>Lists are already a good example for a semigroup: Any <code class="highlighter-rouge">List[T]</code> is a semigroup, with the semigroup operation being list concatenation!
A <code class="highlighter-rouge">Map[K, V]</code> is a semigroup too, given that <code class="highlighter-rouge">V</code> is a semigroup.
The operation is just “merging” two maps, and if you have two duplicate keys, you can use the semigroup operation for <code class="highlighter-rouge">V</code>.</p>

<p>Enough examples. We can represent the concept of a semigroup in Scala using a trait:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">S</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">S</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">S</span><span class="o">)</span><span class="k">:</span> <span class="kt">S</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Obviously, we can also implement a semigroup for base types like <code class="highlighter-rouge">Int</code>. An instance could look like this:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">intInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">s1</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">s2</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">s2</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In other words, we just use the built-in addition function.</p>

<div class="side-note">If you want to know more about applications of abstract algebra in programming, especially in <em>spire</em>, head over to YouTube and watch <a href="http://www.youtube.com/watch?v=xO9AoZNSOH4">an introduction by Tom Switzer</a>.</div>

<h2 id="composing-instances">Composing instances</h2>

<p>Now suppose you are working with three-dimensional images.
Most likely, you will encounter a data structure for vectors (or points), which we recall from above:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="k">class</span> <span class="nc">Vector3D</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">z</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
</code></pre></div></div>

<p>And since you know your maths, you also know that vectors can be added, and that vector addition forms a semigroup!
Hence, a semigroup instance for <code class="highlighter-rouge">Vector3D</code> is the next logical step.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">vectorInstance</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">u</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">,</span> <span class="n">v</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span> <span class="k">=</span>
    <span class="nc">Vector3D</span><span class="o">(</span><span class="n">u</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="o">,</span> <span class="n">u</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, that was a bit tedious, right? We would love to have a way the compiler could write that instance for us.
(I mean, it already generates reasonable defaults for <code class="highlighter-rouge">equals</code>, <code class="highlighter-rouge">hashCode</code> and <code class="highlighter-rouge">toString</code>, so why not for that?)</p>

<p>In any case, you can see a pattern here: Each element of the case class is added separately.
Here, we could have even delegated the addition to our <code class="highlighter-rouge">intInstance</code> from above.</p>

<p>In essence, what we need is a way to combine smaller instances (e.g. for <code class="highlighter-rouge">Int</code>) into larger instances (e.g. for <code class="highlighter-rouge">Vector3D</code> consisting of three <code class="highlighter-rouge">Int</code>s).
Luckily, this is completely mechanic. As an exercise, try writing the following instance:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="n">tupleInstance</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">t1</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">),</span> <span class="n">t2</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="representing-data-types">Representing data types</h2>

<p>Once we know how to produce an instance for a pair, we can apply that two times and obtain an instance for a triple.
However, there are still two problems here:</p>

<ol>
  <li>We would like an instance for <code class="highlighter-rouge">Vector3D</code>, but we have an instance for <code class="highlighter-rouge">(Int, Int, Int)</code>.</li>
  <li>This is still a lie. We actually have an instance for <code class="highlighter-rouge">(Int, (Int, Int))</code>.</li>
</ol>

<p>Let us address these problems now. The following sections assume familiarity with <code class="highlighter-rouge">HList</code>s, as implemented in <em>shapeless</em>.</p>

<div class="side-note">
  If you are not familiar with <code>HList</code>s yet,
  watch Miles Sabin's <a href="http://www.youtube.com/watch?v=GDbNxL8bqkY">talk about <em>shapeless</em></a> at the Northeast Scala Symposium 2012.
  There's also a <a href="http://apocalisp.wordpress.com/2010/06/08/type-level-programming-in-scala/">blog series</a> exploring type-level programming in general by Mark Harrah.
</div>

<p>Now, we want to generate an instance for <code class="highlighter-rouge">Vector3D</code> and countless other data types.
That means that we cannot just special-case for every possible data type, but we have to abstract over them.
The trick is actually quite simple:
For the purposes of automatic instance derivation, we temporarily convert data types into a canonical <em>representation</em> using <code class="highlighter-rouge">HList</code>s, where each case class parameter corresponds to an element in the <code class="highlighter-rouge">HList</code>.</p>

<p>In our example, that representation is <code class="highlighter-rouge">Int :: Int :: Int :: HNil</code>.
Yes, that type is completely equivalent to <code class="highlighter-rouge">Vector3D</code>, and you can implement the conversion functions straightforwardly:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">to</span><span class="o">(</span><span class="n">vec</span><span class="k">:</span> <span class="kt">Vector3D</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span> <span class="o">=</span>
  <span class="n">vec</span><span class="o">.</span><span class="n">x</span> <span class="o">::</span> <span class="n">vec</span><span class="o">.</span><span class="n">y</span> <span class="o">::</span> <span class="n">vec</span><span class="o">.</span><span class="n">z</span> <span class="o">::</span> <span class="nc">HNil</span>

<span class="k">def</span> <span class="n">from</span><span class="o">(</span><span class="n">hlist</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">Int</span> <span class="kt">::</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span>
  <span class="o">???</span> <span class="c1">// fun exercise!
</span></code></pre></div></div>

<p>Because we are lazy, we let a macro automatically generate the <code class="highlighter-rouge">to</code> and <code class="highlighter-rouge">from</code> methods.
We will see in the second part of the series how that works.
For now, just assume that you can invoke some method, magic happens, and you get the conversions out.</p>

<h2 id="using-the-representation">Using the representation</h2>

<p>At this point, we have a canonical representation for arbitrary case classes.
We will also assume that there are <code class="highlighter-rouge">Semigroup</code> instances for each of its elements.
Now we would like to combine those base instances into an instance for the representation.
We need two implicits for that:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">nilInstance</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">HNil</span><span class="o">)</span> <span class="k">=</span> <span class="nc">HNil</span>
  <span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">consInstance</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="k">implicit</span> <span class="k">val</span> <span class="n">H</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="c1">// actual implementation doesn't matter that much
</span>    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">???</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>The key insight is that the compiler can come up with an instance for <code class="highlighter-rouge">Int :: Int :: Int :: HNil</code>, just because these two implicits are in scope.</p>

<p>Now we just need a way to get an instance for <code class="highlighter-rouge">Vector3D</code>.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">Semigroup</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=</span>
      <span class="n">from</span><span class="o">(</span><span class="n">instance</span><span class="o">.</span><span class="n">append</span><span class="o">(</span><span class="n">to</span><span class="o">(</span><span class="n">a1</span><span class="o">),</span> <span class="n">to</span><span class="o">(</span><span class="n">a2</span><span class="o">))</span>
  <span class="o">}</span>
</code></pre></div></div>

<p>Easy enough, right?
To get our much-wanted <code class="highlighter-rouge">Semigroup[Vector3D]</code>, we ask the compiler to make an instance its <code class="highlighter-rouge">HList</code> representation, conjure the conversion functions and plug all that stuff into the <code class="highlighter-rouge">subst</code> machine. Voilà, done!
Add some teaspoons of macros, and we are able to write</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Semigroup</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
</code></pre></div></div>

<p>Are we done yet? No. We can go even further.</p>

<h2 id="abstracting-over-type-classes">Abstracting over type classes</h2>

<p><code class="highlighter-rouge">Semigroup</code> is not the only type class around. For example, there is a whole tower of classes from group theory for varying use cases. Then there are some type classes from <em>scalaz</em>:</p>

<ul>
  <li><code class="highlighter-rouge">Show</code> provides a way to convert a value to a <code class="highlighter-rouge">String</code></li>
  <li><code class="highlighter-rouge">Equal</code> for type-safe equality</li>
  <li><code class="highlighter-rouge">Order</code> provides total ordering on values</li>
</ul>

<p>… and many more!</p>

<p>Another key insight is that <em>all</em> of those classes are able to deal with <code class="highlighter-rouge">HLists</code> and also support the <code class="highlighter-rouge">subst</code> operation.
Hence, one could be tempted to write:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Show</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="nc">Equal</span><span class="o">.</span><span class="n">derive</span><span class="o">[</span><span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// and more
</span></code></pre></div></div>

<p>I hate duplication, though. I do not want to implement the <code class="highlighter-rouge">derive</code> macro over and over again.
Now, if only there was a way to abstract over common functionality of types …</p>

<h2 id="a-type-class-called-typeclass">A type class called “TypeClass”</h2>

<p>“What,” I hear you saying, “the <code class="highlighter-rouge">TypeClass</code> type class? You can’t be serious!”</p>

<p>I am serious.</p>

<p>We use type classes to abstract over types.
<code class="highlighter-rouge">Semigroup</code> abstracts over types which offer some sort of addition functionality.</p>

<p>However, type classes are themselves just types in Scala.
Thus, we can use type classes to abstract over type classes.
We are defining a type class which abstracts over type classes whose instances can be combined to form larger instances.</p>

<p>So, without further ado:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">C</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">nil</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">HNil</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">cons</span><span class="o">[</span><span class="kt">H</span>, <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">HList</span><span class="o">](</span><span class="n">H</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span><span class="o">],</span> <span class="n">T</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">H</span> <span class="kt">::</span> <span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">subst</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">to</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">from</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">,</span> <span class="n">instance</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>This should actually be not too surprising. We already know exactly how to implement <code class="highlighter-rouge">TypeClass[Semigroup]</code>.
If we put this implementation into the companion object of <code class="highlighter-rouge">Semigroup</code>, it will be available for the macro to use.</p>

<h2 id="wrapping-it-up">Wrapping it up</h2>

<p>How can this actually be used?
The work can be roughly divided between three roles:</p>

<ol>
  <li>
    <p>The macro author, who has to implement all the nitty-gritty details of the derivation process.</p>

    <p>That is already done and implemented in <em>shapeless</em>.
The upcoming 2.0.0 release will contain all the necessary bits and pieces, but requires at least Scala 2.10.2 (it will not work for 2.10.1 or earlier).
If you are brave, try the latest snapshot version which is available on Sonatype.</p>
  </li>
  <li>
    <p>The library author, who defines type classes, fundamental instances thereof, and of course the necessary <code class="highlighter-rouge">TypeClass</code> instances.</p>

    <p>These are usually contained in the libraries you use, but the last part will additionally require a bridge library.
But fear not, those bridge libraries already exist, at least for the typelevel.scala libraries, and can be readily added as dependency for your build.
Head over to the <a href="https://github.com/typelevel/shapeless-contrib#readme">GitHub project</a>, we will keep you posted for when a new version comes out.
We also plan to put a compatibility chart on this site.</p>
  </li>
  <li>
    <p>The library user, who defines data types and wants to get instances without all the boilerplate.</p>

    <p>This is the simplest task of all: All you have to do is to put</p>

    <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">val</span> <span class="n">myInstance</span> <span class="k">=</span> <span class="nc">TypeClass</span><span class="o">[</span><span class="kt">Semigroup</span>, <span class="kt">Vector3D</span><span class="o">]</span>
<span class="c1">// or
</span><span class="k">import</span> <span class="nn">Semigroup.auto._</span>
</code></pre></div>    </div>

    <p>somewhere into your scope, and you are done!</p>

    <p>Providing “explicit” implicit declarations for each type class instance provides the tightest control over your implicit scope and ensures you only have the instances that you want.
Importing <code class="highlighter-rouge">auto</code> reduces the boilerplate to the absolute minimum, which is often desirable, but might result in more instances being materialized than you expect.
Which to choose is partly a matter of taste and partly a function of the size and complexity of the scopes you are importing in to:
large or complex scopes might favour explicit declarations; tighter, simpler scopes might favour <code class="highlighter-rouge">auto</code>.</p>
  </li>
</ol>


<h2>Licensing</h2>
<p>
  Unless otherwise noted, all content is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.
</p>


  <div class="post__author js-fade-in">
    
    
      
      <p>by Lars Hupel
    
    on Jun 24, 2013</p>

    
  <a href="https://twitter.com/larsr_h" class="twitter-follow-button" data-show-count="false" data-dnt="true">Follow @larsr_h</a>
  <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>


  <a class="github-button" href="https://github.com/larsrh" aria-label="Follow @larsrh on GitHub">Follow @larsrh</a>
  <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>


  </div>
  <a class="btn text" href="/blog">Back to blog</a>

  <br style="clear:both;">
<div class="disqus-container" style="padding-top:1em;">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'typelevel'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

</div>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {inlineMath: [['$','$']]}
  });
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


    </div>

    <div class="footer">
      <div class="wrapper">
        <p>Copyright &copy; 2013-2018 the <a href="/">typelevel.org</a> <a href="/contributors.html">contributors</a>.</p>
        <ul class="navigation">
          <li><a href="/projects">Projects</a></li>
          <li><a href="/events">Events</a></li>
          <li><a href="/blog">Blog</a></li>
          <li><a href="/about">About</a></li>
        </ul>
      </div>
    </div>
    
  <!-- Salvattore.js for the masonry layout -->
  <script type="text/javascript" src="/js/salvattore.min.js"></script>
  <!-- Salvattore.js for the masonry layout -->
  </body>
</html>
